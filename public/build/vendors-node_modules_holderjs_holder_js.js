(self["webpackChunk"] = self["webpackChunk"] || []).push([["vendors-node_modules_holderjs_holder_js"],{

/***/ "./node_modules/holderjs/holder.js":
/*!*****************************************!*\
  !*** ./node_modules/holderjs/holder.js ***!
  \*****************************************/
/***/ (function(module) {

/*!

Holder - client side image placeholders
Version 2.9.9+jl7z
Â© 2021 Ivan Malopinsky - https://imsky.co

Site:     http://holderjs.com
Issues:   https://github.com/imsky/holder/issues
License:  MIT

*/
(function (window) {
  if (!window.document) return;
  var document = window.document;

  //https://github.com/inexorabletash/polyfill/blob/master/web.js
    if (!document.querySelectorAll) {
      document.querySelectorAll = function (selectors) {
        var style = document.createElement('style'), elements = [], element;
        document.documentElement.firstChild.appendChild(style);
        document._qsa = [];

        style.styleSheet.cssText = selectors + '{x-qsa:expression(document._qsa && document._qsa.push(this))}';
        window.scrollBy(0, 0);
        style.parentNode.removeChild(style);

        while (document._qsa.length) {
          element = document._qsa.shift();
          element.style.removeAttribute('x-qsa');
          elements.push(element);
        }
        document._qsa = null;
        return elements;
      };
    }

    if (!document.querySelector) {
      document.querySelector = function (selectors) {
        var elements = document.querySelectorAll(selectors);
        return (elements.length) ? elements[0] : null;
      };
    }

    if (!document.getElementsByClassName) {
      document.getElementsByClassName = function (classNames) {
        classNames = String(classNames).replace(/^|\s+/g, '.');
        return document.querySelectorAll(classNames);
      };
    }

  //https://github.com/inexorabletash/polyfill
  // ES5 15.2.3.14 Object.keys ( O )
  // https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Object/keys
  if (!Object.keys) {
    Object.keys = function (o) {
      if (o !== Object(o)) { throw TypeError('Object.keys called on non-object'); }
      var ret = [], p;
      for (p in o) {
        if (Object.prototype.hasOwnProperty.call(o, p)) {
          ret.push(p);
        }
      }
      return ret;
    };
  }

  // ES5 15.4.4.18 Array.prototype.forEach ( callbackfn [ , thisArg ] )
  // From https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/forEach
  if (!Array.prototype.forEach) {
    Array.prototype.forEach = function (fun /*, thisp */) {
      if (this === void 0 || this === null) { throw TypeError(); }

      var t = Object(this);
      var len = t.length >>> 0;
      if (typeof fun !== "function") { throw TypeError(); }

      var thisp = arguments[1], i;
      for (i = 0; i < len; i++) {
        if (i in t) {
          fun.call(thisp, t[i], i, t);
        }
      }
    };
  }

  //https://github.com/inexorabletash/polyfill/blob/master/web.js
  (function (global) {
    var B64_ALPHABET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
    global.atob = global.atob || function (input) {
      input = String(input);
      var position = 0,
          output = [],
          buffer = 0, bits = 0, n;

      input = input.replace(/\s/g, '');
      if ((input.length % 4) === 0) { input = input.replace(/=+$/, ''); }
      if ((input.length % 4) === 1) { throw Error('InvalidCharacterError'); }
      if (/[^+/0-9A-Za-z]/.test(input)) { throw Error('InvalidCharacterError'); }

      while (position < input.length) {
        n = B64_ALPHABET.indexOf(input.charAt(position));
        buffer = (buffer << 6) | n;
        bits += 6;

        if (bits === 24) {
          output.push(String.fromCharCode((buffer >> 16) & 0xFF));
          output.push(String.fromCharCode((buffer >>  8) & 0xFF));
          output.push(String.fromCharCode(buffer & 0xFF));
          bits = 0;
          buffer = 0;
        }
        position += 1;
      }

      if (bits === 12) {
        buffer = buffer >> 4;
        output.push(String.fromCharCode(buffer & 0xFF));
      } else if (bits === 18) {
        buffer = buffer >> 2;
        output.push(String.fromCharCode((buffer >> 8) & 0xFF));
        output.push(String.fromCharCode(buffer & 0xFF));
      }

      return output.join('');
    };

    global.btoa = global.btoa || function (input) {
      input = String(input);
      var position = 0,
          out = [],
          o1, o2, o3,
          e1, e2, e3, e4;

      if (/[^\x00-\xFF]/.test(input)) { throw Error('InvalidCharacterError'); }

      while (position < input.length) {
        o1 = input.charCodeAt(position++);
        o2 = input.charCodeAt(position++);
        o3 = input.charCodeAt(position++);

        // 111111 112222 222233 333333
        e1 = o1 >> 2;
        e2 = ((o1 & 0x3) << 4) | (o2 >> 4);
        e3 = ((o2 & 0xf) << 2) | (o3 >> 6);
        e4 = o3 & 0x3f;

        if (position === input.length + 2) {
          e3 = 64; e4 = 64;
        }
        else if (position === input.length + 1) {
          e4 = 64;
        }

        out.push(B64_ALPHABET.charAt(e1),
                 B64_ALPHABET.charAt(e2),
                 B64_ALPHABET.charAt(e3),
                 B64_ALPHABET.charAt(e4));
      }

      return out.join('');
    };
  }(window));

  //https://gist.github.com/jimeh/332357
  if (!Object.prototype.hasOwnProperty){
      /*jshint -W001, -W103 */
      Object.prototype.hasOwnProperty = function(prop) {
      var proto = this.__proto__ || this.constructor.prototype;
      return (prop in this) && (!(prop in proto) || proto[prop] !== this[prop]);
    };
      /*jshint +W001, +W103 */
  }

  // @license http://opensource.org/licenses/MIT
  // copyright Paul Irish 2015


  // Date.now() is supported everywhere except IE8. For IE8 we use the Date.now polyfill
  //   github.com/Financial-Times/polyfill-service/blob/master/polyfills/Date.now/polyfill.js
  // as Safari 6 doesn't have support for NavigationTiming, we use a Date.now() timestamp for relative values

  // if you want values similar to what you'd get with real perf.now, place this towards the head of the page
  // but in reality, you're just getting the delta between now() calls, so it's not terribly important where it's placed


  (function(){

    if ('performance' in window === false) {
        window.performance = {};
    }
    
    Date.now = (Date.now || function () {  // thanks IE8
      return new Date().getTime();
    });

    if ('now' in window.performance === false){
      
      var nowOffset = Date.now();
      
      if (performance.timing && performance.timing.navigationStart){
        nowOffset = performance.timing.navigationStart;
      }

      window.performance.now = function now(){
        return Date.now() - nowOffset;
      };
    }

  })();

  //requestAnimationFrame polyfill for older Firefox/Chrome versions
  if (!window.requestAnimationFrame) {
    if (window.webkitRequestAnimationFrame && window.webkitCancelAnimationFrame) {
    //https://github.com/Financial-Times/polyfill-service/blob/master/polyfills/requestAnimationFrame/polyfill-webkit.js
    (function (global) {
      global.requestAnimationFrame = function (callback) {
        return webkitRequestAnimationFrame(function () {
          callback(global.performance.now());
        });
      };

      global.cancelAnimationFrame = global.webkitCancelAnimationFrame;
    }(window));
    } else if (window.mozRequestAnimationFrame && window.mozCancelAnimationFrame) {
      //https://github.com/Financial-Times/polyfill-service/blob/master/polyfills/requestAnimationFrame/polyfill-moz.js
    (function (global) {
      global.requestAnimationFrame = function (callback) {
        return mozRequestAnimationFrame(function () {
          callback(global.performance.now());
        });
      };

      global.cancelAnimationFrame = global.mozCancelAnimationFrame;
    }(window));
    } else {
    (function (global) {
      global.requestAnimationFrame = function (callback) {
        return global.setTimeout(callback, 1000 / 60);
      };

      global.cancelAnimationFrame = global.clearTimeout;
    })(window);
    }
  }
})(this);

(function webpackUniversalModuleDefinition(root, factory) {
	if(true)
		module.exports = factory();
	else {}
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __nested_webpack_require_8420__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_8420__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__nested_webpack_require_8420__.m = modules;

/******/ 	// expose the module cache
/******/ 	__nested_webpack_require_8420__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__nested_webpack_require_8420__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __nested_webpack_require_8420__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __nested_webpack_require_9621__) {

	/*
	Holder.js - client side image placeholders
	(c) 2012-2020 Ivan Malopinsky - https://imsky.co
	*/

	module.exports = __nested_webpack_require_9621__(1);


/***/ }),
/* 1 */
/***/ (function(module, exports, __nested_webpack_require_9843__) {

	/* WEBPACK VAR INJECTION */(function(global) {/*
	Holder.js - client side image placeholders
	(c) 2012-2020 Ivan Malopinsky - http://imsky.co
	*/

	//Libraries and functions
	var onDomReady = __nested_webpack_require_9843__(2);
	var querystring = __nested_webpack_require_9843__(3);

	var SceneGraph = __nested_webpack_require_9843__(6);
	var utils = __nested_webpack_require_9843__(7);
	var SVG = __nested_webpack_require_9843__(8);
	var DOM = __nested_webpack_require_9843__(9);
	var Color = __nested_webpack_require_9843__(10);
	var constants = __nested_webpack_require_9843__(11);

	var svgRenderer = __nested_webpack_require_9843__(12);
	var sgCanvasRenderer = __nested_webpack_require_9843__(27);

	var extend = utils.extend;
	var dimensionCheck = utils.dimensionCheck;

	//Constants and definitions
	var SVG_NS = constants.svg_ns;

	var Holder = {
	    version: constants.version,

	    /**
	     * Adds a theme to default settings
	     *
	     * @param {string} name Theme name
	     * @param {Object} theme Theme object, with foreground, background, size, font, and fontweight properties.
	     */
	    addTheme: function(name, theme) {
	        name != null && theme != null && (App.settings.themes[name] = theme);
	        delete App.vars.cache.themeKeys;
	        return this;
	    },

	    /**
	     * Appends a placeholder to an element
	     *
	     * @param {string} src Placeholder URL string
	     * @param el A selector or a reference to a DOM node
	     */
	    addImage: function(src, el) {
	        //todo: use jquery fallback if available for all QSA references
	        var nodes = DOM.getNodeArray(el);
	        nodes.forEach(function (node) {
	            var img = DOM.newEl('img');
	            var domProps = {};
	            domProps[App.setup.dataAttr] = src;
	            DOM.setAttr(img, domProps);
	            node.appendChild(img);
	        });
	        return this;
	    },

	    /**
	     * Sets whether or not an image is updated on resize.
	     * If an image is set to be updated, it is immediately rendered.
	     *
	     * @param {Object} el Image DOM element
	     * @param {Boolean} value Resizable update flag value
	     */
	    setResizeUpdate: function(el, value) {
	        if (el.holderData) {
	            el.holderData.resizeUpdate = !!value;
	            if (el.holderData.resizeUpdate) {
	                updateResizableElements(el);
	            }
	        }
	    },

	    /**
	     * Runs Holder with options. By default runs Holder on all images with "holder.js" in their source attributes.
	     *
	     * @param {Object} userOptions Options object, can contain domain, themes, images, and bgnodes properties
	     */
	    run: function(userOptions) {
	        //todo: split processing into separate queues
	        userOptions = userOptions || {};
	        var engineSettings = {};
	        var options = extend(App.settings, userOptions);

	        App.vars.preempted = true;
	        App.vars.dataAttr = options.dataAttr || App.setup.dataAttr;

	        engineSettings.renderer = options.renderer ? options.renderer : App.setup.renderer;
	        if (App.setup.renderers.join(',').indexOf(engineSettings.renderer) === -1) {
	            engineSettings.renderer = App.setup.supportsSVG ? 'svg' : (App.setup.supportsCanvas ? 'canvas' : 'html');
	        }

	        var images = DOM.getNodeArray(options.images);
	        var bgnodes = DOM.getNodeArray(options.bgnodes);
	        var stylenodes = DOM.getNodeArray(options.stylenodes);
	        var objects = DOM.getNodeArray(options.objects);

	        engineSettings.stylesheets = [];
	        engineSettings.svgXMLStylesheet = true;
	        engineSettings.noFontFallback = !!options.noFontFallback;
	        engineSettings.noBackgroundSize = !!options.noBackgroundSize;

	        stylenodes.forEach(function (styleNode) {
	            if (styleNode.attributes.rel && styleNode.attributes.href && styleNode.attributes.rel.value == 'stylesheet') {
	                var href = styleNode.attributes.href.value;
	                //todo: write isomorphic relative-to-absolute URL function
	                var proxyLink = DOM.newEl('a');
	                proxyLink.href = href;
	                var stylesheetURL = proxyLink.protocol + '//' + proxyLink.host + proxyLink.pathname + proxyLink.search;
	                engineSettings.stylesheets.push(stylesheetURL);
	            }
	        });

	        bgnodes.forEach(function (bgNode) {
	            //Skip processing background nodes if getComputedStyle is unavailable, since only modern browsers would be able to use canvas or SVG to render to background
	            if (!global.getComputedStyle) return;
	            var backgroundImage = global.getComputedStyle(bgNode, null).getPropertyValue('background-image');
	            var dataBackgroundImage = bgNode.getAttribute('data-background-src');
	            var rawURL = dataBackgroundImage || backgroundImage;

	            var holderURL = null;
	            var holderString = options.domain + '/';
	            var holderStringIndex = rawURL.indexOf(holderString);

	            if (holderStringIndex === 0) {
	                holderURL = rawURL;
	            } else if (holderStringIndex === 1 && rawURL[0] === '?') {
	                holderURL = rawURL.slice(1);
	            } else {
	                var fragment = rawURL.substr(holderStringIndex).match(/([^"]*)"?\)/);
	                if (fragment !== null) {
	                    holderURL = fragment[1];
	                } else if (rawURL.indexOf('url(') === 0) {
	                    throw 'Holder: unable to parse background URL: ' + rawURL;
	                }
	            }

	            if (holderURL) {
	                var holderFlags = parseURL(holderURL, options);
	                if (holderFlags) {
	                    prepareDOMElement({
	                        mode: 'background',
	                        el: bgNode,
	                        flags: holderFlags,
	                        engineSettings: engineSettings
	                    });
	                }
	            }
	        });

	        objects.forEach(function (object) {
	            var objectAttr = {};

	            try {
	                objectAttr.data = object.getAttribute('data');
	                objectAttr.dataSrc = object.getAttribute(App.vars.dataAttr);
	            } catch (e) {
	              objectAttr.error = e;
	            }

	            var objectHasSrcURL = objectAttr.data != null && objectAttr.data.indexOf(options.domain) === 0;
	            var objectHasDataSrcURL = objectAttr.dataSrc != null && objectAttr.dataSrc.indexOf(options.domain) === 0;

	            if (objectHasSrcURL) {
	                prepareImageElement(options, engineSettings, objectAttr.data, object);
	            } else if (objectHasDataSrcURL) {
	                prepareImageElement(options, engineSettings, objectAttr.dataSrc, object);
	            }
	        });

	        images.forEach(function (image) {
	            var imageAttr = {};

	            try {
	                imageAttr.src = image.getAttribute('src');
	                imageAttr.dataSrc = image.getAttribute(App.vars.dataAttr);
	                imageAttr.rendered = image.getAttribute('data-holder-rendered');
	            } catch (e) {
	              imageAttr.error = e;
	            }

	            var imageHasSrc = imageAttr.src != null;
	            var imageHasDataSrcURL = imageAttr.dataSrc != null && imageAttr.dataSrc.indexOf(options.domain) === 0;
	            var imageRendered = imageAttr.rendered != null && imageAttr.rendered == 'true';

	            if (imageHasSrc) {
	                if (imageAttr.src.indexOf(options.domain) === 0) {
	                    prepareImageElement(options, engineSettings, imageAttr.src, image);
	                } else if (imageHasDataSrcURL) {
	                    //Image has a valid data-src and an invalid src
	                    if (imageRendered) {
	                        //If the placeholder has already been render, re-render it
	                        prepareImageElement(options, engineSettings, imageAttr.dataSrc, image);
	                    } else {
	                        //If the placeholder has not been rendered, check if the image exists and render a fallback if it doesn't
	                        (function(src, options, engineSettings, dataSrc, image) {
	                            utils.imageExists(src, function(exists) {
	                                if (!exists) {
	                                    prepareImageElement(options, engineSettings, dataSrc, image);
	                                }
	                            });
	                        })(imageAttr.src, options, engineSettings, imageAttr.dataSrc, image);
	                    }
	                }
	            } else if (imageHasDataSrcURL) {
	                prepareImageElement(options, engineSettings, imageAttr.dataSrc, image);
	            }
	        });

	        return this;
	    }
	};

	var App = {
	    settings: {
	        domain: 'holder.js',
	        images: 'img',
	        objects: 'object',
	        bgnodes: 'body .holderjs',
	        stylenodes: 'head link.holderjs',
	        themes: {
	            'gray': {
	                bg: '#EEEEEE',
	                fg: '#AAAAAA'
	            },
	            'social': {
	                bg: '#3a5a97',
	                fg: '#FFFFFF'
	            },
	            'industrial': {
	                bg: '#434A52',
	                fg: '#C2F200'
	            },
	            'sky': {
	                bg: '#0D8FDB',
	                fg: '#FFFFFF'
	            },
	            'vine': {
	                bg: '#39DBAC',
	                fg: '#1E292C'
	            },
	            'lava': {
	                bg: '#F8591A',
	                fg: '#1C2846'
	            }
	        }
	    },
	    defaults: {
	        size: 10,
	        units: 'pt',
	        scale: 1 / 16
	    }
	};

	/**
	 * Processes provided source attribute and sets up the appropriate rendering workflow
	 *
	 * @private
	 * @param options Instance options from Holder.run
	 * @param renderSettings Instance configuration
	 * @param src Image URL
	 * @param el Image DOM element
	 */
	function prepareImageElement(options, engineSettings, src, el) {
	    var holderFlags = parseURL(src.substr(src.lastIndexOf(options.domain)), options);
	    if (holderFlags) {
	        prepareDOMElement({
	            mode: null,
	            el: el,
	            flags: holderFlags,
	            engineSettings: engineSettings
	        });
	    }
	}

	/**
	 * Processes a Holder URL and extracts configuration from query string
	 *
	 * @private
	 * @param url URL
	 * @param instanceOptions Instance options from Holder.run
	 */
	function parseURL(url, instanceOptions) {
	    var holder = {
	        theme: extend(App.settings.themes.gray, null),
	        stylesheets: instanceOptions.stylesheets,
	        instanceOptions: instanceOptions
	    };

	    var firstQuestionMark = url.indexOf('?');
	    var parts = [url];

	    if (firstQuestionMark !== -1) {
	        parts = [url.slice(0, firstQuestionMark), url.slice(firstQuestionMark + 1)];
	    }

	    var basics = parts[0].split('/');

	    holder.holderURL = url;

	    var dimensions = basics[1];
	    var dimensionData = dimensions.match(/([\d]+p?)x([\d]+p?)/);

	    if (!dimensionData) return false;

	    holder.fluid = dimensions.indexOf('p') !== -1;

	    holder.dimensions = {
	        width: dimensionData[1].replace('p', '%'),
	        height: dimensionData[2].replace('p', '%')
	    };

	    if (parts.length === 2) {
	        var options = querystring.parse(parts[1]);

	        // Dimensions

	        if (utils.truthy(options.ratio)) {
	            holder.fluid = true;
	            var ratioWidth = parseFloat(holder.dimensions.width.replace('%', ''));
	            var ratioHeight = parseFloat(holder.dimensions.height.replace('%', ''));

	            ratioHeight = Math.floor(100 * (ratioHeight / ratioWidth));
	            ratioWidth = 100;

	            holder.dimensions.width = ratioWidth + '%';
	            holder.dimensions.height = ratioHeight + '%';
	        }

	        holder.auto = utils.truthy(options.auto);

	        // Colors

	        if (options.bg) {
	            holder.theme.bg = utils.parseColor(options.bg);
	        }

	        if (options.fg) {
	            holder.theme.fg = utils.parseColor(options.fg);
	        }

	        //todo: add automatic foreground to themes without foreground
	        if (options.bg && !options.fg) {
	            holder.autoFg = true;
	        }

	        if (options.theme && Object.prototype.hasOwnProperty.call(holder.instanceOptions.themes, options.theme)) {
	            holder.theme = extend(holder.instanceOptions.themes[options.theme], null);
	        }

	        // Text

	        if (options.text) {
	            holder.text = options.text;
	        }

	        if (options.textmode) {
	            holder.textmode = options.textmode;
	        }

	        if (options.size && parseFloat(options.size)) {
	            holder.size = parseFloat(options.size);
	        }

	        if (options.fixedSize != null) {
	            holder.fixedSize = utils.truthy(options.fixedSize);
	        }

	        if (options.font) {
	            holder.font = options.font;
	        }

	        if (options.align) {
	            holder.align = options.align;
	        }

	        if (options.lineWrap) {
	            holder.lineWrap = options.lineWrap;
	        }

	        holder.nowrap = utils.truthy(options.nowrap);

	        // Miscellaneous

	        holder.outline = utils.truthy(options.outline);

	        if (utils.truthy(options.random)) {
	            App.vars.cache.themeKeys = App.vars.cache.themeKeys || Object.keys(holder.instanceOptions.themes);
	            var _theme = App.vars.cache.themeKeys[0 | Math.random() * App.vars.cache.themeKeys.length];
	            holder.theme = extend(holder.instanceOptions.themes[_theme], null);
	        }
	    }

	    return holder;
	}

	/**
	 * Modifies the DOM to fit placeholders and sets up resizable image callbacks (for fluid and automatically sized placeholders)
	 *
	 * @private
	 * @param settings DOM prep settings
	 */
	function prepareDOMElement(prepSettings) {
	    var mode = prepSettings.mode;
	    var el = prepSettings.el;
	    var flags = prepSettings.flags;
	    var _engineSettings = prepSettings.engineSettings;
	    var dimensions = flags.dimensions,
	        theme = flags.theme;
	    var dimensionsCaption = dimensions.width + 'x' + dimensions.height;
	    mode = mode == null ? (flags.fluid ? 'fluid' : 'image') : mode;
	    var holderTemplateRe = /holder_([a-z]+)/g;
	    var dimensionsInText = false;

	    if (flags.text != null) {
	        theme.text = flags.text;

	        //<object> SVG embedding doesn't parse Unicode properly
	        if (el.nodeName.toLowerCase() === 'object') {
	            var textLines = theme.text.split('\\n');
	            for (var k = 0; k < textLines.length; k++) {
	                textLines[k] = utils.encodeHtmlEntity(textLines[k]);
	            }
	            theme.text = textLines.join('\\n');
	        }
	    }

	    if (theme.text) {
	        var holderTemplateMatches = theme.text.match(holderTemplateRe);

	        if (holderTemplateMatches !== null) {
	            //todo: optimize template replacement
	            holderTemplateMatches.forEach(function (match) {
	                if (match === 'holder_dimensions') {
	                    theme.text = theme.text.replace(match, dimensionsCaption);
	                }
	            });
	        }
	    }

	    var holderURL = flags.holderURL;
	    var engineSettings = extend(_engineSettings, null);

	    if (flags.font) {
	        /*
	        If external fonts are used in a <img> placeholder rendered with SVG, Holder falls back to canvas.

	        This is done because Firefox and Chrome disallow embedded SVGs from referencing external assets.
	        The workaround is either to change the placeholder tag from <img> to <object> or to use the canvas renderer.
	        */
	        theme.font = flags.font;
	        if (!engineSettings.noFontFallback && el.nodeName.toLowerCase() === 'img' && App.setup.supportsCanvas && engineSettings.renderer === 'svg') {
	            engineSettings = extend(engineSettings, {
	                renderer: 'canvas'
	            });
	        }
	    }

	    //Chrome and Opera require a quick 10ms re-render if web fonts are used with canvas
	    if (flags.font && engineSettings.renderer == 'canvas') {
	        engineSettings.reRender = true;
	    }

	    if (mode == 'background') {
	        if (el.getAttribute('data-background-src') == null) {
	            DOM.setAttr(el, {
	                'data-background-src': holderURL
	            });
	        }
	    } else {
	        var domProps = {};
	        domProps[App.vars.dataAttr] = holderURL;
	        DOM.setAttr(el, domProps);
	    }

	    flags.theme = theme;

	    //todo consider using all renderSettings in holderData
	    el.holderData = {
	        flags: flags,
	        engineSettings: engineSettings
	    };

	    if (mode == 'image' || mode == 'fluid') {
	        DOM.setAttr(el, {
	            'alt': theme.text ? (dimensionsInText ? theme.text : theme.text + ' [' + dimensionsCaption + ']') : dimensionsCaption
	        });
	    }

	    var renderSettings = {
	        mode: mode,
	        el: el,
	        holderSettings: {
	            dimensions: dimensions,
	            theme: theme,
	            flags: flags
	        },
	        engineSettings: engineSettings
	    };

	    if (mode == 'image') {
	        if (!flags.auto) {
	            el.style.width = dimensions.width + 'px';
	            el.style.height = dimensions.height + 'px';
	        }

	        if (engineSettings.renderer == 'html') {
	            el.style.backgroundColor = theme.bg;
	        } else {
	            render(renderSettings);

	            if (flags.textmode == 'exact') {
	                el.holderData.resizeUpdate = true;
	                App.vars.resizableImages.push(el);
	                updateResizableElements(el);
	            }
	        }
	    } else if (mode == 'background' && engineSettings.renderer != 'html') {
	        render(renderSettings);
	    } else if (mode == 'fluid') {
	        el.holderData.resizeUpdate = true;

	        if (dimensions.height.slice(-1) == '%') {
	            el.style.height = dimensions.height;
	        } else if (flags.auto == null || !flags.auto) {
	            el.style.height = dimensions.height + 'px';
	        }
	        if (dimensions.width.slice(-1) == '%') {
	            el.style.width = dimensions.width;
	        } else if (flags.auto == null || !flags.auto) {
	            el.style.width = dimensions.width + 'px';
	        }
	        if (el.style.display == 'inline' || el.style.display === '' || el.style.display == 'none') {
	            el.style.display = 'block';
	        }

	        setInitialDimensions(el);

	        if (engineSettings.renderer == 'html') {
	            el.style.backgroundColor = theme.bg;
	        } else {
	            App.vars.resizableImages.push(el);
	            updateResizableElements(el);
	        }
	    }
	}

	/**
	 * Core function that takes output from renderers and sets it as the source or background-image of the target element
	 *
	 * @private
	 * @param renderSettings Renderer settings
	 */
	function render(renderSettings) {
	    var image = null;
	    var mode = renderSettings.mode;
	    var el = renderSettings.el;
	    var holderSettings = renderSettings.holderSettings;
	    var engineSettings = renderSettings.engineSettings;

	    switch (engineSettings.renderer) {
	        case 'svg':
	            if (!App.setup.supportsSVG) return;
	            break;
	        case 'canvas':
	            if (!App.setup.supportsCanvas) return;
	            break;
	        default:
	            return;
	    }

	    //todo: move generation of scene up to flag generation to reduce extra object creation
	    var scene = {
	        width: holderSettings.dimensions.width,
	        height: holderSettings.dimensions.height,
	        theme: holderSettings.theme,
	        flags: holderSettings.flags
	    };

	    var sceneGraph = buildSceneGraph(scene);

	    function getRenderedImage() {
	        var image = null;
	        switch (engineSettings.renderer) {
	            case 'canvas':
	                image = sgCanvasRenderer(sceneGraph, renderSettings);
	                break;
	            case 'svg':
	                image = svgRenderer(sceneGraph, renderSettings);
	                break;
	            default:
	                throw 'Holder: invalid renderer: ' + engineSettings.renderer;
	        }

	        return image;
	    }

	    image = getRenderedImage();

	    if (image == null) {
	        throw 'Holder: couldn\'t render placeholder';
	    }

	    //todo: add <object> canvas rendering
	    if (mode == 'background') {
	        el.style.backgroundImage = 'url(' + image + ')';

	        if (!engineSettings.noBackgroundSize) {
	            el.style.backgroundSize = scene.width + 'px ' + scene.height + 'px';
	        }
	    } else {
	        if (el.nodeName.toLowerCase() === 'img') {
	            DOM.setAttr(el, {
	                'src': image
	            });
	        } else if (el.nodeName.toLowerCase() === 'object') {
	            DOM.setAttr(el, {
	                'data': image,
	                'type': 'image/svg+xml'
	            });
	        }
	        if (engineSettings.reRender) {
	            global.setTimeout(function () {
	                var image = getRenderedImage();
	                if (image == null) {
	                    throw 'Holder: couldn\'t render placeholder';
	                }
	                //todo: refactor this code into a function
	                if (el.nodeName.toLowerCase() === 'img') {
	                    DOM.setAttr(el, {
	                        'src': image
	                    });
	                } else if (el.nodeName.toLowerCase() === 'object') {
	                    DOM.setAttr(el, {
	                        'data': image,
	                        'type': 'image/svg+xml'
	                    });
	                }
	            }, 150);
	        }
	    }
	    //todo: account for re-rendering
	    DOM.setAttr(el, {
	        'data-holder-rendered': true
	    });
	}

	/**
	 * Core function that takes a Holder scene description and builds a scene graph
	 *
	 * @private
	 * @param scene Holder scene object
	 */
	//todo: make this function reusable
	//todo: merge app defaults and setup properties into the scene argument
	function buildSceneGraph(scene) {
	    var fontSize = App.defaults.size;
	    var fixedSize = scene.flags.fixedSize != null ? scene.flags.fixedSize : scene.theme.fixedSize;
	    if (parseFloat(scene.theme.size)) {
	        fontSize = scene.theme.size;
	    } else if (parseFloat(scene.flags.size)) {
	        fontSize = scene.flags.size;
	    }

	    scene.font = {
	        family: scene.theme.font ? scene.theme.font : 'Arial, Helvetica, Open Sans, sans-serif',
	        size: fixedSize ? fontSize : textSize(scene.width, scene.height, fontSize, App.defaults.scale),
	        units: scene.theme.units ? scene.theme.units : App.defaults.units,
	        weight: scene.theme.fontweight ? scene.theme.fontweight : 'bold'
	    };

	    scene.text = scene.theme.text || Math.floor(scene.width) + 'x' + Math.floor(scene.height);

	    scene.noWrap = scene.theme.nowrap || scene.flags.nowrap;

	    scene.align = scene.theme.align || scene.flags.align || 'center';

	    switch (scene.flags.textmode) {
	        case 'literal':
	            scene.text = scene.flags.dimensions.width + 'x' + scene.flags.dimensions.height;
	            break;
	        case 'exact':
	            if (!scene.flags.exactDimensions) break;
	            scene.text = Math.floor(scene.flags.exactDimensions.width) + 'x' + Math.floor(scene.flags.exactDimensions.height);
	            break;
	    }

	    var lineWrap = scene.flags.lineWrap || App.setup.lineWrapRatio;
	    var sceneMargin = scene.width * lineWrap;
	    var maxLineWidth = sceneMargin;

	    var sceneGraph = new SceneGraph({
	        width: scene.width,
	        height: scene.height
	    });

	    var Shape = sceneGraph.Shape;

	    var holderBg = new Shape.Rect('holderBg', {
	        fill: scene.theme.bg
	    });

	    holderBg.resize(scene.width, scene.height);
	    sceneGraph.root.add(holderBg);

	    if (scene.flags.outline) {
	        var outlineColor = new Color(holderBg.properties.fill);
	        outlineColor = outlineColor.lighten(outlineColor.lighterThan('7f7f7f') ? -0.1 : 0.1);
	        holderBg.properties.outline = {
	            fill: outlineColor.toHex(true),
	            width: 2
	        };
	    }

	    var holderTextColor = scene.theme.fg;

	    if (scene.flags.autoFg) {
	        var holderBgColor = new Color(holderBg.properties.fill);
	        var lightColor = new Color('fff');
	        var darkColor = new Color('000', {
	            'alpha': 0.285714
	        });

	        holderTextColor = holderBgColor.blendAlpha(holderBgColor.lighterThan('7f7f7f') ? darkColor : lightColor).toHex(true);
	    }

	    var holderTextGroup = new Shape.Group('holderTextGroup', {
	        text: scene.text,
	        align: scene.align,
	        font: scene.font,
	        fill: holderTextColor
	    });

	    holderTextGroup.moveTo(null, null, 1);
	    sceneGraph.root.add(holderTextGroup);

	    var tpdata = holderTextGroup.textPositionData = stagingRenderer(sceneGraph);
	    if (!tpdata) {
	        throw 'Holder: staging fallback not supported yet.';
	    }
	    holderTextGroup.properties.leading = tpdata.boundingBox.height;

	    var textNode = null;
	    var line = null;

	    function finalizeLine(parent, line, width, height) {
	        line.width = width;
	        line.height = height;
	        parent.width = Math.max(parent.width, line.width);
	        parent.height += line.height;
	    }

	    if (tpdata.lineCount > 1) {
	        var offsetX = 0;
	        var offsetY = 0;
	        var lineIndex = 0;
	        var lineKey;
	        line = new Shape.Group('line' + lineIndex);

	        //Double margin so that left/right-aligned next is not flush with edge of image
	        if (scene.align === 'left' || scene.align === 'right') {
	            maxLineWidth = scene.width * (1 - (1 - lineWrap) * 2);
	        }

	        for (var i = 0; i < tpdata.words.length; i++) {
	            var word = tpdata.words[i];
	            textNode = new Shape.Text(word.text);
	            var newline = word.text == '\\n';
	            if (!scene.noWrap && (offsetX + word.width >= maxLineWidth || newline === true)) {
	                finalizeLine(holderTextGroup, line, offsetX, holderTextGroup.properties.leading);
	                holderTextGroup.add(line);
	                offsetX = 0;
	                offsetY += holderTextGroup.properties.leading;
	                lineIndex += 1;
	                line = new Shape.Group('line' + lineIndex);
	                line.y = offsetY;
	            }
	            if (newline === true) {
	                continue;
	            }
	            textNode.moveTo(offsetX, 0);
	            offsetX += tpdata.spaceWidth + word.width;
	            line.add(textNode);
	        }

	        finalizeLine(holderTextGroup, line, offsetX, holderTextGroup.properties.leading);
	        holderTextGroup.add(line);

	        if (scene.align === 'left') {
	            holderTextGroup.moveTo(scene.width - sceneMargin, null, null);
	        } else if (scene.align === 'right') {
	            for (lineKey in holderTextGroup.children) {
	                line = holderTextGroup.children[lineKey];
	                line.moveTo(scene.width - line.width, null, null);
	            }

	            holderTextGroup.moveTo(0 - (scene.width - sceneMargin), null, null);
	        } else {
	            for (lineKey in holderTextGroup.children) {
	                line = holderTextGroup.children[lineKey];
	                line.moveTo((holderTextGroup.width - line.width) / 2, null, null);
	            }

	            holderTextGroup.moveTo((scene.width - holderTextGroup.width) / 2, null, null);
	        }

	        holderTextGroup.moveTo(null, (scene.height - holderTextGroup.height) / 2, null);

	        //If the text exceeds vertical space, move it down so the first line is visible
	        if ((scene.height - holderTextGroup.height) / 2 < 0) {
	            holderTextGroup.moveTo(null, 0, null);
	        }
	    } else {
	        textNode = new Shape.Text(scene.text);
	        line = new Shape.Group('line0');
	        line.add(textNode);
	        holderTextGroup.add(line);

	        if (scene.align === 'left') {
	            holderTextGroup.moveTo(scene.width - sceneMargin, null, null);
	        } else if (scene.align === 'right') {
	            holderTextGroup.moveTo(0 - (scene.width - sceneMargin), null, null);
	        } else {
	            holderTextGroup.moveTo((scene.width - tpdata.boundingBox.width) / 2, null, null);
	        }

	        holderTextGroup.moveTo(null, (scene.height - tpdata.boundingBox.height) / 2, null);
	    }

	    //todo: renderlist
	    return sceneGraph;
	}

	/**
	 * Adaptive text sizing function
	 *
	 * @private
	 * @param width Parent width
	 * @param height Parent height
	 * @param fontSize Requested text size
	 * @param scale Proportional scale of text
	 */
	function textSize(width, height, fontSize, scale) {
	    var stageWidth = parseInt(width, 10);
	    var stageHeight = parseInt(height, 10);

	    var bigSide = Math.max(stageWidth, stageHeight);
	    var smallSide = Math.min(stageWidth, stageHeight);

	    var newHeight = 0.8 * Math.min(smallSide, bigSide * scale);
	    return Math.round(Math.max(fontSize, newHeight));
	}

	/**
	 * Iterates over resizable (fluid or auto) placeholders and renders them
	 *
	 * @private
	 * @param element Optional element selector, specified only if a specific element needs to be re-rendered
	 */
	function updateResizableElements(element) {
	    var images;
	    if (element == null || element.nodeType == null) {
	        images = App.vars.resizableImages;
	    } else {
	        images = [element];
	    }
	    for (var i = 0, l = images.length; i < l; i++) {
	        var el = images[i];
	        if (el.holderData) {
	            var flags = el.holderData.flags;
	            var dimensions = dimensionCheck(el);
	            if (dimensions) {
	                if (!el.holderData.resizeUpdate) {
	                    continue;
	                }

	                if (flags.fluid && flags.auto) {
	                    var fluidConfig = el.holderData.fluidConfig;
	                    switch (fluidConfig.mode) {
	                        case 'width':
	                            dimensions.height = dimensions.width / fluidConfig.ratio;
	                            break;
	                        case 'height':
	                            dimensions.width = dimensions.height * fluidConfig.ratio;
	                            break;
	                    }
	                }

	                var settings = {
	                    mode: 'image',
	                    holderSettings: {
	                        dimensions: dimensions,
	                        theme: flags.theme,
	                        flags: flags
	                    },
	                    el: el,
	                    engineSettings: el.holderData.engineSettings
	                };

	                if (flags.textmode == 'exact') {
	                    flags.exactDimensions = dimensions;
	                    settings.holderSettings.dimensions = flags.dimensions;
	                }

	                render(settings);
	            } else {
	                setInvisible(el);
	            }
	        }
	    }
	}

	/**
	 * Sets up aspect ratio metadata for fluid placeholders, in order to preserve proportions when resizing
	 *
	 * @private
	 * @param el Image DOM element
	 */
	function setInitialDimensions(el) {
	    if (el.holderData) {
	        var dimensions = dimensionCheck(el);
	        if (dimensions) {
	            var flags = el.holderData.flags;

	            var fluidConfig = {
	                fluidHeight: flags.dimensions.height.slice(-1) == '%',
	                fluidWidth: flags.dimensions.width.slice(-1) == '%',
	                mode: null,
	                initialDimensions: dimensions
	            };

	            if (fluidConfig.fluidWidth && !fluidConfig.fluidHeight) {
	                fluidConfig.mode = 'width';
	                fluidConfig.ratio = fluidConfig.initialDimensions.width / parseFloat(flags.dimensions.height);
	            } else if (!fluidConfig.fluidWidth && fluidConfig.fluidHeight) {
	                fluidConfig.mode = 'height';
	                fluidConfig.ratio = parseFloat(flags.dimensions.width) / fluidConfig.initialDimensions.height;
	            }

	            el.holderData.fluidConfig = fluidConfig;
	        } else {
	            setInvisible(el);
	        }
	    }
	}

	/**
	 * Iterates through all current invisible images, and if they're visible, renders them and removes them from further checks. Runs every animation frame.
	 *
	 * @private
	 */
	function visibilityCheck() {
	    var renderableImages = [];
	    var keys = Object.keys(App.vars.invisibleImages);
	    var el;

	    keys.forEach(function (key) {
	        el = App.vars.invisibleImages[key];
	        if (dimensionCheck(el) && el.nodeName.toLowerCase() == 'img') {
	            renderableImages.push(el);
	            delete App.vars.invisibleImages[key];
	        }
	    });

	    if (renderableImages.length) {
	        Holder.run({
	            images: renderableImages
	        });
	    }

	    // Done to prevent 100% CPU usage via aggressive calling of requestAnimationFrame
	    setTimeout(function () {
	        global.requestAnimationFrame(visibilityCheck);
	    }, 10);
	}

	/**
	 * Starts checking for invisible placeholders if not doing so yet. Does nothing otherwise.
	 *
	 * @private
	 */
	function startVisibilityCheck() {
	    if (!App.vars.visibilityCheckStarted) {
	        global.requestAnimationFrame(visibilityCheck);
	        App.vars.visibilityCheckStarted = true;
	    }
	}

	/**
	 * Sets a unique ID for an image detected to be invisible and adds it to the map of invisible images checked by visibilityCheck
	 *
	 * @private
	 * @param el Invisible DOM element
	 */
	function setInvisible(el) {
	    if (!el.holderData.invisibleId) {
	        App.vars.invisibleId += 1;
	        App.vars.invisibleImages['i' + App.vars.invisibleId] = el;
	        el.holderData.invisibleId = App.vars.invisibleId;
	    }
	}

	//todo: see if possible to convert stagingRenderer to use HTML only
	var stagingRenderer = (function() {
	    var svg = null,
	        stagingText = null,
	        stagingTextNode = null;
	    return function(graph) {
	        var rootNode = graph.root;
	        if (App.setup.supportsSVG) {
	            var firstTimeSetup = false;
	            var tnode = function(text) {
	                return document.createTextNode(text);
	            };
	            if (svg == null || svg.parentNode !== document.body) {
	                firstTimeSetup = true;
	            }

	            svg = SVG.initSVG(svg, rootNode.properties.width, rootNode.properties.height);
	            //Show staging element before staging
	            svg.style.display = 'block';

	            if (firstTimeSetup) {
	                stagingText = DOM.newEl('text', SVG_NS);
	                stagingTextNode = tnode(null);
	                DOM.setAttr(stagingText, {
	                    x: 0
	                });
	                stagingText.appendChild(stagingTextNode);
	                svg.appendChild(stagingText);
	                document.body.appendChild(svg);
	                svg.style.visibility = 'hidden';
	                svg.style.position = 'absolute';
	                svg.style.top = '-100%';
	                svg.style.left = '-100%';
	                //todo: workaround for zero-dimension <svg> tag in Opera 12
	                //svg.setAttribute('width', 0);
	                //svg.setAttribute('height', 0);
	            }

	            var holderTextGroup = rootNode.children.holderTextGroup;
	            var htgProps = holderTextGroup.properties;
	            DOM.setAttr(stagingText, {
	                'y': htgProps.font.size,
	                'style': utils.cssProps({
	                    'font-weight': htgProps.font.weight,
	                    'font-size': htgProps.font.size + htgProps.font.units,
	                    'font-family': htgProps.font.family
	                })
	            });

	            //Unescape HTML entities to get approximately the right width
	            var txt = DOM.newEl('textarea');
	            txt.innerHTML = htgProps.text;
	            stagingTextNode.nodeValue = txt.value;

	            //Get bounding box for the whole string (total width and height)
	            var stagingTextBBox = stagingText.getBBox();

	            //Get line count and split the string into words
	            var lineCount = Math.ceil(stagingTextBBox.width / rootNode.properties.width);
	            var words = htgProps.text.split(' ');
	            var newlines = htgProps.text.match(/\\n/g);
	            lineCount += newlines == null ? 0 : newlines.length;

	            //Get bounding box for the string with spaces removed
	            stagingTextNode.nodeValue = htgProps.text.replace(/[ ]+/g, '');
	            var computedNoSpaceLength = stagingText.getComputedTextLength();

	            //Compute average space width
	            var diffLength = stagingTextBBox.width - computedNoSpaceLength;
	            var spaceWidth = Math.round(diffLength / Math.max(1, words.length - 1));

	            //Get widths for every word with space only if there is more than one line
	            var wordWidths = [];
	            if (lineCount > 1) {
	                stagingTextNode.nodeValue = '';
	                for (var i = 0; i < words.length; i++) {
	                    if (words[i].length === 0) continue;
	                    stagingTextNode.nodeValue = utils.decodeHtmlEntity(words[i]);
	                    var bbox = stagingText.getBBox();
	                    wordWidths.push({
	                        text: words[i],
	                        width: bbox.width
	                    });
	                }
	            }

	            //Hide staging element after staging
	            svg.style.display = 'none';

	            return {
	                spaceWidth: spaceWidth,
	                lineCount: lineCount,
	                boundingBox: stagingTextBBox,
	                words: wordWidths
	            };
	        } else {
	            //todo: canvas fallback for measuring text on android 2.3
	            return false;
	        }
	    };
	})();

	//Helpers

	/**
	 * Prevents a function from being called too often, waits until a timer elapses to call it again
	 *
	 * @param fn Function to call
	 */
	function debounce(fn) {
	    if (!App.vars.debounceTimer) fn.call(this);
	    if (App.vars.debounceTimer) global.clearTimeout(App.vars.debounceTimer);
	    App.vars.debounceTimer = global.setTimeout(function() {
	        App.vars.debounceTimer = null;
	        fn.call(this);
	    }, App.setup.debounce);
	}

	/**
	 * Holder-specific resize/orientation change callback, debounced to prevent excessive execution
	 */
	function resizeEvent() {
	    debounce(function() {
	        updateResizableElements(null);
	    });
	}

	//Set up flags

	for (var flag in App.flags) {
	    if (!Object.prototype.hasOwnProperty.call(App.flags, flag)) continue;
	    App.flags[flag].match = function(val) {
	        return val.match(this.regex);
	    };
	}

	//Properties set once on setup

	App.setup = {
	    renderer: 'html',
	    debounce: 100,
	    ratio: 1,
	    supportsCanvas: false,
	    supportsSVG: false,
	    lineWrapRatio: 0.9,
	    dataAttr: 'data-src',
	    renderers: ['html', 'canvas', 'svg']
	};

	//Properties modified during runtime

	App.vars = {
	    preempted: false,
	    resizableImages: [],
	    invisibleImages: {},
	    invisibleId: 0,
	    visibilityCheckStarted: false,
	    debounceTimer: null,
	    cache: {}
	};

	//Pre-flight

	(function() {
	    var canvas = DOM.newEl('canvas');

	    if (canvas.getContext) {
	        if (canvas.toDataURL('image/png').indexOf('data:image/png') != -1) {
	            App.setup.renderer = 'canvas';
	            App.setup.supportsCanvas = true;
	        }
	    }

	    if (!!document.createElementNS && !!document.createElementNS(SVG_NS, 'svg').createSVGRect) {
	        App.setup.renderer = 'svg';
	        App.setup.supportsSVG = true;
	    }
	})();

	//Starts checking for invisible placeholders
	startVisibilityCheck();

	if (onDomReady) {
	    onDomReady(function() {
	        if (!App.vars.preempted) {
	            Holder.run();
	        }
	        if (global.addEventListener) {
	            global.addEventListener('resize', resizeEvent, false);
	            global.addEventListener('orientationchange', resizeEvent, false);
	        } else {
	            global.attachEvent('onresize', resizeEvent);
	        }

	        if (typeof global.Turbolinks == 'object') {
	            global.document.addEventListener('page:change', function() {
	                Holder.run();
	            });
	        }
	    });
	}

	module.exports = Holder;

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ }),
/* 2 */
/***/ (function(module, exports) {

	/*!
	 * onDomReady.js 1.4.0 (c) 2013 Tubal Martin - MIT license
	 *
	 * Specially modified to work with Holder.js
	 */

	function _onDomReady(win) {
	    //Lazy loading fix for Firefox < 3.6
	    //http://webreflection.blogspot.com/2009/11/195-chars-to-help-lazy-loading.html
	    if (document.readyState == null && document.addEventListener) {
	        document.addEventListener("DOMContentLoaded", function DOMContentLoaded() {
	            document.removeEventListener("DOMContentLoaded", DOMContentLoaded, false);
	            document.readyState = "complete";
	        }, false);
	        document.readyState = "loading";
	    }
	    
	    var doc = win.document,
	        docElem = doc.documentElement,
	    
	        LOAD = "load",
	        FALSE = false,
	        ONLOAD = "on"+LOAD,
	        COMPLETE = "complete",
	        READYSTATE = "readyState",
	        ATTACHEVENT = "attachEvent",
	        DETACHEVENT = "detachEvent",
	        ADDEVENTLISTENER = "addEventListener",
	        DOMCONTENTLOADED = "DOMContentLoaded",
	        ONREADYSTATECHANGE = "onreadystatechange",
	        REMOVEEVENTLISTENER = "removeEventListener",
	    
	        // W3C Event model
	        w3c = ADDEVENTLISTENER in doc,
	        _top = FALSE,
	    
	        // isReady: Is the DOM ready to be used? Set to true once it occurs.
	        isReady = FALSE,
	    
	        // Callbacks pending execution until DOM is ready
	        callbacks = [];
	    
	    // Handle when the DOM is ready
	    function ready( fn ) {
	        if ( !isReady ) {
	    
	            // Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).
	            if ( !doc.body ) {
	                return defer( ready );
	            }
	    
	            // Remember that the DOM is ready
	            isReady = true;
	    
	            // Execute all callbacks
	            while ( fn = callbacks.shift() ) {
	                defer( fn );
	            }
	        }
	    }
	    
	    // The ready event handler
	    function completed( event ) {
	        // readyState === "complete" is good enough for us to call the dom ready in oldIE
	        if ( w3c || event.type === LOAD || doc[READYSTATE] === COMPLETE ) {
	            detach();
	            ready();
	        }
	    }
	    
	    // Clean-up method for dom ready events
	    function detach() {
	        if ( w3c ) {
	            doc[REMOVEEVENTLISTENER]( DOMCONTENTLOADED, completed, FALSE );
	            win[REMOVEEVENTLISTENER]( LOAD, completed, FALSE );
	        } else {
	            doc[DETACHEVENT]( ONREADYSTATECHANGE, completed );
	            win[DETACHEVENT]( ONLOAD, completed );
	        }
	    }
	    
	    // Defers a function, scheduling it to run after the current call stack has cleared.
	    function defer( fn, wait ) {
	        // Allow 0 to be passed
	        setTimeout( fn, +wait >= 0 ? wait : 1 );
	    }
	    
	    // Attach the listeners:
	    
	    // Catch cases where onDomReady is called after the browser event has already occurred.
	    // we once tried to use readyState "interactive" here, but it caused issues like the one
	    // discovered by ChrisS here: http://bugs.jquery.com/ticket/12282#comment:15
	    if ( doc[READYSTATE] === COMPLETE ) {
	        // Handle it asynchronously to allow scripts the opportunity to delay ready
	        defer( ready );
	    
	    // Standards-based browsers support DOMContentLoaded
	    } else if ( w3c ) {
	        // Use the handy event callback
	        doc[ADDEVENTLISTENER]( DOMCONTENTLOADED, completed, FALSE );
	    
	        // A fallback to window.onload, that will always work
	        win[ADDEVENTLISTENER]( LOAD, completed, FALSE );
	    
	    // If IE event model is used
	    } else {
	        // Ensure firing before onload, maybe late but safe also for iframes
	        doc[ATTACHEVENT]( ONREADYSTATECHANGE, completed );
	    
	        // A fallback to window.onload, that will always work
	        win[ATTACHEVENT]( ONLOAD, completed );
	    
	        // If IE and not a frame
	        // continually check to see if the document is ready
	        try {
	            _top = win.frameElement == null && docElem;
	        } catch(e) {}
	    
	        if ( _top && _top.doScroll ) {
	            (function doScrollCheck() {
	                if ( !isReady ) {
	                    try {
	                        // Use the trick by Diego Perini
	                        // http://javascript.nwbox.com/IEContentLoaded/
	                        _top.doScroll("left");
	                    } catch(e) {
	                        return defer( doScrollCheck, 50 );
	                    }
	    
	                    // detach all dom ready events
	                    detach();
	    
	                    // and execute any waiting functions
	                    ready();
	                }
	            })();
	        }
	    }
	    
	    function onDomReady( fn ) {
	        // If DOM is ready, execute the function (async), otherwise wait
	        isReady ? defer( fn ) : callbacks.push( fn );
	    }
	    
	    // Add version
	    onDomReady.version = "1.4.0";
	    // Add method to check if DOM is ready
	    onDomReady.isReady = function(){
	        return isReady;
	    };

	    return onDomReady;
	}

	module.exports = typeof window !== "undefined" && _onDomReady(window);

/***/ }),
/* 3 */
/***/ (function(module, exports, __nested_webpack_require_56630__) {

	//Modified version of component/querystring
	//Changes: updated dependencies, dot notation parsing, JSHint fixes
	//Fork at https://github.com/imsky/querystring

	/**
	 * Module dependencies.
	 */

	var encode = encodeURIComponent;
	var decode = decodeURIComponent;
	var trim = __nested_webpack_require_56630__(4);
	var type = __nested_webpack_require_56630__(5);

	var arrayRegex = /(\w+)\[(\d+)\]/;
	var objectRegex = /\w+\.\w+/;

	/**
	 * Parse the given query `str`.
	 *
	 * @param {String} str
	 * @return {Object}
	 * @api public
	 */

	exports.parse = function(str){
	  if ('string' !== typeof str) return {};

	  str = trim(str);
	  if ('' === str) return {};
	  if ('?' === str.charAt(0)) str = str.slice(1);

	  var obj = {};
	  var pairs = str.split('&');
	  for (var i = 0; i < pairs.length; i++) {
	    var parts = pairs[i].split('=');
	    var key = decode(parts[0]);
	    var m, ctx, prop;

	    if (m = arrayRegex.exec(key)) {
	      obj[m[1]] = obj[m[1]] || [];
	      obj[m[1]][m[2]] = decode(parts[1]);
	      continue;
	    }

	    if (m = objectRegex.test(key)) {
	      m = key.split('.');
	      ctx = obj;
	      
	      while (m.length) {
	        prop = m.shift();

	        if (!prop.length) continue;

	        if (!ctx[prop]) {
	          ctx[prop] = {};
	        } else if (ctx[prop] && typeof ctx[prop] !== 'object') {
	          break;
	        }

	        if (!m.length) {
	          ctx[prop] = decode(parts[1]);
	        }

	        ctx = ctx[prop];
	      }

	      continue;
	    }

	    obj[parts[0]] = null == parts[1] ? '' : decode(parts[1]);
	  }

	  return obj;
	};

	/**
	 * Stringify the given `obj`.
	 *
	 * @param {Object} obj
	 * @return {String}
	 * @api public
	 */

	exports.stringify = function(obj){
	  if (!obj) return '';
	  var pairs = [];

	  for (var key in obj) {
	    var value = obj[key];

	    if ('array' == type(value)) {
	      for (var i = 0; i < value.length; ++i) {
	        pairs.push(encode(key + '[' + i + ']') + '=' + encode(value[i]));
	      }
	      continue;
	    }

	    pairs.push(encode(key) + '=' + encode(obj[key]));
	  }

	  return pairs.join('&');
	};


/***/ }),
/* 4 */
/***/ (function(module, exports) {

	
	exports = module.exports = trim;

	function trim(str){
	  return str.replace(/^\s*|\s*$/g, '');
	}

	exports.left = function(str){
	  return str.replace(/^\s*/, '');
	};

	exports.right = function(str){
	  return str.replace(/\s*$/, '');
	};


/***/ }),
/* 5 */
/***/ (function(module, exports) {

	/**
	 * toString ref.
	 */

	var toString = Object.prototype.toString;

	/**
	 * Return the type of `val`.
	 *
	 * @param {Mixed} val
	 * @return {String}
	 * @api public
	 */

	module.exports = function(val){
	  switch (toString.call(val)) {
	    case '[object Date]': return 'date';
	    case '[object RegExp]': return 'regexp';
	    case '[object Arguments]': return 'arguments';
	    case '[object Array]': return 'array';
	    case '[object Error]': return 'error';
	  }

	  if (val === null) return 'null';
	  if (val === undefined) return 'undefined';
	  if (val !== val) return 'nan';
	  if (val && val.nodeType === 1) return 'element';

	  val = val.valueOf
	    ? val.valueOf()
	    : Object.prototype.valueOf.apply(val)

	  return typeof val;
	};


/***/ }),
/* 6 */
/***/ (function(module, exports) {

	var SceneGraph = function(sceneProperties) {
	    var nodeCount = 1;

	    //todo: move merge to helpers section
	    function merge(parent, child) {
	        for (var prop in child) {
	            parent[prop] = child[prop];
	        }
	        return parent;
	    }

	    var SceneNode = function(name) {
	        nodeCount++;
	        this.parent = null;
	        this.children = {};
	        this.id = nodeCount;
	        this.name = 'n' + nodeCount;
	        if (typeof name !== 'undefined') {
	            this.name = name;
	        }
	        this.x = this.y = this.z = 0;
	        this.width = this.height = 0;
	    };

	    SceneNode.prototype.resize = function(width, height) {
	        if (width != null) {
	            this.width = width;
	        }
	        if (height != null) {
	            this.height = height;
	        }
	    };

	    SceneNode.prototype.moveTo = function(x, y, z) {
	        this.x = x != null ? x : this.x;
	        this.y = y != null ? y : this.y;
	        this.z = z != null ? z : this.z;
	    };

	    SceneNode.prototype.add = function(child) {
	        var name = child.name;
	        if (typeof this.children[name] === 'undefined') {
	            this.children[name] = child;
	            child.parent = this;
	        } else {
	            throw 'SceneGraph: child already exists: ' + name;
	        }
	    };

	    var RootNode = function() {
	        SceneNode.call(this, 'root');
	        this.properties = sceneProperties;
	    };

	    RootNode.prototype = new SceneNode();

	    var Shape = function(name, props) {
	        SceneNode.call(this, name);
	        this.properties = {
	            'fill': '#000000'
	        };
	        if (typeof props !== 'undefined') {
	            merge(this.properties, props);
	        } else if (typeof name !== 'undefined' && typeof name !== 'string') {
	            throw 'SceneGraph: invalid node name';
	        }
	    };

	    Shape.prototype = new SceneNode();

	    var Group = function() {
	        Shape.apply(this, arguments);
	        this.type = 'group';
	    };

	    Group.prototype = new Shape();

	    var Rect = function() {
	        Shape.apply(this, arguments);
	        this.type = 'rect';
	    };

	    Rect.prototype = new Shape();

	    var Text = function(text) {
	        Shape.call(this);
	        this.type = 'text';
	        this.properties.text = text;
	    };

	    Text.prototype = new Shape();

	    var root = new RootNode();

	    this.Shape = {
	        'Rect': Rect,
	        'Text': Text,
	        'Group': Group
	    };

	    this.root = root;
	    return this;
	};

	module.exports = SceneGraph;


/***/ }),
/* 7 */
/***/ (function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {/**
	 * Shallow object clone and merge
	 *
	 * @param a Object A
	 * @param b Object B
	 * @returns {Object} New object with all of A's properties, and all of B's properties, overwriting A's properties
	 */
	exports.extend = function(a, b) {
	    var c = {};
	    for (var x in a) {
	        if (Object.prototype.hasOwnProperty.call(a,x)) {
	            c[x] = a[x];
	        }
	    }
	    if (b != null) {
	        for (var y in b) {
	            if (Object.prototype.hasOwnProperty.call(b, y)) {
	                c[y] = b[y];
	            }
	        }
	    }
	    return c;
	};

	/**
	 * Takes a k/v list of CSS properties and returns a rule
	 *
	 * @param props CSS properties object
	 */
	exports.cssProps = function(props) {
	    var ret = [];
	    for (var p in props) {
	        if (Object.prototype.hasOwnProperty.call(props, p)) {
	            ret.push(p + ':' + props[p]);
	        }
	    }
	    return ret.join(';');
	};

	/**
	 * Encodes HTML entities in a string
	 *
	 * @param str Input string
	 */
	exports.encodeHtmlEntity = function(str) {
	    var buf = [];
	    var charCode = 0;
	    for (var i = str.length - 1; i >= 0; i--) {
	        charCode = str.charCodeAt(i);
	        if (charCode > 128) {
	            buf.unshift(['&#', charCode, ';'].join(''));
	        } else {
	            buf.unshift(str[i]);
	        }
	    }
	    return buf.join('');
	};

	/**
	 * Checks if an image exists
	 *
	 * @param src URL of image
	 * @param callback Callback to call once image status has been found
	 */
	exports.imageExists = function(src, callback) {
	    var image = new Image();
	    image.onerror = function() {
	        callback.call(this, false);
	    };
	    image.onload = function() {
	        callback.call(this, true);
	    };
	    image.src = src;
	};

	/**
	 * Decodes HTML entities in a string
	 *
	 * @param str Input string
	 */
	exports.decodeHtmlEntity = function(str) {
	    return str.replace(/&#(\d+);/g, function(match, dec) {
	        return String.fromCharCode(dec);
	    });
	};


	/**
	 * Returns an element's dimensions if it's visible, `false` otherwise.
	 *
	 * @param el DOM element
	 */
	exports.dimensionCheck = function(el) {
	    var dimensions = {
	        height: el.clientHeight,
	        width: el.clientWidth
	    };

	    if (dimensions.height && dimensions.width) {
	        return dimensions;
	    } else {
	        return false;
	    }
	};


	/**
	 * Returns true if value is truthy or if it is "semantically truthy"
	 * @param val
	 */
	exports.truthy = function(val) {
	    if (typeof val === 'string') {
	        return val === 'true' || val === 'yes' || val === '1' || val === 'on' || val === 'â';
	    }
	    return !!val;
	};

	/**
	 * Parses input into a well-formed CSS color
	 * @param val
	 */
	exports.parseColor = function(val) {
	    var hexre = /(^(?:#?)[0-9a-f]{6}$)|(^(?:#?)[0-9a-f]{3}$)/i;
	    var rgbre = /^rgb\((\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*\)$/;
	    var rgbare = /^rgba\((\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(0*\.\d{1,}|1)\)$/;

	    var match = val.match(hexre);
	    var retval;

	    if (match !== null) {
	        retval = match[1] || match[2];
	        if (retval[0] !== '#') {
	            return '#' + retval;
	        } else {
	            return retval;
	        }
	    }

	    match = val.match(rgbre);

	    if (match !== null) {
	        retval = 'rgb(' + match.slice(1).join(',') + ')';
	        return retval;
	    }

	    match = val.match(rgbare);

	    if (match !== null) {
	        var normalizeAlpha = function (a) { return '0.' + a.split('.')[1]; };
	        var fixedMatch = match.slice(1).map(function (e, i) {
	            return (i === 3) ? normalizeAlpha(e) : e;
	        });
	        retval = 'rgba(' + fixedMatch.join(',') + ')';
	        return retval;
	    }

	    return null;
	};

	/**
	 * Provides the correct scaling ratio for canvas drawing operations on HiDPI screens (e.g. Retina displays)
	 */
	exports.canvasRatio = function () {
	    var devicePixelRatio = 1;
	    var backingStoreRatio = 1;

	    if (global.document) {
	        var canvas = global.document.createElement('canvas');
	        if (canvas.getContext) {
	            var ctx = canvas.getContext('2d');
	            devicePixelRatio = global.devicePixelRatio || 1;
	            backingStoreRatio = ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || ctx.backingStorePixelRatio || 1;
	        }
	    }

	    return devicePixelRatio / backingStoreRatio;
	};

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ }),
/* 8 */
/***/ (function(module, exports, __nested_webpack_require_67337__) {

	/* WEBPACK VAR INJECTION */(function(global) {var DOM = __nested_webpack_require_67337__(9);

	var SVG_NS = 'http://www.w3.org/2000/svg';
	var NODE_TYPE_COMMENT = 8;

	/**
	 * Generic SVG element creation function
	 *
	 * @param svg SVG context, set to null if new
	 * @param width Document width
	 * @param height Document height
	 */
	exports.initSVG = function(svg, width, height) {
	    var defs, style, initialize = false;

	    if (svg && svg.querySelector) {
	        style = svg.querySelector('style');
	        if (style === null) {
	            initialize = true;
	        }
	    } else {
	        svg = DOM.newEl('svg', SVG_NS);
	        initialize = true;
	    }

	    if (initialize) {
	        defs = DOM.newEl('defs', SVG_NS);
	        style = DOM.newEl('style', SVG_NS);
	        DOM.setAttr(style, {
	            'type': 'text/css'
	        });
	        defs.appendChild(style);
	        svg.appendChild(defs);
	    }

	    //IE throws an exception if this is set and Chrome requires it to be set
	    if (svg.webkitMatchesSelector) {
	        svg.setAttribute('xmlns', SVG_NS);
	    }

	    //Remove comment nodes
	    for (var i = 0; i < svg.childNodes.length; i++) {
	        if (svg.childNodes[i].nodeType === NODE_TYPE_COMMENT) {
	            svg.removeChild(svg.childNodes[i]);
	        }
	    }

	    //Remove CSS
	    while (style.childNodes.length) {
	        style.removeChild(style.childNodes[0]);
	    }

	    DOM.setAttr(svg, {
	        'width': width,
	        'height': height,
	        'viewBox': '0 0 ' + width + ' ' + height,
	        'preserveAspectRatio': 'none'
	    });

	    return svg;
	};

	/**
	 * Converts serialized SVG to a string suitable for data URI use
	 * @param svgString Serialized SVG string
	 * @param [base64] Use base64 encoding for data URI
	 */
	exports.svgStringToDataURI = function() {
	    var rawPrefix = 'data:image/svg+xml;charset=UTF-8,';
	    var base64Prefix = 'data:image/svg+xml;charset=UTF-8;base64,';

	    return function(svgString, base64) {
	        if (base64) {
	            return base64Prefix + btoa(global.unescape(encodeURIComponent(svgString)));
	        } else {
	            return rawPrefix + encodeURIComponent(svgString);
	        }
	    };
	}();

	/**
	 * Returns serialized SVG with XML processing instructions
	 *
	 * @param svg SVG context
	 * @param stylesheets CSS stylesheets to include
	 */
	exports.serializeSVG = function(svg, engineSettings) {
	    if (!global.XMLSerializer) return;
	    var serializer = new XMLSerializer();
	    var svgCSS = '';
	    var stylesheets = engineSettings.stylesheets;

	    //External stylesheets: Processing Instruction method
	    if (engineSettings.svgXMLStylesheet) {
	        var xml = DOM.createXML();
	        //Add <?xml-stylesheet ?> directives
	        for (var i = stylesheets.length - 1; i >= 0; i--) {
	            var csspi = xml.createProcessingInstruction('xml-stylesheet', 'href="' + stylesheets[i] + '" rel="stylesheet"');
	            xml.insertBefore(csspi, xml.firstChild);
	        }

	        xml.removeChild(xml.documentElement);
	        svgCSS = serializer.serializeToString(xml);
	    }

	    var svgText = serializer.serializeToString(svg);
	    svgText = svgText.replace(/&amp;(#[0-9]{2,};)/g, '&$1');
	    return svgCSS + svgText;
	};

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ }),
/* 9 */
/***/ (function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {/**
	 * Generic new DOM element function
	 *
	 * @param tag Tag to create
	 * @param namespace Optional namespace value
	 */
	exports.newEl = function(tag, namespace) {
	    if (!global.document) return;

	    if (namespace == null) {
	        return global.document.createElement(tag);
	    } else {
	        return global.document.createElementNS(namespace, tag);
	    }
	};

	/**
	 * Generic setAttribute function
	 *
	 * @param el Reference to DOM element
	 * @param attrs Object with attribute keys and values
	 */
	exports.setAttr = function (el, attrs) {
	    for (var a in attrs) {
	        el.setAttribute(a, attrs[a]);
	    }
	};

	/**
	 * Creates a XML document
	 * @private
	 */
	exports.createXML = function() {
	    if (!global.DOMParser) return;
	    return new DOMParser().parseFromString('<xml />', 'application/xml');
	};

	/**
	 * Converts a value into an array of DOM nodes
	 *
	 * @param val A string, a NodeList, a Node, or an HTMLCollection
	 */
	exports.getNodeArray = function(val) {
	    var retval = null;
	    if (typeof(val) == 'string') {
	        retval = document.querySelectorAll(val);
	    } else if (global.NodeList && val instanceof global.NodeList) {
	        retval = val;
	    } else if (global.Node && val instanceof global.Node) {
	        retval = [val];
	    } else if (global.HTMLCollection && val instanceof global.HTMLCollection) {
	        retval = val;
	    } else if (val instanceof Array) {
	        retval = val;
	    } else if (val === null) {
	        retval = [];
	    }

	    retval = Array.prototype.slice.call(retval);

	    return retval;
	};

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ }),
/* 10 */
/***/ (function(module, exports) {

	var Color = function(color, options) {
	    //todo: support rgba, hsla, and rrggbbaa notation
	    //todo: use CIELAB internally
	    //todo: add clamp function (with sign)
	    if (typeof color !== 'string') return;

	    this.original = color;

	    if (color.charAt(0) === '#') {
	        color = color.slice(1);
	    }

	    if (/[^a-f0-9]+/i.test(color)) return;

	    if (color.length === 3) {
	        color = color.replace(/./g, '$&$&');
	    }

	    if (color.length !== 6) return;

	    this.alpha = 1;

	    if (options && options.alpha) {
	        this.alpha = options.alpha;
	    }

	    this.set(parseInt(color, 16));
	};

	//todo: jsdocs
	Color.rgb2hex = function(r, g, b) {
	    function format (decimal) {
	        var hex = (decimal | 0).toString(16);
	        if (decimal < 16) {
	            hex = '0' + hex;
	        }
	        return hex;
	    }

	    return [r, g, b].map(format).join('');
	};

	//todo: jsdocs
	Color.hsl2rgb = function (h, s, l) {
	    var H = h / 60;
	    var C = (1 - Math.abs(2 * l - 1)) * s;
	    var X = C * (1 - Math.abs(parseInt(H) % 2 - 1));
	    var m = l - (C / 2);

	    var r = 0, g = 0, b = 0;

	    if (H >= 0 && H < 1) {
	        r = C;
	        g = X;
	    } else if (H >= 1 && H < 2) {
	        r = X;
	        g = C;
	    } else if (H >= 2 && H < 3) {
	        g = C;
	        b = X;
	    } else if (H >= 3 && H < 4) {
	        g = X;
	        b = C;
	    } else if (H >= 4 && H < 5) {
	        r = X;
	        b = C;
	    } else if (H >= 5 && H < 6) {
	        r = C;
	        b = X;
	    }

	    r += m;
	    g += m;
	    b += m;

	    r = parseInt(r * 255);
	    g = parseInt(g * 255);
	    b = parseInt(b * 255);

	    return [r, g, b];
	};

	/**
	 * Sets the color from a raw RGB888 integer
	 * @param raw RGB888 representation of color
	 */
	//todo: refactor into a static method
	//todo: factor out individual color spaces
	//todo: add HSL, CIELAB, and CIELUV
	Color.prototype.set = function (val) {
	    this.raw = val;

	    var r = (this.raw & 0xFF0000) >> 16;
	    var g = (this.raw & 0x00FF00) >> 8;
	    var b = (this.raw & 0x0000FF);

	    // BT.709
	    var y = 0.2126 * r + 0.7152 * g + 0.0722 * b;
	    var u = -0.09991 * r - 0.33609 * g + 0.436 * b;
	    var v = 0.615 * r - 0.55861 * g - 0.05639 * b;

	    this.rgb = {
	        r: r,
	        g: g,
	        b: b
	    };

	    this.yuv = {
	        y: y,
	        u: u,
	        v: v
	    };

	    return this;
	};

	/**
	 * Lighten or darken a color
	 * @param multiplier Amount to lighten or darken (-1 to 1)
	 */
	Color.prototype.lighten = function(multiplier) {
	    var cm = Math.min(1, Math.max(0, Math.abs(multiplier))) * (multiplier < 0 ? -1 : 1);
	    var bm = (255 * cm) | 0;
	    var cr = Math.min(255, Math.max(0, this.rgb.r + bm));
	    var cg = Math.min(255, Math.max(0, this.rgb.g + bm));
	    var cb = Math.min(255, Math.max(0, this.rgb.b + bm));
	    var hex = Color.rgb2hex(cr, cg, cb);
	    return new Color(hex);
	};

	/**
	 * Output color in hex format
	 * @param addHash Add a hash character to the beginning of the output
	 */
	Color.prototype.toHex = function(addHash) {
	    return (addHash ? '#' : '') + this.raw.toString(16);
	};

	/**
	 * Returns whether or not current color is lighter than another color
	 * @param color Color to compare against
	 */
	Color.prototype.lighterThan = function(color) {
	    if (!(color instanceof Color)) {
	        color = new Color(color);
	    }

	    return this.yuv.y > color.yuv.y;
	};

	/**
	 * Returns the result of mixing current color with another color
	 * @param color Color to mix with
	 * @param multiplier How much to mix with the other color
	 */
	/*
	Color.prototype.mix = function (color, multiplier) {
	    if (!(color instanceof Color)) {
	        color = new Color(color);
	    }

	    var r = this.rgb.r;
	    var g = this.rgb.g;
	    var b = this.rgb.b;
	    var a = this.alpha;

	    var m = typeof multiplier !== 'undefined' ? multiplier : 0.5;

	    //todo: write a lerp function
	    r = r + m * (color.rgb.r - r);
	    g = g + m * (color.rgb.g - g);
	    b = b + m * (color.rgb.b - b);
	    a = a + m * (color.alpha - a);

	    return new Color(Color.rgbToHex(r, g, b), {
	        'alpha': a
	    });
	};
	*/

	/**
	 * Returns the result of blending another color on top of current color with alpha
	 * @param color Color to blend on top of current color, i.e. "Ca"
	 */
	//todo: see if .blendAlpha can be merged into .mix
	Color.prototype.blendAlpha = function(color) {
	    if (!(color instanceof Color)) {
	        color = new Color(color);
	    }

	    var Ca = color;
	    var Cb = this;

	    //todo: write alpha blending function
	    var r = Ca.alpha * Ca.rgb.r + (1 - Ca.alpha) * Cb.rgb.r;
	    var g = Ca.alpha * Ca.rgb.g + (1 - Ca.alpha) * Cb.rgb.g;
	    var b = Ca.alpha * Ca.rgb.b + (1 - Ca.alpha) * Cb.rgb.b;

	    return new Color(Color.rgb2hex(r, g, b));
	};

	module.exports = Color;


/***/ }),
/* 11 */
/***/ (function(module, exports) {

	module.exports = {
	  'version': '2.9.9',
	  'svg_ns': 'http://www.w3.org/2000/svg'
	};

/***/ }),
/* 12 */
/***/ (function(module, exports, __nested_webpack_require_77680__) {

	var shaven = __nested_webpack_require_77680__(13).default;

	var SVG = __nested_webpack_require_77680__(8);
	var constants = __nested_webpack_require_77680__(11);
	var utils = __nested_webpack_require_77680__(7);

	var SVG_NS = constants.svg_ns;

	var templates = {
	  'element': function (options) {
	    var tag = options.tag;
	    var content = options.content || '';
	    delete options.tag;
	    delete options.content;
	    return  [tag, content, options];
	  }
	};

	//todo: deprecate tag arg, infer tag from shape object
	function convertShape (shape, tag) {
	  return templates.element({
	    'tag': tag,
	    'width': shape.width,
	    'height': shape.height,
	    'fill': shape.properties.fill
	  });
	}

	function textCss (properties) {
	  return utils.cssProps({
	    'fill': properties.fill,
	    'font-weight': properties.font.weight,
	    'font-family': properties.font.family + ', monospace',
	    'font-size': properties.font.size + properties.font.units
	  });
	}

	function outlinePath (bgWidth, bgHeight, outlineWidth) {
	  var outlineOffsetWidth = outlineWidth / 2;

	  return [
	    'M', outlineOffsetWidth, outlineOffsetWidth,
	    'H', bgWidth - outlineOffsetWidth,
	    'V', bgHeight - outlineOffsetWidth,
	    'H', outlineOffsetWidth,
	    'V', 0,
	    'M', 0, outlineOffsetWidth,
	    'L', bgWidth, bgHeight - outlineOffsetWidth,
	    'M', 0, bgHeight - outlineOffsetWidth,
	    'L', bgWidth, outlineOffsetWidth
	  ].join(' ');
	}

	module.exports = function (sceneGraph, renderSettings) {
	  var engineSettings = renderSettings.engineSettings;
	  var stylesheets = engineSettings.stylesheets;
	  var stylesheetXml = stylesheets.map(function (stylesheet) {
	    return '<?xml-stylesheet rel="stylesheet" href="' + stylesheet + '"?>';
	  }).join('\n');

	  var holderId = 'holder_' + Number(new Date()).toString(16);

	  var root = sceneGraph.root;
	  var textGroup = root.children.holderTextGroup;

	  var css = '#' + holderId + ' text { ' + textCss(textGroup.properties) + ' } ';

	  // push text down to be equally vertically aligned with canvas renderer
	  textGroup.y += textGroup.textPositionData.boundingBox.height * 0.8;

	  var wordTags = [];

	  Object.keys(textGroup.children).forEach(function (lineKey) {
	    var line = textGroup.children[lineKey];

	    Object.keys(line.children).forEach(function (wordKey) {
	      var word = line.children[wordKey];
	      var x = textGroup.x + line.x + word.x;
	      var y = textGroup.y + line.y + word.y;
	      var wordTag = templates.element({
	        'tag': 'text',
	        'content': word.properties.text,
	        'x': x,
	        'y': y
	      });

	      wordTags.push(wordTag);
	    });
	  });

	  var text = templates.element({
	    'tag': 'g',
	    'content': wordTags
	  });

	  var outline = null;

	  if (root.children.holderBg.properties.outline) {
	    var outlineProperties = root.children.holderBg.properties.outline;
	    outline = templates.element({
	      'tag': 'path',
	      'd': outlinePath(root.children.holderBg.width, root.children.holderBg.height, outlineProperties.width),
	      'stroke-width': outlineProperties.width,
	      'stroke': outlineProperties.fill,
	      'fill': 'none'
	    });
	  }

	  var bg = convertShape(root.children.holderBg, 'rect');

	  var sceneContent = [];

	  sceneContent.push(bg);
	  if (outlineProperties) {
	    sceneContent.push(outline);
	  }
	  sceneContent.push(text);

	  var scene = templates.element({
	    'tag': 'g',
	    'id': holderId,
	    'content': sceneContent
	  });

	  var style = templates.element({
	    'tag': 'style',
	    //todo: figure out how to add CDATA directive
	    'content': css,
	    'type': 'text/css'
	  });

	  var defs = templates.element({
	    'tag': 'defs',
	    'content': style
	  });

	  var svg = templates.element({
	    'tag': 'svg',
	    'content': [defs, scene],
	    'width': root.properties.width,
	    'height': root.properties.height,
	    'xmlns': SVG_NS,
	    'viewBox': [0, 0, root.properties.width, root.properties.height].join(' '),
	    'preserveAspectRatio': 'none'
	  });

	  var output = String(shaven(svg));

	  if (/&amp;(x)?#[0-9A-Fa-f]/.test(output[0])) {
	    output = output.replace(/&amp;#/gm, '&#');
	  }

	  output = stylesheetXml + output;

	  var svgString = SVG.svgStringToDataURI(output, renderSettings.mode === 'background');

	  return svgString;
	};


/***/ }),
/* 13 */
/***/ (function(module, exports, __nested_webpack_require_82078__) {

	// vendored shaven 1.3.0 due to published package.json including an outdated node engine
	module.exports = __nested_webpack_require_82078__(14);


/***/ }),
/* 14 */
/***/ (function(module, exports, __nested_webpack_require_82289__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	exports.default = shaven;

	var _parseSugarString = __nested_webpack_require_82289__(15);

	var _parseSugarString2 = _interopRequireDefault(_parseSugarString);

	var _escape = __nested_webpack_require_82289__(16);

	var escape = _interopRequireWildcard(_escape);

	var _defaults = __nested_webpack_require_82289__(17);

	var _defaults2 = _interopRequireDefault(_defaults);

	var _mapAttributeValue = __nested_webpack_require_82289__(18);

	var _mapAttributeValue2 = _interopRequireDefault(_mapAttributeValue);

	var _assert = __nested_webpack_require_82289__(21);

	var _assert2 = _interopRequireDefault(_assert);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function shaven(arrayOrObject) {
	  var isArray = Array.isArray(arrayOrObject);
	  var objType = typeof arrayOrObject === 'undefined' ? 'undefined' : _typeof(arrayOrObject);

	  if (!isArray && objType !== 'object') {
	    throw new Error('Argument must be either an array or an object ' + 'and not ' + JSON.stringify(arrayOrObject));
	  }

	  if (isArray && arrayOrObject.length === 0) {
	    // Ignore empty arrays
	    return {};
	  }

	  var config = {};
	  var elementArray = [];

	  if (Array.isArray(arrayOrObject)) {
	    elementArray = arrayOrObject.slice(0);
	  } else {
	    elementArray = arrayOrObject.elementArray.slice(0);
	    config = Object.assign(config, arrayOrObject);
	    delete config.elementArray;
	  }

	  config = Object.assign({}, _defaults2.default, config, {
	    returnObject: { // Shaven object to return at last
	      ids: {},
	      references: {}
	    }
	  });

	  function createElement(sugarString) {
	    var properties = (0, _parseSugarString2.default)(sugarString);
	    var element = {
	      tag: properties.tag,
	      attr: {},
	      children: []
	    };

	    if (properties.id) {
	      element.attr.id = properties.id;
	      (0, _assert2.default)(!config.returnObject.ids.hasOwnProperty(properties.id), 'Ids must be unique and "' + properties.id + '" is already assigned');
	      config.returnObject.ids[properties.id] = element;
	    }
	    if (properties.class) {
	      element.attr.class = properties.class;
	    }
	    if (properties.reference) {
	      (0, _assert2.default)(!config.returnObject.ids.hasOwnProperty(properties.reference), 'References must be unique and "' + properties.id + '" is already assigned');
	      config.returnObject.references[properties.reference] = element;
	    }

	    config.escapeHTML = properties.escapeHTML != null ? properties.escapeHTML : config.escapeHTML;

	    return element;
	  }

	  function buildDom(elemArray) {
	    if (Array.isArray(elemArray) && elemArray.length === 0) {
	      // Ignore empty arrays
	      return {};
	    }

	    var index = 1;
	    var createdCallback = void 0;
	    var selfClosingHTMLTags = ['area', 'base', 'br', 'col', 'command', 'embed', 'hr', 'img', 'input', 'keygen', 'link', 'menuitem', 'meta', 'param', 'source', 'track', 'wbr'];
	    // Clone to avoid mutation problems
	    var array = elemArray.slice(0);

	    if (typeof array[0] === 'string') {
	      array[0] = createElement(array[0]);
	    } else if (Array.isArray(array[0])) {
	      index = 0;
	    } else {
	      throw new Error('First element of array must be a string, ' + 'or an array and not ' + JSON.stringify(array[0]));
	    }

	    for (; index < array.length; index++) {

	      // Don't render element if value is false or null
	      if (array[index] === false || array[index] === null) {
	        array[0] = false;
	        break;
	      }

	      // Continue with next array value if current value is undefined or true
	      else if (array[index] === undefined || array[index] === true) {
	          continue;
	        } else if (typeof array[index] === 'string') {
	          if (config.escapeHTML) {
	            // eslint-disable-next-line new-cap
	            array[index] = escape.HTML(array[index]);
	          }

	          array[0].children.push(array[index]);
	        } else if (typeof array[index] === 'number') {

	          array[0].children.push(array[index]);
	        } else if (Array.isArray(array[index])) {

	          if (Array.isArray(array[index][0])) {
	            array[index].reverse().forEach(function (subArray) {
	              // eslint-disable-line no-loop-func
	              array.splice(index + 1, 0, subArray);
	            });

	            if (index !== 0) continue;
	            index++;
	          }

	          array[index] = buildDom(array[index]);

	          if (array[index][0]) {
	            array[0].children.push(array[index][0]);
	          }
	        } else if (typeof array[index] === 'function') {
	          createdCallback = array[index];
	        } else if (_typeof(array[index]) === 'object') {
	          for (var attributeKey in array[index]) {
	            if (!array[index].hasOwnProperty(attributeKey)) continue;

	            var attributeValue = array[index][attributeKey];

	            if (array[index].hasOwnProperty(attributeKey) && attributeValue !== null && attributeValue !== false) {
	              array[0].attr[attributeKey] = (0, _mapAttributeValue2.default)(attributeKey, attributeValue);
	            }
	          }
	        } else {
	          throw new TypeError('"' + array[index] + '" is not allowed as a value');
	        }
	    }

	    if (array[0] !== false) {
	      var HTMLString = '<' + array[0].tag;

	      for (var key in array[0].attr) {
	        if (array[0].attr.hasOwnProperty(key)) {
	          var _attributeValue = escape.attribute(array[0].attr[key]);
	          var value = _attributeValue;

	          if (config.quoteAttributes || /[ "'=<>]/.test(_attributeValue)) {
	            value = config.quotationMark + _attributeValue + config.quotationMark;
	          }

	          HTMLString += ' ' + key + '=' + value;
	        }
	      }

	      HTMLString += '>';

	      if (!(selfClosingHTMLTags.indexOf(array[0].tag) !== -1)) {
	        array[0].children.forEach(function (child) {
	          return HTMLString += child;
	        });

	        HTMLString += '</' + array[0].tag + '>';
	      }

	      array[0] = HTMLString;
	    }

	    // Return root element on index 0
	    config.returnObject[0] = array[0];
	    config.returnObject.rootElement = array[0];

	    config.returnObject.toString = function () {
	      return array[0];
	    };

	    if (createdCallback) createdCallback(array[0]);

	    return config.returnObject;
	  }

	  return buildDom(elementArray);
	}

	shaven.setDefaults = function (object) {
	  Object.assign(_defaults2.default, object);
	  return shaven;
	};


/***/ }),
/* 15 */
/***/ (function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	exports.default = function (sugarString) {
	  var tags = sugarString.match(/^[\w-]+/);
	  var properties = {
	    tag: tags ? tags[0] : 'div'
	  };
	  var ids = sugarString.match(/#([\w-]+)/);
	  var classes = sugarString.match(/\.[\w-]+/g);
	  var references = sugarString.match(/\$([\w-]+)/);

	  if (ids) properties.id = ids[1];

	  if (classes) {
	    properties.class = classes.join(' ').replace(/\./g, '');
	  }

	  if (references) properties.reference = references[1];

	  if (sugarString.endsWith('&') || sugarString.endsWith('!')) {
	    properties.escapeHTML = false;
	  }

	  return properties;
	};

/***/ }),
/* 16 */
/***/ (function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.attribute = attribute;
	exports.HTML = HTML;
	function attribute(string) {
	  return string || string === 0 ? String(string).replace(/&/g, '&amp;').replace(/"/g, '&quot;') : '';
	}

	function HTML(string) {
	  return String(string).replace(/&/g, '&amp;').replace(/"/g, '&quot;').replace(/'/g, '&apos;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
	}

/***/ }),
/* 17 */
/***/ (function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = {
	  namespace: 'xhtml',
	  autoNamespacing: true,
	  escapeHTML: true,
	  quotationMark: '"',
	  quoteAttributes: true,
	  convertTransformArray: true
	};

/***/ }),
/* 18 */
/***/ (function(module, exports, __nested_webpack_require_91112__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	var _buildTransformString = __nested_webpack_require_91112__(19);

	var _buildTransformString2 = _interopRequireDefault(_buildTransformString);

	var _stringifyStyleObject = __nested_webpack_require_91112__(20);

	var _stringifyStyleObject2 = _interopRequireDefault(_stringifyStyleObject);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = function (key, value) {
	  if (value === undefined) {
	    return '';
	  }

	  if (key === 'style' && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object') {
	    return (0, _stringifyStyleObject2.default)(value);
	  }

	  if (key === 'transform' && Array.isArray(value)) {
	    return (0, _buildTransformString2.default)(value);
	  }

	  return value;
	};

/***/ }),
/* 19 */
/***/ (function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	// Create transform string from list transform objects

	exports.default = function (transformObjects) {

	  return transformObjects.map(function (transformation) {
	    var values = [];

	    if (transformation.type === 'rotate' && transformation.degrees) {
	      values.push(transformation.degrees);
	    }
	    if (transformation.x) values.push(transformation.x);
	    if (transformation.y) values.push(transformation.y);

	    return transformation.type + '(' + values + ')';
	  }).join(' ');
	};

/***/ }),
/* 20 */
/***/ (function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	function sanitizeProperties(key, value) {
	  if (value === null || value === false || value === undefined) return;
	  if (typeof value === 'string' || (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object') return value;

	  return String(value);
	}

	exports.default = function (styleObject) {
	  return JSON.stringify(styleObject, sanitizeProperties).slice(2, -2).replace(/","/g, ';').replace(/":"/g, ':').replace(/\\"/g, '\'');
	};

/***/ }),
/* 21 */
/***/ (function(module, exports, __nested_webpack_require_93821__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';

	var objectAssign = __nested_webpack_require_93821__(22);

	// compare and isBuffer taken from https://github.com/feross/buffer/blob/680e9e5e488f22aac27599a57dc844a6315928dd/index.js
	// original notice:

	/*!
	 * The buffer module from node.js, for the browser.
	 *
	 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
	 * @license  MIT
	 */
	function compare(a, b) {
	  if (a === b) {
	    return 0;
	  }

	  var x = a.length;
	  var y = b.length;

	  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
	    if (a[i] !== b[i]) {
	      x = a[i];
	      y = b[i];
	      break;
	    }
	  }

	  if (x < y) {
	    return -1;
	  }
	  if (y < x) {
	    return 1;
	  }
	  return 0;
	}
	function isBuffer(b) {
	  if (global.Buffer && typeof global.Buffer.isBuffer === 'function') {
	    return global.Buffer.isBuffer(b);
	  }
	  return !!(b != null && b._isBuffer);
	}

	// based on node assert, original notice:
	// NB: The URL to the CommonJS spec is kept just for tradition.
	//     node-assert has evolved a lot since then, both in API and behavior.

	// http://wiki.commonjs.org/wiki/Unit_Testing/1.0
	//
	// THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8!
	//
	// Originally from narwhal.js (http://narwhaljs.org)
	// Copyright (c) 2009 Thomas Robinson <280north.com>
	//
	// Permission is hereby granted, free of charge, to any person obtaining a copy
	// of this software and associated documentation files (the 'Software'), to
	// deal in the Software without restriction, including without limitation the
	// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
	// sell copies of the Software, and to permit persons to whom the Software is
	// furnished to do so, subject to the following conditions:
	//
	// The above copyright notice and this permission notice shall be included in
	// all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
	// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
	// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

	var util = __nested_webpack_require_93821__(23);
	var hasOwn = Object.prototype.hasOwnProperty;
	var pSlice = Array.prototype.slice;
	var functionsHaveNames = (function () {
	  return function foo() {}.name === 'foo';
	}());
	function pToString (obj) {
	  return Object.prototype.toString.call(obj);
	}
	function isView(arrbuf) {
	  if (isBuffer(arrbuf)) {
	    return false;
	  }
	  if (typeof global.ArrayBuffer !== 'function') {
	    return false;
	  }
	  if (typeof ArrayBuffer.isView === 'function') {
	    return ArrayBuffer.isView(arrbuf);
	  }
	  if (!arrbuf) {
	    return false;
	  }
	  if (arrbuf instanceof DataView) {
	    return true;
	  }
	  if (arrbuf.buffer && arrbuf.buffer instanceof ArrayBuffer) {
	    return true;
	  }
	  return false;
	}
	// 1. The assert module provides functions that throw
	// AssertionError's when particular conditions are not met. The
	// assert module must conform to the following interface.

	var assert = module.exports = ok;

	// 2. The AssertionError is defined in assert.
	// new assert.AssertionError({ message: message,
	//                             actual: actual,
	//                             expected: expected })

	var regex = /\s*function\s+([^\(\s]*)\s*/;
	// based on https://github.com/ljharb/function.prototype.name/blob/adeeeec8bfcc6068b187d7d9fb3d5bb1d3a30899/implementation.js
	function getName(func) {
	  if (!util.isFunction(func)) {
	    return;
	  }
	  if (functionsHaveNames) {
	    return func.name;
	  }
	  var str = func.toString();
	  var match = str.match(regex);
	  return match && match[1];
	}
	assert.AssertionError = function AssertionError(options) {
	  this.name = 'AssertionError';
	  this.actual = options.actual;
	  this.expected = options.expected;
	  this.operator = options.operator;
	  if (options.message) {
	    this.message = options.message;
	    this.generatedMessage = false;
	  } else {
	    this.message = getMessage(this);
	    this.generatedMessage = true;
	  }
	  var stackStartFunction = options.stackStartFunction || fail;
	  if (Error.captureStackTrace) {
	    Error.captureStackTrace(this, stackStartFunction);
	  } else {
	    // non v8 browsers so we can have a stacktrace
	    var err = new Error();
	    if (err.stack) {
	      var out = err.stack;

	      // try to strip useless frames
	      var fn_name = getName(stackStartFunction);
	      var idx = out.indexOf('\n' + fn_name);
	      if (idx >= 0) {
	        // once we have located the function frame
	        // we need to strip out everything before it (and its line)
	        var next_line = out.indexOf('\n', idx + 1);
	        out = out.substring(next_line + 1);
	      }

	      this.stack = out;
	    }
	  }
	};

	// assert.AssertionError instanceof Error
	util.inherits(assert.AssertionError, Error);

	function truncate(s, n) {
	  if (typeof s === 'string') {
	    return s.length < n ? s : s.slice(0, n);
	  } else {
	    return s;
	  }
	}
	function inspect(something) {
	  if (functionsHaveNames || !util.isFunction(something)) {
	    return util.inspect(something);
	  }
	  var rawname = getName(something);
	  var name = rawname ? ': ' + rawname : '';
	  return '[Function' +  name + ']';
	}
	function getMessage(self) {
	  return truncate(inspect(self.actual), 128) + ' ' +
	         self.operator + ' ' +
	         truncate(inspect(self.expected), 128);
	}

	// At present only the three keys mentioned above are used and
	// understood by the spec. Implementations or sub modules can pass
	// other keys to the AssertionError's constructor - they will be
	// ignored.

	// 3. All of the following functions must throw an AssertionError
	// when a corresponding condition is not met, with a message that
	// may be undefined if not provided.  All assertion methods provide
	// both the actual and expected values to the assertion error for
	// display purposes.

	function fail(actual, expected, message, operator, stackStartFunction) {
	  throw new assert.AssertionError({
	    message: message,
	    actual: actual,
	    expected: expected,
	    operator: operator,
	    stackStartFunction: stackStartFunction
	  });
	}

	// EXTENSION! allows for well behaved errors defined elsewhere.
	assert.fail = fail;

	// 4. Pure assertion tests whether a value is truthy, as determined
	// by !!guard.
	// assert.ok(guard, message_opt);
	// This statement is equivalent to assert.equal(true, !!guard,
	// message_opt);. To test strictly for the value true, use
	// assert.strictEqual(true, guard, message_opt);.

	function ok(value, message) {
	  if (!value) fail(value, true, message, '==', assert.ok);
	}
	assert.ok = ok;

	// 5. The equality assertion tests shallow, coercive equality with
	// ==.
	// assert.equal(actual, expected, message_opt);

	assert.equal = function equal(actual, expected, message) {
	  if (actual != expected) fail(actual, expected, message, '==', assert.equal);
	};

	// 6. The non-equality assertion tests for whether two objects are not equal
	// with != assert.notEqual(actual, expected, message_opt);

	assert.notEqual = function notEqual(actual, expected, message) {
	  if (actual == expected) {
	    fail(actual, expected, message, '!=', assert.notEqual);
	  }
	};

	// 7. The equivalence assertion tests a deep equality relation.
	// assert.deepEqual(actual, expected, message_opt);

	assert.deepEqual = function deepEqual(actual, expected, message) {
	  if (!_deepEqual(actual, expected, false)) {
	    fail(actual, expected, message, 'deepEqual', assert.deepEqual);
	  }
	};

	assert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {
	  if (!_deepEqual(actual, expected, true)) {
	    fail(actual, expected, message, 'deepStrictEqual', assert.deepStrictEqual);
	  }
	};

	function _deepEqual(actual, expected, strict, memos) {
	  // 7.1. All identical values are equivalent, as determined by ===.
	  if (actual === expected) {
	    return true;
	  } else if (isBuffer(actual) && isBuffer(expected)) {
	    return compare(actual, expected) === 0;

	  // 7.2. If the expected value is a Date object, the actual value is
	  // equivalent if it is also a Date object that refers to the same time.
	  } else if (util.isDate(actual) && util.isDate(expected)) {
	    return actual.getTime() === expected.getTime();

	  // 7.3 If the expected value is a RegExp object, the actual value is
	  // equivalent if it is also a RegExp object with the same source and
	  // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).
	  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {
	    return actual.source === expected.source &&
	           actual.global === expected.global &&
	           actual.multiline === expected.multiline &&
	           actual.lastIndex === expected.lastIndex &&
	           actual.ignoreCase === expected.ignoreCase;

	  // 7.4. Other pairs that do not both pass typeof value == 'object',
	  // equivalence is determined by ==.
	  } else if ((actual === null || typeof actual !== 'object') &&
	             (expected === null || typeof expected !== 'object')) {
	    return strict ? actual === expected : actual == expected;

	  // If both values are instances of typed arrays, wrap their underlying
	  // ArrayBuffers in a Buffer each to increase performance
	  // This optimization requires the arrays to have the same type as checked by
	  // Object.prototype.toString (aka pToString). Never perform binary
	  // comparisons for Float*Arrays, though, since e.g. +0 === -0 but their
	  // bit patterns are not identical.
	  } else if (isView(actual) && isView(expected) &&
	             pToString(actual) === pToString(expected) &&
	             !(actual instanceof Float32Array ||
	               actual instanceof Float64Array)) {
	    return compare(new Uint8Array(actual.buffer),
	                   new Uint8Array(expected.buffer)) === 0;

	  // 7.5 For all other Object pairs, including Array objects, equivalence is
	  // determined by having the same number of owned properties (as verified
	  // with Object.prototype.hasOwnProperty.call), the same set of keys
	  // (although not necessarily the same order), equivalent values for every
	  // corresponding key, and an identical 'prototype' property. Note: this
	  // accounts for both named and indexed properties on Arrays.
	  } else if (isBuffer(actual) !== isBuffer(expected)) {
	    return false;
	  } else {
	    memos = memos || {actual: [], expected: []};

	    var actualIndex = memos.actual.indexOf(actual);
	    if (actualIndex !== -1) {
	      if (actualIndex === memos.expected.indexOf(expected)) {
	        return true;
	      }
	    }

	    memos.actual.push(actual);
	    memos.expected.push(expected);

	    return objEquiv(actual, expected, strict, memos);
	  }
	}

	function isArguments(object) {
	  return Object.prototype.toString.call(object) == '[object Arguments]';
	}

	function objEquiv(a, b, strict, actualVisitedObjects) {
	  if (a === null || a === undefined || b === null || b === undefined)
	    return false;
	  // if one is a primitive, the other must be same
	  if (util.isPrimitive(a) || util.isPrimitive(b))
	    return a === b;
	  if (strict && Object.getPrototypeOf(a) !== Object.getPrototypeOf(b))
	    return false;
	  var aIsArgs = isArguments(a);
	  var bIsArgs = isArguments(b);
	  if ((aIsArgs && !bIsArgs) || (!aIsArgs && bIsArgs))
	    return false;
	  if (aIsArgs) {
	    a = pSlice.call(a);
	    b = pSlice.call(b);
	    return _deepEqual(a, b, strict);
	  }
	  var ka = objectKeys(a);
	  var kb = objectKeys(b);
	  var key, i;
	  // having the same number of owned properties (keys incorporates
	  // hasOwnProperty)
	  if (ka.length !== kb.length)
	    return false;
	  //the same set of keys (although not necessarily the same order),
	  ka.sort();
	  kb.sort();
	  //~~~cheap key test
	  for (i = ka.length - 1; i >= 0; i--) {
	    if (ka[i] !== kb[i])
	      return false;
	  }
	  //equivalent values for every corresponding key, and
	  //~~~possibly expensive deep test
	  for (i = ka.length - 1; i >= 0; i--) {
	    key = ka[i];
	    if (!_deepEqual(a[key], b[key], strict, actualVisitedObjects))
	      return false;
	  }
	  return true;
	}

	// 8. The non-equivalence assertion tests for any deep inequality.
	// assert.notDeepEqual(actual, expected, message_opt);

	assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
	  if (_deepEqual(actual, expected, false)) {
	    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
	  }
	};

	assert.notDeepStrictEqual = notDeepStrictEqual;
	function notDeepStrictEqual(actual, expected, message) {
	  if (_deepEqual(actual, expected, true)) {
	    fail(actual, expected, message, 'notDeepStrictEqual', notDeepStrictEqual);
	  }
	}


	// 9. The strict equality assertion tests strict equality, as determined by ===.
	// assert.strictEqual(actual, expected, message_opt);

	assert.strictEqual = function strictEqual(actual, expected, message) {
	  if (actual !== expected) {
	    fail(actual, expected, message, '===', assert.strictEqual);
	  }
	};

	// 10. The strict non-equality assertion tests for strict inequality, as
	// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);

	assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
	  if (actual === expected) {
	    fail(actual, expected, message, '!==', assert.notStrictEqual);
	  }
	};

	function expectedException(actual, expected) {
	  if (!actual || !expected) {
	    return false;
	  }

	  if (Object.prototype.toString.call(expected) == '[object RegExp]') {
	    return expected.test(actual);
	  }

	  try {
	    if (actual instanceof expected) {
	      return true;
	    }
	  } catch (e) {
	    // Ignore.  The instanceof check doesn't work for arrow functions.
	  }

	  if (Error.isPrototypeOf(expected)) {
	    return false;
	  }

	  return expected.call({}, actual) === true;
	}

	function _tryBlock(block) {
	  var error;
	  try {
	    block();
	  } catch (e) {
	    error = e;
	  }
	  return error;
	}

	function _throws(shouldThrow, block, expected, message) {
	  var actual;

	  if (typeof block !== 'function') {
	    throw new TypeError('"block" argument must be a function');
	  }

	  if (typeof expected === 'string') {
	    message = expected;
	    expected = null;
	  }

	  actual = _tryBlock(block);

	  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +
	            (message ? ' ' + message : '.');

	  if (shouldThrow && !actual) {
	    fail(actual, expected, 'Missing expected exception' + message);
	  }

	  var userProvidedMessage = typeof message === 'string';
	  var isUnwantedException = !shouldThrow && util.isError(actual);
	  var isUnexpectedException = !shouldThrow && actual && !expected;

	  if ((isUnwantedException &&
	      userProvidedMessage &&
	      expectedException(actual, expected)) ||
	      isUnexpectedException) {
	    fail(actual, expected, 'Got unwanted exception' + message);
	  }

	  if ((shouldThrow && actual && expected &&
	      !expectedException(actual, expected)) || (!shouldThrow && actual)) {
	    throw actual;
	  }
	}

	// 11. Expected to throw an error:
	// assert.throws(block, Error_opt, message_opt);

	assert.throws = function(block, /*optional*/error, /*optional*/message) {
	  _throws(true, block, error, message);
	};

	// EXTENSION! This is annoying to write outside this module.
	assert.doesNotThrow = function(block, /*optional*/error, /*optional*/message) {
	  _throws(false, block, error, message);
	};

	assert.ifError = function(err) { if (err) throw err; };

	// Expose a strict only variant of assert
	function strict(value, message) {
	  if (!value) fail(value, true, message, '==', strict);
	}
	assert.strict = objectAssign(strict, assert, {
	  equal: assert.strictEqual,
	  deepEqual: assert.deepStrictEqual,
	  notEqual: assert.notStrictEqual,
	  notDeepEqual: assert.notDeepStrictEqual
	});
	assert.strict.strict = assert.strict;

	var objectKeys = Object.keys || function (obj) {
	  var keys = [];
	  for (var key in obj) {
	    if (hasOwn.call(obj, key)) keys.push(key);
	  }
	  return keys;
	};

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ }),
/* 22 */
/***/ (function(module, exports) {

	/*
	object-assign
	(c) Sindre Sorhus
	@license MIT
	*/

	'use strict';
	/* eslint-disable no-unused-vars */
	var getOwnPropertySymbols = Object.getOwnPropertySymbols;
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	var propIsEnumerable = Object.prototype.propertyIsEnumerable;

	function toObject(val) {
		if (val === null || val === undefined) {
			throw new TypeError('Object.assign cannot be called with null or undefined');
		}

		return Object(val);
	}

	function shouldUseNative() {
		try {
			if (!Object.assign) {
				return false;
			}

			// Detect buggy property enumeration order in older V8 versions.

			// https://bugs.chromium.org/p/v8/issues/detail?id=4118
			var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
			test1[5] = 'de';
			if (Object.getOwnPropertyNames(test1)[0] === '5') {
				return false;
			}

			// https://bugs.chromium.org/p/v8/issues/detail?id=3056
			var test2 = {};
			for (var i = 0; i < 10; i++) {
				test2['_' + String.fromCharCode(i)] = i;
			}
			var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
				return test2[n];
			});
			if (order2.join('') !== '0123456789') {
				return false;
			}

			// https://bugs.chromium.org/p/v8/issues/detail?id=3056
			var test3 = {};
			'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
				test3[letter] = letter;
			});
			if (Object.keys(Object.assign({}, test3)).join('') !==
					'abcdefghijklmnopqrst') {
				return false;
			}

			return true;
		} catch (err) {
			// We don't expect any of the above to throw, but better to be safe.
			return false;
		}
	}

	module.exports = shouldUseNative() ? Object.assign : function (target, source) {
		var from;
		var to = toObject(target);
		var symbols;

		for (var s = 1; s < arguments.length; s++) {
			from = Object(arguments[s]);

			for (var key in from) {
				if (hasOwnProperty.call(from, key)) {
					to[key] = from[key];
				}
			}

			if (getOwnPropertySymbols) {
				symbols = getOwnPropertySymbols(from);
				for (var i = 0; i < symbols.length; i++) {
					if (propIsEnumerable.call(from, symbols[i])) {
						to[symbols[i]] = from[symbols[i]];
					}
				}
			}
		}

		return to;
	};


/***/ }),
/* 23 */
/***/ (function(module, exports, __nested_webpack_require_112702__) {

	/* WEBPACK VAR INJECTION */(function(global, process) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	var formatRegExp = /%[sdj%]/g;
	exports.format = function(f) {
	  if (!isString(f)) {
	    var objects = [];
	    for (var i = 0; i < arguments.length; i++) {
	      objects.push(inspect(arguments[i]));
	    }
	    return objects.join(' ');
	  }

	  var i = 1;
	  var args = arguments;
	  var len = args.length;
	  var str = String(f).replace(formatRegExp, function(x) {
	    if (x === '%%') return '%';
	    if (i >= len) return x;
	    switch (x) {
	      case '%s': return String(args[i++]);
	      case '%d': return Number(args[i++]);
	      case '%j':
	        try {
	          return JSON.stringify(args[i++]);
	        } catch (_) {
	          return '[Circular]';
	        }
	      default:
	        return x;
	    }
	  });
	  for (var x = args[i]; i < len; x = args[++i]) {
	    if (isNull(x) || !isObject(x)) {
	      str += ' ' + x;
	    } else {
	      str += ' ' + inspect(x);
	    }
	  }
	  return str;
	};


	// Mark that a method should not be used.
	// Returns a modified function which warns once by default.
	// If --no-deprecation is set, then it is a no-op.
	exports.deprecate = function(fn, msg) {
	  // Allow for deprecating things in the process of starting up.
	  if (isUndefined(global.process)) {
	    return function() {
	      return exports.deprecate(fn, msg).apply(this, arguments);
	    };
	  }

	  if (process.noDeprecation === true) {
	    return fn;
	  }

	  var warned = false;
	  function deprecated() {
	    if (!warned) {
	      if (process.throwDeprecation) {
	        throw new Error(msg);
	      } else if (process.traceDeprecation) {
	        console.trace(msg);
	      } else {
	        console.error(msg);
	      }
	      warned = true;
	    }
	    return fn.apply(this, arguments);
	  }

	  return deprecated;
	};


	var debugs = {};
	var debugEnviron;
	exports.debuglog = function(set) {
	  if (isUndefined(debugEnviron))
	    debugEnviron = process.env.NODE_DEBUG || '';
	  set = set.toUpperCase();
	  if (!debugs[set]) {
	    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
	      var pid = process.pid;
	      debugs[set] = function() {
	        var msg = exports.format.apply(exports, arguments);
	        console.error('%s %d: %s', set, pid, msg);
	      };
	    } else {
	      debugs[set] = function() {};
	    }
	  }
	  return debugs[set];
	};


	/**
	 * Echos the value of a value. Trys to print the value out
	 * in the best way possible given the different types.
	 *
	 * @param {Object} obj The object to print out.
	 * @param {Object} opts Optional options object that alters the output.
	 */
	/* legacy: obj, showHidden, depth, colors*/
	function inspect(obj, opts) {
	  // default options
	  var ctx = {
	    seen: [],
	    stylize: stylizeNoColor
	  };
	  // legacy...
	  if (arguments.length >= 3) ctx.depth = arguments[2];
	  if (arguments.length >= 4) ctx.colors = arguments[3];
	  if (isBoolean(opts)) {
	    // legacy...
	    ctx.showHidden = opts;
	  } else if (opts) {
	    // got an "options" object
	    exports._extend(ctx, opts);
	  }
	  // set default options
	  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
	  if (isUndefined(ctx.depth)) ctx.depth = 2;
	  if (isUndefined(ctx.colors)) ctx.colors = false;
	  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
	  if (ctx.colors) ctx.stylize = stylizeWithColor;
	  return formatValue(ctx, obj, ctx.depth);
	}
	exports.inspect = inspect;


	// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
	inspect.colors = {
	  'bold' : [1, 22],
	  'italic' : [3, 23],
	  'underline' : [4, 24],
	  'inverse' : [7, 27],
	  'white' : [37, 39],
	  'grey' : [90, 39],
	  'black' : [30, 39],
	  'blue' : [34, 39],
	  'cyan' : [36, 39],
	  'green' : [32, 39],
	  'magenta' : [35, 39],
	  'red' : [31, 39],
	  'yellow' : [33, 39]
	};

	// Don't use 'blue' not visible on cmd.exe
	inspect.styles = {
	  'special': 'cyan',
	  'number': 'yellow',
	  'boolean': 'yellow',
	  'undefined': 'grey',
	  'null': 'bold',
	  'string': 'green',
	  'date': 'magenta',
	  // "name": intentionally not styling
	  'regexp': 'red'
	};


	function stylizeWithColor(str, styleType) {
	  var style = inspect.styles[styleType];

	  if (style) {
	    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
	           '\u001b[' + inspect.colors[style][1] + 'm';
	  } else {
	    return str;
	  }
	}


	function stylizeNoColor(str, styleType) {
	  return str;
	}


	function arrayToHash(array) {
	  var hash = {};

	  array.forEach(function(val, idx) {
	    hash[val] = true;
	  });

	  return hash;
	}


	function formatValue(ctx, value, recurseTimes) {
	  // Provide a hook for user-specified inspect functions.
	  // Check that value is an object with an inspect function on it
	  if (ctx.customInspect &&
	      value &&
	      isFunction(value.inspect) &&
	      // Filter out the util module, it's inspect function is special
	      value.inspect !== exports.inspect &&
	      // Also filter out any prototype objects using the circular check.
	      !(value.constructor && value.constructor.prototype === value)) {
	    var ret = value.inspect(recurseTimes, ctx);
	    if (!isString(ret)) {
	      ret = formatValue(ctx, ret, recurseTimes);
	    }
	    return ret;
	  }

	  // Primitive types cannot have properties
	  var primitive = formatPrimitive(ctx, value);
	  if (primitive) {
	    return primitive;
	  }

	  // Look up the keys of the object.
	  var keys = Object.keys(value);
	  var visibleKeys = arrayToHash(keys);

	  if (ctx.showHidden) {
	    keys = Object.getOwnPropertyNames(value);
	  }

	  // IE doesn't make error fields non-enumerable
	  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
	  if (isError(value)
	      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
	    return formatError(value);
	  }

	  // Some type of object without properties can be shortcutted.
	  if (keys.length === 0) {
	    if (isFunction(value)) {
	      var name = value.name ? ': ' + value.name : '';
	      return ctx.stylize('[Function' + name + ']', 'special');
	    }
	    if (isRegExp(value)) {
	      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
	    }
	    if (isDate(value)) {
	      return ctx.stylize(Date.prototype.toString.call(value), 'date');
	    }
	    if (isError(value)) {
	      return formatError(value);
	    }
	  }

	  var base = '', array = false, braces = ['{', '}'];

	  // Make Array say that they are Array
	  if (isArray(value)) {
	    array = true;
	    braces = ['[', ']'];
	  }

	  // Make functions say that they are functions
	  if (isFunction(value)) {
	    var n = value.name ? ': ' + value.name : '';
	    base = ' [Function' + n + ']';
	  }

	  // Make RegExps say that they are RegExps
	  if (isRegExp(value)) {
	    base = ' ' + RegExp.prototype.toString.call(value);
	  }

	  // Make dates with properties first say the date
	  if (isDate(value)) {
	    base = ' ' + Date.prototype.toUTCString.call(value);
	  }

	  // Make error with message first say the error
	  if (isError(value)) {
	    base = ' ' + formatError(value);
	  }

	  if (keys.length === 0 && (!array || value.length == 0)) {
	    return braces[0] + base + braces[1];
	  }

	  if (recurseTimes < 0) {
	    if (isRegExp(value)) {
	      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
	    } else {
	      return ctx.stylize('[Object]', 'special');
	    }
	  }

	  ctx.seen.push(value);

	  var output;
	  if (array) {
	    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
	  } else {
	    output = keys.map(function(key) {
	      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
	    });
	  }

	  ctx.seen.pop();

	  return reduceToSingleString(output, base, braces);
	}


	function formatPrimitive(ctx, value) {
	  if (isUndefined(value))
	    return ctx.stylize('undefined', 'undefined');
	  if (isString(value)) {
	    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
	                                             .replace(/'/g, "\\'")
	                                             .replace(/\\"/g, '"') + '\'';
	    return ctx.stylize(simple, 'string');
	  }
	  if (isNumber(value))
	    return ctx.stylize('' + value, 'number');
	  if (isBoolean(value))
	    return ctx.stylize('' + value, 'boolean');
	  // For some reason typeof null is "object", so special case here.
	  if (isNull(value))
	    return ctx.stylize('null', 'null');
	}


	function formatError(value) {
	  return '[' + Error.prototype.toString.call(value) + ']';
	}


	function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
	  var output = [];
	  for (var i = 0, l = value.length; i < l; ++i) {
	    if (hasOwnProperty(value, String(i))) {
	      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
	          String(i), true));
	    } else {
	      output.push('');
	    }
	  }
	  keys.forEach(function(key) {
	    if (!key.match(/^\d+$/)) {
	      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
	          key, true));
	    }
	  });
	  return output;
	}


	function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
	  var name, str, desc;
	  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
	  if (desc.get) {
	    if (desc.set) {
	      str = ctx.stylize('[Getter/Setter]', 'special');
	    } else {
	      str = ctx.stylize('[Getter]', 'special');
	    }
	  } else {
	    if (desc.set) {
	      str = ctx.stylize('[Setter]', 'special');
	    }
	  }
	  if (!hasOwnProperty(visibleKeys, key)) {
	    name = '[' + key + ']';
	  }
	  if (!str) {
	    if (ctx.seen.indexOf(desc.value) < 0) {
	      if (isNull(recurseTimes)) {
	        str = formatValue(ctx, desc.value, null);
	      } else {
	        str = formatValue(ctx, desc.value, recurseTimes - 1);
	      }
	      if (str.indexOf('\n') > -1) {
	        if (array) {
	          str = str.split('\n').map(function(line) {
	            return '  ' + line;
	          }).join('\n').substr(2);
	        } else {
	          str = '\n' + str.split('\n').map(function(line) {
	            return '   ' + line;
	          }).join('\n');
	        }
	      }
	    } else {
	      str = ctx.stylize('[Circular]', 'special');
	    }
	  }
	  if (isUndefined(name)) {
	    if (array && key.match(/^\d+$/)) {
	      return str;
	    }
	    name = JSON.stringify('' + key);
	    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
	      name = name.substr(1, name.length - 2);
	      name = ctx.stylize(name, 'name');
	    } else {
	      name = name.replace(/'/g, "\\'")
	                 .replace(/\\"/g, '"')
	                 .replace(/(^"|"$)/g, "'");
	      name = ctx.stylize(name, 'string');
	    }
	  }

	  return name + ': ' + str;
	}


	function reduceToSingleString(output, base, braces) {
	  var numLinesEst = 0;
	  var length = output.reduce(function(prev, cur) {
	    numLinesEst++;
	    if (cur.indexOf('\n') >= 0) numLinesEst++;
	    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
	  }, 0);

	  if (length > 60) {
	    return braces[0] +
	           (base === '' ? '' : base + '\n ') +
	           ' ' +
	           output.join(',\n  ') +
	           ' ' +
	           braces[1];
	  }

	  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
	}


	// NOTE: These type checking functions intentionally don't use `instanceof`
	// because it is fragile and can be easily faked with `Object.create()`.
	function isArray(ar) {
	  return Array.isArray(ar);
	}
	exports.isArray = isArray;

	function isBoolean(arg) {
	  return typeof arg === 'boolean';
	}
	exports.isBoolean = isBoolean;

	function isNull(arg) {
	  return arg === null;
	}
	exports.isNull = isNull;

	function isNullOrUndefined(arg) {
	  return arg == null;
	}
	exports.isNullOrUndefined = isNullOrUndefined;

	function isNumber(arg) {
	  return typeof arg === 'number';
	}
	exports.isNumber = isNumber;

	function isString(arg) {
	  return typeof arg === 'string';
	}
	exports.isString = isString;

	function isSymbol(arg) {
	  return typeof arg === 'symbol';
	}
	exports.isSymbol = isSymbol;

	function isUndefined(arg) {
	  return arg === void 0;
	}
	exports.isUndefined = isUndefined;

	function isRegExp(re) {
	  return isObject(re) && objectToString(re) === '[object RegExp]';
	}
	exports.isRegExp = isRegExp;

	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}
	exports.isObject = isObject;

	function isDate(d) {
	  return isObject(d) && objectToString(d) === '[object Date]';
	}
	exports.isDate = isDate;

	function isError(e) {
	  return isObject(e) &&
	      (objectToString(e) === '[object Error]' || e instanceof Error);
	}
	exports.isError = isError;

	function isFunction(arg) {
	  return typeof arg === 'function';
	}
	exports.isFunction = isFunction;

	function isPrimitive(arg) {
	  return arg === null ||
	         typeof arg === 'boolean' ||
	         typeof arg === 'number' ||
	         typeof arg === 'string' ||
	         typeof arg === 'symbol' ||  // ES6 symbol
	         typeof arg === 'undefined';
	}
	exports.isPrimitive = isPrimitive;

	exports.isBuffer = __nested_webpack_require_112702__(25);

	function objectToString(o) {
	  return Object.prototype.toString.call(o);
	}


	function pad(n) {
	  return n < 10 ? '0' + n.toString(10) : n.toString(10);
	}


	var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
	              'Oct', 'Nov', 'Dec'];

	// 26 Feb 16:19:34
	function timestamp() {
	  var d = new Date();
	  var time = [pad(d.getHours()),
	              pad(d.getMinutes()),
	              pad(d.getSeconds())].join(':');
	  return [d.getDate(), months[d.getMonth()], time].join(' ');
	}


	// log is just a thin wrapper to console.log that prepends a timestamp
	exports.log = function() {
	  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
	};


	/**
	 * Inherit the prototype methods from one constructor into another.
	 *
	 * The Function.prototype.inherits from lang.js rewritten as a standalone
	 * function (not on Function.prototype). NOTE: If this file is to be loaded
	 * during bootstrapping this function needs to be rewritten using some native
	 * functions as prototype setup using normal JavaScript does not work as
	 * expected during bootstrapping (see mirror.js in r114903).
	 *
	 * @param {function} ctor Constructor function which needs to inherit the
	 *     prototype.
	 * @param {function} superCtor Constructor function to inherit prototype from.
	 */
	exports.inherits = __nested_webpack_require_112702__(26);

	exports._extend = function(origin, add) {
	  // Don't do anything if add isn't an object
	  if (!add || !isObject(add)) return origin;

	  var keys = Object.keys(add);
	  var i = keys.length;
	  while (i--) {
	    origin[keys[i]] = add[keys[i]];
	  }
	  return origin;
	};

	function hasOwnProperty(obj, prop) {
	  return Object.prototype.hasOwnProperty.call(obj, prop);
	}

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __nested_webpack_require_112702__(24)))

/***/ }),
/* 24 */
/***/ (function(module, exports) {

	// shim for using process in browser
	var process = module.exports = {};

	// cached from whatever global is present so that test runners that stub it
	// don't break things.  But we need to wrap it in a try catch in case it is
	// wrapped in strict mode code which doesn't define any globals.  It's inside a
	// function because try/catches deoptimize in certain engines.

	var cachedSetTimeout;
	var cachedClearTimeout;

	function defaultSetTimout() {
	    throw new Error('setTimeout has not been defined');
	}
	function defaultClearTimeout () {
	    throw new Error('clearTimeout has not been defined');
	}
	(function () {
	    try {
	        if (typeof setTimeout === 'function') {
	            cachedSetTimeout = setTimeout;
	        } else {
	            cachedSetTimeout = defaultSetTimout;
	        }
	    } catch (e) {
	        cachedSetTimeout = defaultSetTimout;
	    }
	    try {
	        if (typeof clearTimeout === 'function') {
	            cachedClearTimeout = clearTimeout;
	        } else {
	            cachedClearTimeout = defaultClearTimeout;
	        }
	    } catch (e) {
	        cachedClearTimeout = defaultClearTimeout;
	    }
	} ())
	function runTimeout(fun) {
	    if (cachedSetTimeout === setTimeout) {
	        //normal enviroments in sane situations
	        return setTimeout(fun, 0);
	    }
	    // if setTimeout wasn't available but was latter defined
	    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
	        cachedSetTimeout = setTimeout;
	        return setTimeout(fun, 0);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedSetTimeout(fun, 0);
	    } catch(e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
	            return cachedSetTimeout.call(null, fun, 0);
	        } catch(e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
	            return cachedSetTimeout.call(this, fun, 0);
	        }
	    }


	}
	function runClearTimeout(marker) {
	    if (cachedClearTimeout === clearTimeout) {
	        //normal enviroments in sane situations
	        return clearTimeout(marker);
	    }
	    // if clearTimeout wasn't available but was latter defined
	    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
	        cachedClearTimeout = clearTimeout;
	        return clearTimeout(marker);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedClearTimeout(marker);
	    } catch (e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
	            return cachedClearTimeout.call(null, marker);
	        } catch (e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
	            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
	            return cachedClearTimeout.call(this, marker);
	        }
	    }



	}
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;

	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}

	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = runTimeout(cleanUpNextTick);
	    draining = true;

	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    runClearTimeout(timeout);
	}

	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        runTimeout(drainQueue);
	    }
	};

	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};

	function noop() {}

	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;
	process.prependListener = noop;
	process.prependOnceListener = noop;

	process.listeners = function (name) { return [] }

	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};

	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ }),
/* 25 */
/***/ (function(module, exports) {

	module.exports = function isBuffer(arg) {
	  return arg && typeof arg === 'object'
	    && typeof arg.copy === 'function'
	    && typeof arg.fill === 'function'
	    && typeof arg.readUInt8 === 'function';
	}

/***/ }),
/* 26 */
/***/ (function(module, exports) {

	if (typeof Object.create === 'function') {
	  // implementation from standard node.js 'util' module
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    ctor.prototype = Object.create(superCtor.prototype, {
	      constructor: {
	        value: ctor,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	  };
	} else {
	  // old school shim for old browsers
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    var TempCtor = function () {}
	    TempCtor.prototype = superCtor.prototype
	    ctor.prototype = new TempCtor()
	    ctor.prototype.constructor = ctor
	  }
	}


/***/ }),
/* 27 */
/***/ (function(module, exports, __nested_webpack_require_135660__) {

	var DOM = __nested_webpack_require_135660__(9);
	var utils = __nested_webpack_require_135660__(7);

	module.exports = (function() {
	    var canvas = DOM.newEl('canvas');
	    var ctx = null;

	    return function(sceneGraph) {
	        if (ctx == null) {
	            ctx = canvas.getContext('2d');
	        }

	        var dpr = utils.canvasRatio();
	        var root = sceneGraph.root;
	        canvas.width = dpr * root.properties.width;
	        canvas.height = dpr * root.properties.height ;
	        ctx.textBaseline = 'middle';

	        var bg = root.children.holderBg;
	        var bgWidth = dpr * bg.width;
	        var bgHeight = dpr * bg.height;
	        //todo: parametrize outline width (e.g. in scene object)
	        var outlineWidth = 2;
	        var outlineOffsetWidth = outlineWidth / 2;

	        ctx.fillStyle = bg.properties.fill;
	        ctx.fillRect(0, 0, bgWidth, bgHeight);

	        if (bg.properties.outline) {
	            //todo: abstract this into a method
	            ctx.strokeStyle = bg.properties.outline.fill;
	            ctx.lineWidth = bg.properties.outline.width;
	            ctx.moveTo(outlineOffsetWidth, outlineOffsetWidth);
	            // TL, TR, BR, BL
	            ctx.lineTo(bgWidth - outlineOffsetWidth, outlineOffsetWidth);
	            ctx.lineTo(bgWidth - outlineOffsetWidth, bgHeight - outlineOffsetWidth);
	            ctx.lineTo(outlineOffsetWidth, bgHeight - outlineOffsetWidth);
	            ctx.lineTo(outlineOffsetWidth, outlineOffsetWidth);
	            // Diagonals
	            ctx.moveTo(0, outlineOffsetWidth);
	            ctx.lineTo(bgWidth, bgHeight - outlineOffsetWidth);
	            ctx.moveTo(0, bgHeight - outlineOffsetWidth);
	            ctx.lineTo(bgWidth, outlineOffsetWidth);
	            ctx.stroke();
	        }

	        var textGroup = root.children.holderTextGroup;
	        ctx.font = textGroup.properties.font.weight + ' ' + (dpr * textGroup.properties.font.size) + textGroup.properties.font.units + ' ' + textGroup.properties.font.family + ', monospace';
	        ctx.fillStyle = textGroup.properties.fill;

	        for (var lineKey in textGroup.children) {
	            var line = textGroup.children[lineKey];
	            for (var wordKey in line.children) {
	                var word = line.children[wordKey];
	                var x = dpr * (textGroup.x + line.x + word.x);
	                var y = dpr * (textGroup.y + line.y + word.y + (textGroup.properties.leading / 2));

	                ctx.fillText(word.properties.text, x, y);
	            }
	        }

	        return canvas.toDataURL('image/png');
	    };
	})();

/***/ })
/******/ ])
});
;
(function(ctx, isMeteorPackage) {
    if (isMeteorPackage) {
        Holder = ctx.Holder;
    }
})(this, typeof Meteor !== 'undefined' && typeof Package !== 'undefined');


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfaG9sZGVyanNfaG9sZGVyX2pzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaURBQWlELDREQUE0RDtBQUM3RztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDOztBQUU5QztBQUNBO0FBQ0EsdUNBQXVDOztBQUV2QztBQUNBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0NBQXNDO0FBQ3RDLHNDQUFzQztBQUN0QywwQ0FBMEM7O0FBRTFDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0NBQXdDOztBQUV4QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0EsS0FBSztBQUNMLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0EsS0FBSztBQUNMLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBLElBQUksSUFBeUQ7QUFDN0Q7QUFDQSxNQUFNLEVBS3VCO0FBQzdCLENBQUM7QUFDRCxxQ0FBcUM7QUFDckM7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQiwrQkFBbUI7O0FBRXRDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBFQUEwRSwrQkFBbUI7O0FBRTdGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBLFVBQVUsK0JBQW1COztBQUU3QjtBQUNBLFVBQVUsK0JBQW1COztBQUU3QjtBQUNBLFVBQVUsK0JBQW1COztBQUU3QjtBQUNBLGlCQUFpQiwrQkFBbUI7QUFDcEMsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQywrQkFBbUI7O0FBRXBEO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQiwrQkFBbUI7OztBQUdyQyxPQUFPO0FBQ1A7QUFDQSxpQ0FBaUMsK0JBQW1COztBQUVwRCwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLCtCQUFtQjtBQUNyQyxtQkFBbUIsK0JBQW1COztBQUV0QyxrQkFBa0IsK0JBQW1CO0FBQ3JDLGFBQWEsK0JBQW1CO0FBQ2hDLFdBQVcsK0JBQW1CO0FBQzlCLFdBQVcsK0JBQW1CO0FBQzlCLGFBQWEsK0JBQW1CO0FBQ2hDLGlCQUFpQiwrQkFBbUI7O0FBRXBDLG1CQUFtQiwrQkFBbUI7QUFDdEMsd0JBQXdCLCtCQUFtQjs7QUFFM0M7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEIsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QixnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVOztBQUVWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBLFVBQVU7O0FBRVY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLFVBQVU7O0FBRVY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSxVQUFVOztBQUVWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHNCQUFzQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QixtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOOztBQUVBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTs7QUFFVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCLHlCQUF5QjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSx3Q0FBd0MsT0FBTztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEIsY0FBYzs7QUFFZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxrQkFBa0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsTUFBTTtBQUNOOztBQUVBOztBQUVBLDZCQUE2Qiw2QkFBNkIsY0FBYzs7QUFFeEUsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLE9BQU87QUFDUDtBQUNBLGlDQUFpQyxnQ0FBbUI7O0FBRXBEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksZ0NBQW1CO0FBQy9CLFlBQVksZ0NBQW1COztBQUUvQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLGtCQUFrQjtBQUNyQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHVCQUF1QixrQkFBa0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsUUFBUTtBQUMxQztBQUNBO0FBQ0EsNENBQTRDO0FBQzVDLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBLE1BQU07QUFDTjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsRUFBRSxvQkFBb0IsRUFBRTtBQUMzRCw0QkFBNEIsSUFBSSxZQUFZLElBQUksWUFBWSxJQUFJO0FBQ2hFLDhCQUE4QixJQUFJLFlBQVksSUFBSSxZQUFZLElBQUksZ0JBQWdCLEdBQUc7O0FBRXJGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSw2QkFBNkIsNkJBQTZCLGNBQWM7O0FBRXhFLE9BQU87QUFDUDtBQUNBLGlDQUFpQyxnQ0FBbUI7O0FBRXBELCtDQUErQyxVQUFVLGdDQUFtQjs7QUFFNUU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsMkJBQTJCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDLDRDQUE0QyxjQUFjOztBQUUxRDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLFFBQVE7QUFDdEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFDQUFxQyxRQUFRLElBQUk7QUFDakQ7QUFDQTs7QUFFQSw2QkFBNkIsNkJBQTZCLGNBQWM7O0FBRXhFLE9BQU87QUFDUDtBQUNBOztBQUVBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSw2QkFBNkIsNkJBQTZCLGNBQWM7O0FBRXhFLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQSxpQ0FBaUMsZ0NBQW1COztBQUVwRCxjQUFjLGdDQUFtQjs7QUFFakMsV0FBVyxnQ0FBbUI7QUFDOUIsaUJBQWlCLGdDQUFtQjtBQUNwQyxhQUFhLGdDQUFtQjs7QUFFaEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjs7QUFFQTtBQUNBOztBQUVBLHVDQUF1Qyx3Q0FBd0M7O0FBRS9FO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0EsTUFBTTtBQUNOLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7O0FBRUEsYUFBYTtBQUNiLG1DQUFtQztBQUNuQzs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQSxpQ0FBaUMsZ0NBQW1COztBQUVwRDtBQUNBLGtCQUFrQixnQ0FBbUI7OztBQUdyQyxPQUFPO0FBQ1A7QUFDQSxpQ0FBaUMsZ0NBQW1COztBQUVwRDs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRixzR0FBc0cscUJBQXFCLG1CQUFtQjs7QUFFOUk7O0FBRUEseUJBQXlCLGdDQUFtQjs7QUFFNUM7O0FBRUEsZUFBZSxnQ0FBbUI7O0FBRWxDOztBQUVBLGlCQUFpQixnQ0FBbUI7O0FBRXBDOztBQUVBLDBCQUEwQixnQ0FBbUI7O0FBRTdDOztBQUVBLGVBQWUsZ0NBQW1COztBQUVsQzs7QUFFQSx5Q0FBeUMsNkJBQTZCLGNBQWMsT0FBTyxpQkFBaUIsbUJBQW1CLHVCQUF1QixnRkFBZ0Ysc0JBQXNCOztBQUU1UCx3Q0FBd0MsdUNBQXVDOztBQUUvRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0QkFBNEI7QUFDNUIscUJBQXFCO0FBQ3JCLGNBQWM7QUFDZDtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsWUFBWSxzQkFBc0I7O0FBRWxDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjOztBQUVkO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7O0FBRVY7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRSx3QkFBd0I7QUFDOUY7O0FBRUE7QUFDQSw2Q0FBNkMsd0JBQXdCLHdCQUF3QixzQkFBc0Isc0JBQXNCO0FBQ3pJOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQSxpQ0FBaUMsZ0NBQW1COztBQUVwRDs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRixzR0FBc0cscUJBQXFCLG1CQUFtQjs7QUFFOUksNkJBQTZCLGdDQUFtQjs7QUFFaEQ7O0FBRUEsNkJBQTZCLGdDQUFtQjs7QUFFaEQ7O0FBRUEsd0NBQXdDLHVDQUF1Qzs7QUFFL0U7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRixzR0FBc0cscUJBQXFCLG1CQUFtQjs7QUFFOUk7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSx5RkFBeUY7QUFDekY7O0FBRUEsT0FBTztBQUNQO0FBQ0EsaUNBQWlDLGdDQUFtQjs7QUFFcEQsK0NBQStDOztBQUUvQyxvQkFBb0IsZ0NBQW1COztBQUV2QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEseUNBQXlDLFNBQVM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsWUFBWSxnQ0FBbUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQSxvREFBb0Q7O0FBRXBEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixpREFBaUQ7O0FBRWpEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTCx1QkFBdUI7O0FBRXZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsUUFBUTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFFBQVE7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDBCQUEwQjtBQUMxQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0NBQWtDOztBQUVsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkJBQTZCLDZCQUE2QixjQUFjOztBQUV4RSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0Isc0JBQXNCO0FBQ3hDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixvQkFBb0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBLE9BQU87QUFDUDtBQUNBLGlDQUFpQyxpQ0FBbUI7O0FBRXBELHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixzQkFBc0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0oseUJBQXlCLFNBQVM7QUFDbEM7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkNBQTZDLEtBQUs7O0FBRWxEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxxQ0FBcUMsT0FBTztBQUM1QztBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaLFdBQVc7QUFDWDtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsaUNBQW1COztBQUV2QztBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxVQUFVO0FBQ3RCO0FBQ0EsWUFBWSxVQUFVO0FBQ3RCO0FBQ0Esb0JBQW9CLGlDQUFtQjs7QUFFdkM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw2QkFBNkIsNkJBQTZCLGNBQWMsS0FBSyxpQ0FBbUI7O0FBRWhHLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsc0JBQXNCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1Q0FBdUM7O0FBRXZDO0FBQ0E7QUFDQTs7QUFFQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsOEJBQThCOzs7QUFHOUIsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQSxpQ0FBaUMsaUNBQW1COztBQUVwRCxXQUFXLGlDQUFtQjtBQUM5QixhQUFhLGlDQUFtQjs7QUFFaEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRixPQUFPO0FBQ1A7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaG9sZGVyanMvaG9sZGVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuXG5Ib2xkZXIgLSBjbGllbnQgc2lkZSBpbWFnZSBwbGFjZWhvbGRlcnNcblZlcnNpb24gMi45Ljkramw3elxuwqkgMjAyMSBJdmFuIE1hbG9waW5za3kgLSBodHRwczovL2ltc2t5LmNvXG5cblNpdGU6ICAgICBodHRwOi8vaG9sZGVyanMuY29tXG5Jc3N1ZXM6ICAgaHR0cHM6Ly9naXRodWIuY29tL2ltc2t5L2hvbGRlci9pc3N1ZXNcbkxpY2Vuc2U6ICBNSVRcblxuKi9cbihmdW5jdGlvbiAod2luZG93KSB7XG4gIGlmICghd2luZG93LmRvY3VtZW50KSByZXR1cm47XG4gIHZhciBkb2N1bWVudCA9IHdpbmRvdy5kb2N1bWVudDtcblxuICAvL2h0dHBzOi8vZ2l0aHViLmNvbS9pbmV4b3JhYmxldGFzaC9wb2x5ZmlsbC9ibG9iL21hc3Rlci93ZWIuanNcbiAgICBpZiAoIWRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwpIHtcbiAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwgPSBmdW5jdGlvbiAoc2VsZWN0b3JzKSB7XG4gICAgICAgIHZhciBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyksIGVsZW1lbnRzID0gW10sIGVsZW1lbnQ7XG4gICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5maXJzdENoaWxkLmFwcGVuZENoaWxkKHN0eWxlKTtcbiAgICAgICAgZG9jdW1lbnQuX3FzYSA9IFtdO1xuXG4gICAgICAgIHN0eWxlLnN0eWxlU2hlZXQuY3NzVGV4dCA9IHNlbGVjdG9ycyArICd7eC1xc2E6ZXhwcmVzc2lvbihkb2N1bWVudC5fcXNhICYmIGRvY3VtZW50Ll9xc2EucHVzaCh0aGlzKSl9JztcbiAgICAgICAgd2luZG93LnNjcm9sbEJ5KDAsIDApO1xuICAgICAgICBzdHlsZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0eWxlKTtcblxuICAgICAgICB3aGlsZSAoZG9jdW1lbnQuX3FzYS5sZW5ndGgpIHtcbiAgICAgICAgICBlbGVtZW50ID0gZG9jdW1lbnQuX3FzYS5zaGlmdCgpO1xuICAgICAgICAgIGVsZW1lbnQuc3R5bGUucmVtb3ZlQXR0cmlidXRlKCd4LXFzYScpO1xuICAgICAgICAgIGVsZW1lbnRzLnB1c2goZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgZG9jdW1lbnQuX3FzYSA9IG51bGw7XG4gICAgICAgIHJldHVybiBlbGVtZW50cztcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKCFkb2N1bWVudC5xdWVyeVNlbGVjdG9yKSB7XG4gICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yID0gZnVuY3Rpb24gKHNlbGVjdG9ycykge1xuICAgICAgICB2YXIgZWxlbWVudHMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9ycyk7XG4gICAgICAgIHJldHVybiAoZWxlbWVudHMubGVuZ3RoKSA/IGVsZW1lbnRzWzBdIDogbnVsbDtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKCFkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKSB7XG4gICAgICBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lID0gZnVuY3Rpb24gKGNsYXNzTmFtZXMpIHtcbiAgICAgICAgY2xhc3NOYW1lcyA9IFN0cmluZyhjbGFzc05hbWVzKS5yZXBsYWNlKC9efFxccysvZywgJy4nKTtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoY2xhc3NOYW1lcyk7XG4gICAgICB9O1xuICAgIH1cblxuICAvL2h0dHBzOi8vZ2l0aHViLmNvbS9pbmV4b3JhYmxldGFzaC9wb2x5ZmlsbFxuICAvLyBFUzUgMTUuMi4zLjE0IE9iamVjdC5rZXlzICggTyApXG4gIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9rZXlzXG4gIGlmICghT2JqZWN0LmtleXMpIHtcbiAgICBPYmplY3Qua2V5cyA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICBpZiAobyAhPT0gT2JqZWN0KG8pKSB7IHRocm93IFR5cGVFcnJvcignT2JqZWN0LmtleXMgY2FsbGVkIG9uIG5vbi1vYmplY3QnKTsgfVxuICAgICAgdmFyIHJldCA9IFtdLCBwO1xuICAgICAgZm9yIChwIGluIG8pIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvLCBwKSkge1xuICAgICAgICAgIHJldC5wdXNoKHApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH07XG4gIH1cblxuICAvLyBFUzUgMTUuNC40LjE4IEFycmF5LnByb3RvdHlwZS5mb3JFYWNoICggY2FsbGJhY2tmbiBbICwgdGhpc0FyZyBdIClcbiAgLy8gRnJvbSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9mb3JFYWNoXG4gIGlmICghQXJyYXkucHJvdG90eXBlLmZvckVhY2gpIHtcbiAgICBBcnJheS5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIChmdW4gLyosIHRoaXNwICovKSB7XG4gICAgICBpZiAodGhpcyA9PT0gdm9pZCAwIHx8IHRoaXMgPT09IG51bGwpIHsgdGhyb3cgVHlwZUVycm9yKCk7IH1cblxuICAgICAgdmFyIHQgPSBPYmplY3QodGhpcyk7XG4gICAgICB2YXIgbGVuID0gdC5sZW5ndGggPj4+IDA7XG4gICAgICBpZiAodHlwZW9mIGZ1biAhPT0gXCJmdW5jdGlvblwiKSB7IHRocm93IFR5cGVFcnJvcigpOyB9XG5cbiAgICAgIHZhciB0aGlzcCA9IGFyZ3VtZW50c1sxXSwgaTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpZiAoaSBpbiB0KSB7XG4gICAgICAgICAgZnVuLmNhbGwodGhpc3AsIHRbaV0sIGksIHQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8vaHR0cHM6Ly9naXRodWIuY29tL2luZXhvcmFibGV0YXNoL3BvbHlmaWxsL2Jsb2IvbWFzdGVyL3dlYi5qc1xuICAoZnVuY3Rpb24gKGdsb2JhbCkge1xuICAgIHZhciBCNjRfQUxQSEFCRVQgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLz0nO1xuICAgIGdsb2JhbC5hdG9iID0gZ2xvYmFsLmF0b2IgfHwgZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICBpbnB1dCA9IFN0cmluZyhpbnB1dCk7XG4gICAgICB2YXIgcG9zaXRpb24gPSAwLFxuICAgICAgICAgIG91dHB1dCA9IFtdLFxuICAgICAgICAgIGJ1ZmZlciA9IDAsIGJpdHMgPSAwLCBuO1xuXG4gICAgICBpbnB1dCA9IGlucHV0LnJlcGxhY2UoL1xccy9nLCAnJyk7XG4gICAgICBpZiAoKGlucHV0Lmxlbmd0aCAlIDQpID09PSAwKSB7IGlucHV0ID0gaW5wdXQucmVwbGFjZSgvPSskLywgJycpOyB9XG4gICAgICBpZiAoKGlucHV0Lmxlbmd0aCAlIDQpID09PSAxKSB7IHRocm93IEVycm9yKCdJbnZhbGlkQ2hhcmFjdGVyRXJyb3InKTsgfVxuICAgICAgaWYgKC9bXisvMC05QS1aYS16XS8udGVzdChpbnB1dCkpIHsgdGhyb3cgRXJyb3IoJ0ludmFsaWRDaGFyYWN0ZXJFcnJvcicpOyB9XG5cbiAgICAgIHdoaWxlIChwb3NpdGlvbiA8IGlucHV0Lmxlbmd0aCkge1xuICAgICAgICBuID0gQjY0X0FMUEhBQkVULmluZGV4T2YoaW5wdXQuY2hhckF0KHBvc2l0aW9uKSk7XG4gICAgICAgIGJ1ZmZlciA9IChidWZmZXIgPDwgNikgfCBuO1xuICAgICAgICBiaXRzICs9IDY7XG5cbiAgICAgICAgaWYgKGJpdHMgPT09IDI0KSB7XG4gICAgICAgICAgb3V0cHV0LnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZSgoYnVmZmVyID4+IDE2KSAmIDB4RkYpKTtcbiAgICAgICAgICBvdXRwdXQucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKChidWZmZXIgPj4gIDgpICYgMHhGRikpO1xuICAgICAgICAgIG91dHB1dC5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmZmVyICYgMHhGRikpO1xuICAgICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAgIGJ1ZmZlciA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcG9zaXRpb24gKz0gMTtcbiAgICAgIH1cblxuICAgICAgaWYgKGJpdHMgPT09IDEyKSB7XG4gICAgICAgIGJ1ZmZlciA9IGJ1ZmZlciA+PiA0O1xuICAgICAgICBvdXRwdXQucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZmZlciAmIDB4RkYpKTtcbiAgICAgIH0gZWxzZSBpZiAoYml0cyA9PT0gMTgpIHtcbiAgICAgICAgYnVmZmVyID0gYnVmZmVyID4+IDI7XG4gICAgICAgIG91dHB1dC5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoKGJ1ZmZlciA+PiA4KSAmIDB4RkYpKTtcbiAgICAgICAgb3V0cHV0LnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShidWZmZXIgJiAweEZGKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvdXRwdXQuam9pbignJyk7XG4gICAgfTtcblxuICAgIGdsb2JhbC5idG9hID0gZ2xvYmFsLmJ0b2EgfHwgZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICBpbnB1dCA9IFN0cmluZyhpbnB1dCk7XG4gICAgICB2YXIgcG9zaXRpb24gPSAwLFxuICAgICAgICAgIG91dCA9IFtdLFxuICAgICAgICAgIG8xLCBvMiwgbzMsXG4gICAgICAgICAgZTEsIGUyLCBlMywgZTQ7XG5cbiAgICAgIGlmICgvW15cXHgwMC1cXHhGRl0vLnRlc3QoaW5wdXQpKSB7IHRocm93IEVycm9yKCdJbnZhbGlkQ2hhcmFjdGVyRXJyb3InKTsgfVxuXG4gICAgICB3aGlsZSAocG9zaXRpb24gPCBpbnB1dC5sZW5ndGgpIHtcbiAgICAgICAgbzEgPSBpbnB1dC5jaGFyQ29kZUF0KHBvc2l0aW9uKyspO1xuICAgICAgICBvMiA9IGlucHV0LmNoYXJDb2RlQXQocG9zaXRpb24rKyk7XG4gICAgICAgIG8zID0gaW5wdXQuY2hhckNvZGVBdChwb3NpdGlvbisrKTtcblxuICAgICAgICAvLyAxMTExMTEgMTEyMjIyIDIyMjIzMyAzMzMzMzNcbiAgICAgICAgZTEgPSBvMSA+PiAyO1xuICAgICAgICBlMiA9ICgobzEgJiAweDMpIDw8IDQpIHwgKG8yID4+IDQpO1xuICAgICAgICBlMyA9ICgobzIgJiAweGYpIDw8IDIpIHwgKG8zID4+IDYpO1xuICAgICAgICBlNCA9IG8zICYgMHgzZjtcblxuICAgICAgICBpZiAocG9zaXRpb24gPT09IGlucHV0Lmxlbmd0aCArIDIpIHtcbiAgICAgICAgICBlMyA9IDY0OyBlNCA9IDY0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHBvc2l0aW9uID09PSBpbnB1dC5sZW5ndGggKyAxKSB7XG4gICAgICAgICAgZTQgPSA2NDtcbiAgICAgICAgfVxuXG4gICAgICAgIG91dC5wdXNoKEI2NF9BTFBIQUJFVC5jaGFyQXQoZTEpLFxuICAgICAgICAgICAgICAgICBCNjRfQUxQSEFCRVQuY2hhckF0KGUyKSxcbiAgICAgICAgICAgICAgICAgQjY0X0FMUEhBQkVULmNoYXJBdChlMyksXG4gICAgICAgICAgICAgICAgIEI2NF9BTFBIQUJFVC5jaGFyQXQoZTQpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG91dC5qb2luKCcnKTtcbiAgICB9O1xuICB9KHdpbmRvdykpO1xuXG4gIC8vaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vamltZWgvMzMyMzU3XG4gIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSl7XG4gICAgICAvKmpzaGludCAtVzAwMSwgLVcxMDMgKi9cbiAgICAgIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkgPSBmdW5jdGlvbihwcm9wKSB7XG4gICAgICB2YXIgcHJvdG8gPSB0aGlzLl9fcHJvdG9fXyB8fCB0aGlzLmNvbnN0cnVjdG9yLnByb3RvdHlwZTtcbiAgICAgIHJldHVybiAocHJvcCBpbiB0aGlzKSAmJiAoIShwcm9wIGluIHByb3RvKSB8fCBwcm90b1twcm9wXSAhPT0gdGhpc1twcm9wXSk7XG4gICAgfTtcbiAgICAgIC8qanNoaW50ICtXMDAxLCArVzEwMyAqL1xuICB9XG5cbiAgLy8gQGxpY2Vuc2UgaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVFxuICAvLyBjb3B5cmlnaHQgUGF1bCBJcmlzaCAyMDE1XG5cblxuICAvLyBEYXRlLm5vdygpIGlzIHN1cHBvcnRlZCBldmVyeXdoZXJlIGV4Y2VwdCBJRTguIEZvciBJRTggd2UgdXNlIHRoZSBEYXRlLm5vdyBwb2x5ZmlsbFxuICAvLyAgIGdpdGh1Yi5jb20vRmluYW5jaWFsLVRpbWVzL3BvbHlmaWxsLXNlcnZpY2UvYmxvYi9tYXN0ZXIvcG9seWZpbGxzL0RhdGUubm93L3BvbHlmaWxsLmpzXG4gIC8vIGFzIFNhZmFyaSA2IGRvZXNuJ3QgaGF2ZSBzdXBwb3J0IGZvciBOYXZpZ2F0aW9uVGltaW5nLCB3ZSB1c2UgYSBEYXRlLm5vdygpIHRpbWVzdGFtcCBmb3IgcmVsYXRpdmUgdmFsdWVzXG5cbiAgLy8gaWYgeW91IHdhbnQgdmFsdWVzIHNpbWlsYXIgdG8gd2hhdCB5b3UnZCBnZXQgd2l0aCByZWFsIHBlcmYubm93LCBwbGFjZSB0aGlzIHRvd2FyZHMgdGhlIGhlYWQgb2YgdGhlIHBhZ2VcbiAgLy8gYnV0IGluIHJlYWxpdHksIHlvdSdyZSBqdXN0IGdldHRpbmcgdGhlIGRlbHRhIGJldHdlZW4gbm93KCkgY2FsbHMsIHNvIGl0J3Mgbm90IHRlcnJpYmx5IGltcG9ydGFudCB3aGVyZSBpdCdzIHBsYWNlZFxuXG5cbiAgKGZ1bmN0aW9uKCl7XG5cbiAgICBpZiAoJ3BlcmZvcm1hbmNlJyBpbiB3aW5kb3cgPT09IGZhbHNlKSB7XG4gICAgICAgIHdpbmRvdy5wZXJmb3JtYW5jZSA9IHt9O1xuICAgIH1cbiAgICBcbiAgICBEYXRlLm5vdyA9IChEYXRlLm5vdyB8fCBmdW5jdGlvbiAoKSB7ICAvLyB0aGFua3MgSUU4XG4gICAgICByZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgfSk7XG5cbiAgICBpZiAoJ25vdycgaW4gd2luZG93LnBlcmZvcm1hbmNlID09PSBmYWxzZSl7XG4gICAgICBcbiAgICAgIHZhciBub3dPZmZzZXQgPSBEYXRlLm5vdygpO1xuICAgICAgXG4gICAgICBpZiAocGVyZm9ybWFuY2UudGltaW5nICYmIHBlcmZvcm1hbmNlLnRpbWluZy5uYXZpZ2F0aW9uU3RhcnQpe1xuICAgICAgICBub3dPZmZzZXQgPSBwZXJmb3JtYW5jZS50aW1pbmcubmF2aWdhdGlvblN0YXJ0O1xuICAgICAgfVxuXG4gICAgICB3aW5kb3cucGVyZm9ybWFuY2Uubm93ID0gZnVuY3Rpb24gbm93KCl7XG4gICAgICAgIHJldHVybiBEYXRlLm5vdygpIC0gbm93T2Zmc2V0O1xuICAgICAgfTtcbiAgICB9XG5cbiAgfSkoKTtcblxuICAvL3JlcXVlc3RBbmltYXRpb25GcmFtZSBwb2x5ZmlsbCBmb3Igb2xkZXIgRmlyZWZveC9DaHJvbWUgdmVyc2lvbnNcbiAgaWYgKCF3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKSB7XG4gICAgaWYgKHdpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgJiYgd2luZG93LndlYmtpdENhbmNlbEFuaW1hdGlvbkZyYW1lKSB7XG4gICAgLy9odHRwczovL2dpdGh1Yi5jb20vRmluYW5jaWFsLVRpbWVzL3BvbHlmaWxsLXNlcnZpY2UvYmxvYi9tYXN0ZXIvcG9seWZpbGxzL3JlcXVlc3RBbmltYXRpb25GcmFtZS9wb2x5ZmlsbC13ZWJraXQuanNcbiAgICAoZnVuY3Rpb24gKGdsb2JhbCkge1xuICAgICAgZ2xvYmFsLnJlcXVlc3RBbmltYXRpb25GcmFtZSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gd2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBjYWxsYmFjayhnbG9iYWwucGVyZm9ybWFuY2Uubm93KCkpO1xuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIGdsb2JhbC5jYW5jZWxBbmltYXRpb25GcmFtZSA9IGdsb2JhbC53ZWJraXRDYW5jZWxBbmltYXRpb25GcmFtZTtcbiAgICB9KHdpbmRvdykpO1xuICAgIH0gZWxzZSBpZiAod2luZG93Lm1velJlcXVlc3RBbmltYXRpb25GcmFtZSAmJiB3aW5kb3cubW96Q2FuY2VsQW5pbWF0aW9uRnJhbWUpIHtcbiAgICAgIC8vaHR0cHM6Ly9naXRodWIuY29tL0ZpbmFuY2lhbC1UaW1lcy9wb2x5ZmlsbC1zZXJ2aWNlL2Jsb2IvbWFzdGVyL3BvbHlmaWxscy9yZXF1ZXN0QW5pbWF0aW9uRnJhbWUvcG9seWZpbGwtbW96LmpzXG4gICAgKGZ1bmN0aW9uIChnbG9iYWwpIHtcbiAgICAgIGdsb2JhbC5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIG1velJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgY2FsbGJhY2soZ2xvYmFsLnBlcmZvcm1hbmNlLm5vdygpKTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICBnbG9iYWwuY2FuY2VsQW5pbWF0aW9uRnJhbWUgPSBnbG9iYWwubW96Q2FuY2VsQW5pbWF0aW9uRnJhbWU7XG4gICAgfSh3aW5kb3cpKTtcbiAgICB9IGVsc2Uge1xuICAgIChmdW5jdGlvbiAoZ2xvYmFsKSB7XG4gICAgICBnbG9iYWwucmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiBnbG9iYWwuc2V0VGltZW91dChjYWxsYmFjaywgMTAwMCAvIDYwKTtcbiAgICAgIH07XG5cbiAgICAgIGdsb2JhbC5jYW5jZWxBbmltYXRpb25GcmFtZSA9IGdsb2JhbC5jbGVhclRpbWVvdXQ7XG4gICAgfSkod2luZG93KTtcbiAgICB9XG4gIH1cbn0pKHRoaXMpO1xuXG4oZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJIb2xkZXJcIl0gPSBmYWN0b3J5KCk7XG5cdGVsc2Vcblx0XHRyb290W1wiSG9sZGVyXCJdID0gZmFjdG9yeSgpO1xufSkodGhpcywgZnVuY3Rpb24oKSB7XG5yZXR1cm4gLyoqKioqKi8gKGZ1bmN0aW9uKG1vZHVsZXMpIHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pXG4vKioqKioqLyBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcblxuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge30sXG4vKioqKioqLyBcdFx0XHRpZDogbW9kdWxlSWQsXG4vKioqKioqLyBcdFx0XHRsb2FkZWQ6IGZhbHNlXG4vKioqKioqLyBcdFx0fTtcblxuLyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuLyoqKioqKi8gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4vKioqKioqLyBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuLyoqKioqKi8gXHRcdG1vZHVsZS5sb2FkZWQgPSB0cnVlO1xuXG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cblxuXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuLyoqKioqKi8gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG4vKioqKioqLyBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbi8qKioqKiovIH0pXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gKFtcbi8qIDAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQvKlxuXHRIb2xkZXIuanMgLSBjbGllbnQgc2lkZSBpbWFnZSBwbGFjZWhvbGRlcnNcblx0KGMpIDIwMTItMjAyMCBJdmFuIE1hbG9waW5za3kgLSBodHRwczovL2ltc2t5LmNvXG5cdCovXG5cblx0bW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG5cbi8qKiovIH0pLFxuLyogMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdC8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihnbG9iYWwpIHsvKlxuXHRIb2xkZXIuanMgLSBjbGllbnQgc2lkZSBpbWFnZSBwbGFjZWhvbGRlcnNcblx0KGMpIDIwMTItMjAyMCBJdmFuIE1hbG9waW5za3kgLSBodHRwOi8vaW1za3kuY29cblx0Ki9cblxuXHQvL0xpYnJhcmllcyBhbmQgZnVuY3Rpb25zXG5cdHZhciBvbkRvbVJlYWR5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcblx0dmFyIHF1ZXJ5c3RyaW5nID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcblxuXHR2YXIgU2NlbmVHcmFwaCA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XG5cdHZhciB1dGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oNyk7XG5cdHZhciBTVkcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpO1xuXHR2YXIgRE9NID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcblx0dmFyIENvbG9yID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMCk7XG5cdHZhciBjb25zdGFudHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKTtcblxuXHR2YXIgc3ZnUmVuZGVyZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKTtcblx0dmFyIHNnQ2FudmFzUmVuZGVyZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI3KTtcblxuXHR2YXIgZXh0ZW5kID0gdXRpbHMuZXh0ZW5kO1xuXHR2YXIgZGltZW5zaW9uQ2hlY2sgPSB1dGlscy5kaW1lbnNpb25DaGVjaztcblxuXHQvL0NvbnN0YW50cyBhbmQgZGVmaW5pdGlvbnNcblx0dmFyIFNWR19OUyA9IGNvbnN0YW50cy5zdmdfbnM7XG5cblx0dmFyIEhvbGRlciA9IHtcblx0ICAgIHZlcnNpb246IGNvbnN0YW50cy52ZXJzaW9uLFxuXG5cdCAgICAvKipcblx0ICAgICAqIEFkZHMgYSB0aGVtZSB0byBkZWZhdWx0IHNldHRpbmdzXG5cdCAgICAgKlxuXHQgICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlbWUgbmFtZVxuXHQgICAgICogQHBhcmFtIHtPYmplY3R9IHRoZW1lIFRoZW1lIG9iamVjdCwgd2l0aCBmb3JlZ3JvdW5kLCBiYWNrZ3JvdW5kLCBzaXplLCBmb250LCBhbmQgZm9udHdlaWdodCBwcm9wZXJ0aWVzLlxuXHQgICAgICovXG5cdCAgICBhZGRUaGVtZTogZnVuY3Rpb24obmFtZSwgdGhlbWUpIHtcblx0ICAgICAgICBuYW1lICE9IG51bGwgJiYgdGhlbWUgIT0gbnVsbCAmJiAoQXBwLnNldHRpbmdzLnRoZW1lc1tuYW1lXSA9IHRoZW1lKTtcblx0ICAgICAgICBkZWxldGUgQXBwLnZhcnMuY2FjaGUudGhlbWVLZXlzO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfSxcblxuXHQgICAgLyoqXG5cdCAgICAgKiBBcHBlbmRzIGEgcGxhY2Vob2xkZXIgdG8gYW4gZWxlbWVudFxuXHQgICAgICpcblx0ICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzcmMgUGxhY2Vob2xkZXIgVVJMIHN0cmluZ1xuXHQgICAgICogQHBhcmFtIGVsIEEgc2VsZWN0b3Igb3IgYSByZWZlcmVuY2UgdG8gYSBET00gbm9kZVxuXHQgICAgICovXG5cdCAgICBhZGRJbWFnZTogZnVuY3Rpb24oc3JjLCBlbCkge1xuXHQgICAgICAgIC8vdG9kbzogdXNlIGpxdWVyeSBmYWxsYmFjayBpZiBhdmFpbGFibGUgZm9yIGFsbCBRU0EgcmVmZXJlbmNlc1xuXHQgICAgICAgIHZhciBub2RlcyA9IERPTS5nZXROb2RlQXJyYXkoZWwpO1xuXHQgICAgICAgIG5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcblx0ICAgICAgICAgICAgdmFyIGltZyA9IERPTS5uZXdFbCgnaW1nJyk7XG5cdCAgICAgICAgICAgIHZhciBkb21Qcm9wcyA9IHt9O1xuXHQgICAgICAgICAgICBkb21Qcm9wc1tBcHAuc2V0dXAuZGF0YUF0dHJdID0gc3JjO1xuXHQgICAgICAgICAgICBET00uc2V0QXR0cihpbWcsIGRvbVByb3BzKTtcblx0ICAgICAgICAgICAgbm9kZS5hcHBlbmRDaGlsZChpbWcpO1xuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfSxcblxuXHQgICAgLyoqXG5cdCAgICAgKiBTZXRzIHdoZXRoZXIgb3Igbm90IGFuIGltYWdlIGlzIHVwZGF0ZWQgb24gcmVzaXplLlxuXHQgICAgICogSWYgYW4gaW1hZ2UgaXMgc2V0IHRvIGJlIHVwZGF0ZWQsIGl0IGlzIGltbWVkaWF0ZWx5IHJlbmRlcmVkLlxuXHQgICAgICpcblx0ICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlbCBJbWFnZSBET00gZWxlbWVudFxuXHQgICAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZSBSZXNpemFibGUgdXBkYXRlIGZsYWcgdmFsdWVcblx0ICAgICAqL1xuXHQgICAgc2V0UmVzaXplVXBkYXRlOiBmdW5jdGlvbihlbCwgdmFsdWUpIHtcblx0ICAgICAgICBpZiAoZWwuaG9sZGVyRGF0YSkge1xuXHQgICAgICAgICAgICBlbC5ob2xkZXJEYXRhLnJlc2l6ZVVwZGF0ZSA9ICEhdmFsdWU7XG5cdCAgICAgICAgICAgIGlmIChlbC5ob2xkZXJEYXRhLnJlc2l6ZVVwZGF0ZSkge1xuXHQgICAgICAgICAgICAgICAgdXBkYXRlUmVzaXphYmxlRWxlbWVudHMoZWwpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfSxcblxuXHQgICAgLyoqXG5cdCAgICAgKiBSdW5zIEhvbGRlciB3aXRoIG9wdGlvbnMuIEJ5IGRlZmF1bHQgcnVucyBIb2xkZXIgb24gYWxsIGltYWdlcyB3aXRoIFwiaG9sZGVyLmpzXCIgaW4gdGhlaXIgc291cmNlIGF0dHJpYnV0ZXMuXG5cdCAgICAgKlxuXHQgICAgICogQHBhcmFtIHtPYmplY3R9IHVzZXJPcHRpb25zIE9wdGlvbnMgb2JqZWN0LCBjYW4gY29udGFpbiBkb21haW4sIHRoZW1lcywgaW1hZ2VzLCBhbmQgYmdub2RlcyBwcm9wZXJ0aWVzXG5cdCAgICAgKi9cblx0ICAgIHJ1bjogZnVuY3Rpb24odXNlck9wdGlvbnMpIHtcblx0ICAgICAgICAvL3RvZG86IHNwbGl0IHByb2Nlc3NpbmcgaW50byBzZXBhcmF0ZSBxdWV1ZXNcblx0ICAgICAgICB1c2VyT3B0aW9ucyA9IHVzZXJPcHRpb25zIHx8IHt9O1xuXHQgICAgICAgIHZhciBlbmdpbmVTZXR0aW5ncyA9IHt9O1xuXHQgICAgICAgIHZhciBvcHRpb25zID0gZXh0ZW5kKEFwcC5zZXR0aW5ncywgdXNlck9wdGlvbnMpO1xuXG5cdCAgICAgICAgQXBwLnZhcnMucHJlZW1wdGVkID0gdHJ1ZTtcblx0ICAgICAgICBBcHAudmFycy5kYXRhQXR0ciA9IG9wdGlvbnMuZGF0YUF0dHIgfHwgQXBwLnNldHVwLmRhdGFBdHRyO1xuXG5cdCAgICAgICAgZW5naW5lU2V0dGluZ3MucmVuZGVyZXIgPSBvcHRpb25zLnJlbmRlcmVyID8gb3B0aW9ucy5yZW5kZXJlciA6IEFwcC5zZXR1cC5yZW5kZXJlcjtcblx0ICAgICAgICBpZiAoQXBwLnNldHVwLnJlbmRlcmVycy5qb2luKCcsJykuaW5kZXhPZihlbmdpbmVTZXR0aW5ncy5yZW5kZXJlcikgPT09IC0xKSB7XG5cdCAgICAgICAgICAgIGVuZ2luZVNldHRpbmdzLnJlbmRlcmVyID0gQXBwLnNldHVwLnN1cHBvcnRzU1ZHID8gJ3N2ZycgOiAoQXBwLnNldHVwLnN1cHBvcnRzQ2FudmFzID8gJ2NhbnZhcycgOiAnaHRtbCcpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHZhciBpbWFnZXMgPSBET00uZ2V0Tm9kZUFycmF5KG9wdGlvbnMuaW1hZ2VzKTtcblx0ICAgICAgICB2YXIgYmdub2RlcyA9IERPTS5nZXROb2RlQXJyYXkob3B0aW9ucy5iZ25vZGVzKTtcblx0ICAgICAgICB2YXIgc3R5bGVub2RlcyA9IERPTS5nZXROb2RlQXJyYXkob3B0aW9ucy5zdHlsZW5vZGVzKTtcblx0ICAgICAgICB2YXIgb2JqZWN0cyA9IERPTS5nZXROb2RlQXJyYXkob3B0aW9ucy5vYmplY3RzKTtcblxuXHQgICAgICAgIGVuZ2luZVNldHRpbmdzLnN0eWxlc2hlZXRzID0gW107XG5cdCAgICAgICAgZW5naW5lU2V0dGluZ3Muc3ZnWE1MU3R5bGVzaGVldCA9IHRydWU7XG5cdCAgICAgICAgZW5naW5lU2V0dGluZ3Mubm9Gb250RmFsbGJhY2sgPSAhIW9wdGlvbnMubm9Gb250RmFsbGJhY2s7XG5cdCAgICAgICAgZW5naW5lU2V0dGluZ3Mubm9CYWNrZ3JvdW5kU2l6ZSA9ICEhb3B0aW9ucy5ub0JhY2tncm91bmRTaXplO1xuXG5cdCAgICAgICAgc3R5bGVub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChzdHlsZU5vZGUpIHtcblx0ICAgICAgICAgICAgaWYgKHN0eWxlTm9kZS5hdHRyaWJ1dGVzLnJlbCAmJiBzdHlsZU5vZGUuYXR0cmlidXRlcy5ocmVmICYmIHN0eWxlTm9kZS5hdHRyaWJ1dGVzLnJlbC52YWx1ZSA9PSAnc3R5bGVzaGVldCcpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBocmVmID0gc3R5bGVOb2RlLmF0dHJpYnV0ZXMuaHJlZi52YWx1ZTtcblx0ICAgICAgICAgICAgICAgIC8vdG9kbzogd3JpdGUgaXNvbW9ycGhpYyByZWxhdGl2ZS10by1hYnNvbHV0ZSBVUkwgZnVuY3Rpb25cblx0ICAgICAgICAgICAgICAgIHZhciBwcm94eUxpbmsgPSBET00ubmV3RWwoJ2EnKTtcblx0ICAgICAgICAgICAgICAgIHByb3h5TGluay5ocmVmID0gaHJlZjtcblx0ICAgICAgICAgICAgICAgIHZhciBzdHlsZXNoZWV0VVJMID0gcHJveHlMaW5rLnByb3RvY29sICsgJy8vJyArIHByb3h5TGluay5ob3N0ICsgcHJveHlMaW5rLnBhdGhuYW1lICsgcHJveHlMaW5rLnNlYXJjaDtcblx0ICAgICAgICAgICAgICAgIGVuZ2luZVNldHRpbmdzLnN0eWxlc2hlZXRzLnB1c2goc3R5bGVzaGVldFVSTCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9KTtcblxuXHQgICAgICAgIGJnbm9kZXMuZm9yRWFjaChmdW5jdGlvbiAoYmdOb2RlKSB7XG5cdCAgICAgICAgICAgIC8vU2tpcCBwcm9jZXNzaW5nIGJhY2tncm91bmQgbm9kZXMgaWYgZ2V0Q29tcHV0ZWRTdHlsZSBpcyB1bmF2YWlsYWJsZSwgc2luY2Ugb25seSBtb2Rlcm4gYnJvd3NlcnMgd291bGQgYmUgYWJsZSB0byB1c2UgY2FudmFzIG9yIFNWRyB0byByZW5kZXIgdG8gYmFja2dyb3VuZFxuXHQgICAgICAgICAgICBpZiAoIWdsb2JhbC5nZXRDb21wdXRlZFN0eWxlKSByZXR1cm47XG5cdCAgICAgICAgICAgIHZhciBiYWNrZ3JvdW5kSW1hZ2UgPSBnbG9iYWwuZ2V0Q29tcHV0ZWRTdHlsZShiZ05vZGUsIG51bGwpLmdldFByb3BlcnR5VmFsdWUoJ2JhY2tncm91bmQtaW1hZ2UnKTtcblx0ICAgICAgICAgICAgdmFyIGRhdGFCYWNrZ3JvdW5kSW1hZ2UgPSBiZ05vZGUuZ2V0QXR0cmlidXRlKCdkYXRhLWJhY2tncm91bmQtc3JjJyk7XG5cdCAgICAgICAgICAgIHZhciByYXdVUkwgPSBkYXRhQmFja2dyb3VuZEltYWdlIHx8IGJhY2tncm91bmRJbWFnZTtcblxuXHQgICAgICAgICAgICB2YXIgaG9sZGVyVVJMID0gbnVsbDtcblx0ICAgICAgICAgICAgdmFyIGhvbGRlclN0cmluZyA9IG9wdGlvbnMuZG9tYWluICsgJy8nO1xuXHQgICAgICAgICAgICB2YXIgaG9sZGVyU3RyaW5nSW5kZXggPSByYXdVUkwuaW5kZXhPZihob2xkZXJTdHJpbmcpO1xuXG5cdCAgICAgICAgICAgIGlmIChob2xkZXJTdHJpbmdJbmRleCA9PT0gMCkge1xuXHQgICAgICAgICAgICAgICAgaG9sZGVyVVJMID0gcmF3VVJMO1xuXHQgICAgICAgICAgICB9IGVsc2UgaWYgKGhvbGRlclN0cmluZ0luZGV4ID09PSAxICYmIHJhd1VSTFswXSA9PT0gJz8nKSB7XG5cdCAgICAgICAgICAgICAgICBob2xkZXJVUkwgPSByYXdVUkwuc2xpY2UoMSk7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgZnJhZ21lbnQgPSByYXdVUkwuc3Vic3RyKGhvbGRlclN0cmluZ0luZGV4KS5tYXRjaCgvKFteXCJdKilcIj9cXCkvKTtcblx0ICAgICAgICAgICAgICAgIGlmIChmcmFnbWVudCAhPT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGhvbGRlclVSTCA9IGZyYWdtZW50WzFdO1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChyYXdVUkwuaW5kZXhPZigndXJsKCcpID09PSAwKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhyb3cgJ0hvbGRlcjogdW5hYmxlIHRvIHBhcnNlIGJhY2tncm91bmQgVVJMOiAnICsgcmF3VVJMO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgaWYgKGhvbGRlclVSTCkge1xuXHQgICAgICAgICAgICAgICAgdmFyIGhvbGRlckZsYWdzID0gcGFyc2VVUkwoaG9sZGVyVVJMLCBvcHRpb25zKTtcblx0ICAgICAgICAgICAgICAgIGlmIChob2xkZXJGbGFncykge1xuXHQgICAgICAgICAgICAgICAgICAgIHByZXBhcmVET01FbGVtZW50KHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbW9kZTogJ2JhY2tncm91bmQnLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICBlbDogYmdOb2RlLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICBmbGFnczogaG9sZGVyRmxhZ3MsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGVuZ2luZVNldHRpbmdzOiBlbmdpbmVTZXR0aW5nc1xuXHQgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSk7XG5cblx0ICAgICAgICBvYmplY3RzLmZvckVhY2goZnVuY3Rpb24gKG9iamVjdCkge1xuXHQgICAgICAgICAgICB2YXIgb2JqZWN0QXR0ciA9IHt9O1xuXG5cdCAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICBvYmplY3RBdHRyLmRhdGEgPSBvYmplY3QuZ2V0QXR0cmlidXRlKCdkYXRhJyk7XG5cdCAgICAgICAgICAgICAgICBvYmplY3RBdHRyLmRhdGFTcmMgPSBvYmplY3QuZ2V0QXR0cmlidXRlKEFwcC52YXJzLmRhdGFBdHRyKTtcblx0ICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuXHQgICAgICAgICAgICAgIG9iamVjdEF0dHIuZXJyb3IgPSBlO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgdmFyIG9iamVjdEhhc1NyY1VSTCA9IG9iamVjdEF0dHIuZGF0YSAhPSBudWxsICYmIG9iamVjdEF0dHIuZGF0YS5pbmRleE9mKG9wdGlvbnMuZG9tYWluKSA9PT0gMDtcblx0ICAgICAgICAgICAgdmFyIG9iamVjdEhhc0RhdGFTcmNVUkwgPSBvYmplY3RBdHRyLmRhdGFTcmMgIT0gbnVsbCAmJiBvYmplY3RBdHRyLmRhdGFTcmMuaW5kZXhPZihvcHRpb25zLmRvbWFpbikgPT09IDA7XG5cblx0ICAgICAgICAgICAgaWYgKG9iamVjdEhhc1NyY1VSTCkge1xuXHQgICAgICAgICAgICAgICAgcHJlcGFyZUltYWdlRWxlbWVudChvcHRpb25zLCBlbmdpbmVTZXR0aW5ncywgb2JqZWN0QXR0ci5kYXRhLCBvYmplY3QpO1xuXHQgICAgICAgICAgICB9IGVsc2UgaWYgKG9iamVjdEhhc0RhdGFTcmNVUkwpIHtcblx0ICAgICAgICAgICAgICAgIHByZXBhcmVJbWFnZUVsZW1lbnQob3B0aW9ucywgZW5naW5lU2V0dGluZ3MsIG9iamVjdEF0dHIuZGF0YVNyYywgb2JqZWN0KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0pO1xuXG5cdCAgICAgICAgaW1hZ2VzLmZvckVhY2goZnVuY3Rpb24gKGltYWdlKSB7XG5cdCAgICAgICAgICAgIHZhciBpbWFnZUF0dHIgPSB7fTtcblxuXHQgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgaW1hZ2VBdHRyLnNyYyA9IGltYWdlLmdldEF0dHJpYnV0ZSgnc3JjJyk7XG5cdCAgICAgICAgICAgICAgICBpbWFnZUF0dHIuZGF0YVNyYyA9IGltYWdlLmdldEF0dHJpYnV0ZShBcHAudmFycy5kYXRhQXR0cik7XG5cdCAgICAgICAgICAgICAgICBpbWFnZUF0dHIucmVuZGVyZWQgPSBpbWFnZS5nZXRBdHRyaWJ1dGUoJ2RhdGEtaG9sZGVyLXJlbmRlcmVkJyk7XG5cdCAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcblx0ICAgICAgICAgICAgICBpbWFnZUF0dHIuZXJyb3IgPSBlO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgdmFyIGltYWdlSGFzU3JjID0gaW1hZ2VBdHRyLnNyYyAhPSBudWxsO1xuXHQgICAgICAgICAgICB2YXIgaW1hZ2VIYXNEYXRhU3JjVVJMID0gaW1hZ2VBdHRyLmRhdGFTcmMgIT0gbnVsbCAmJiBpbWFnZUF0dHIuZGF0YVNyYy5pbmRleE9mKG9wdGlvbnMuZG9tYWluKSA9PT0gMDtcblx0ICAgICAgICAgICAgdmFyIGltYWdlUmVuZGVyZWQgPSBpbWFnZUF0dHIucmVuZGVyZWQgIT0gbnVsbCAmJiBpbWFnZUF0dHIucmVuZGVyZWQgPT0gJ3RydWUnO1xuXG5cdCAgICAgICAgICAgIGlmIChpbWFnZUhhc1NyYykge1xuXHQgICAgICAgICAgICAgICAgaWYgKGltYWdlQXR0ci5zcmMuaW5kZXhPZihvcHRpb25zLmRvbWFpbikgPT09IDApIHtcblx0ICAgICAgICAgICAgICAgICAgICBwcmVwYXJlSW1hZ2VFbGVtZW50KG9wdGlvbnMsIGVuZ2luZVNldHRpbmdzLCBpbWFnZUF0dHIuc3JjLCBpbWFnZSk7XG5cdCAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGltYWdlSGFzRGF0YVNyY1VSTCkge1xuXHQgICAgICAgICAgICAgICAgICAgIC8vSW1hZ2UgaGFzIGEgdmFsaWQgZGF0YS1zcmMgYW5kIGFuIGludmFsaWQgc3JjXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGltYWdlUmVuZGVyZWQpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy9JZiB0aGUgcGxhY2Vob2xkZXIgaGFzIGFscmVhZHkgYmVlbiByZW5kZXIsIHJlLXJlbmRlciBpdFxuXHQgICAgICAgICAgICAgICAgICAgICAgICBwcmVwYXJlSW1hZ2VFbGVtZW50KG9wdGlvbnMsIGVuZ2luZVNldHRpbmdzLCBpbWFnZUF0dHIuZGF0YVNyYywgaW1hZ2UpO1xuXHQgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vSWYgdGhlIHBsYWNlaG9sZGVyIGhhcyBub3QgYmVlbiByZW5kZXJlZCwgY2hlY2sgaWYgdGhlIGltYWdlIGV4aXN0cyBhbmQgcmVuZGVyIGEgZmFsbGJhY2sgaWYgaXQgZG9lc24ndFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAoZnVuY3Rpb24oc3JjLCBvcHRpb25zLCBlbmdpbmVTZXR0aW5ncywgZGF0YVNyYywgaW1hZ2UpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHV0aWxzLmltYWdlRXhpc3RzKHNyYywgZnVuY3Rpb24oZXhpc3RzKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFleGlzdHMpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJlcGFyZUltYWdlRWxlbWVudChvcHRpb25zLCBlbmdpbmVTZXR0aW5ncywgZGF0YVNyYywgaW1hZ2UpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KShpbWFnZUF0dHIuc3JjLCBvcHRpb25zLCBlbmdpbmVTZXR0aW5ncywgaW1hZ2VBdHRyLmRhdGFTcmMsIGltYWdlKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0gZWxzZSBpZiAoaW1hZ2VIYXNEYXRhU3JjVVJMKSB7XG5cdCAgICAgICAgICAgICAgICBwcmVwYXJlSW1hZ2VFbGVtZW50KG9wdGlvbnMsIGVuZ2luZVNldHRpbmdzLCBpbWFnZUF0dHIuZGF0YVNyYywgaW1hZ2UpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSk7XG5cblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH1cblx0fTtcblxuXHR2YXIgQXBwID0ge1xuXHQgICAgc2V0dGluZ3M6IHtcblx0ICAgICAgICBkb21haW46ICdob2xkZXIuanMnLFxuXHQgICAgICAgIGltYWdlczogJ2ltZycsXG5cdCAgICAgICAgb2JqZWN0czogJ29iamVjdCcsXG5cdCAgICAgICAgYmdub2RlczogJ2JvZHkgLmhvbGRlcmpzJyxcblx0ICAgICAgICBzdHlsZW5vZGVzOiAnaGVhZCBsaW5rLmhvbGRlcmpzJyxcblx0ICAgICAgICB0aGVtZXM6IHtcblx0ICAgICAgICAgICAgJ2dyYXknOiB7XG5cdCAgICAgICAgICAgICAgICBiZzogJyNFRUVFRUUnLFxuXHQgICAgICAgICAgICAgICAgZmc6ICcjQUFBQUFBJ1xuXHQgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICAnc29jaWFsJzoge1xuXHQgICAgICAgICAgICAgICAgYmc6ICcjM2E1YTk3Jyxcblx0ICAgICAgICAgICAgICAgIGZnOiAnI0ZGRkZGRidcblx0ICAgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgJ2luZHVzdHJpYWwnOiB7XG5cdCAgICAgICAgICAgICAgICBiZzogJyM0MzRBNTInLFxuXHQgICAgICAgICAgICAgICAgZmc6ICcjQzJGMjAwJ1xuXHQgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICAnc2t5Jzoge1xuXHQgICAgICAgICAgICAgICAgYmc6ICcjMEQ4RkRCJyxcblx0ICAgICAgICAgICAgICAgIGZnOiAnI0ZGRkZGRidcblx0ICAgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgJ3ZpbmUnOiB7XG5cdCAgICAgICAgICAgICAgICBiZzogJyMzOURCQUMnLFxuXHQgICAgICAgICAgICAgICAgZmc6ICcjMUUyOTJDJ1xuXHQgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICAnbGF2YSc6IHtcblx0ICAgICAgICAgICAgICAgIGJnOiAnI0Y4NTkxQScsXG5cdCAgICAgICAgICAgICAgICBmZzogJyMxQzI4NDYnXG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9LFxuXHQgICAgZGVmYXVsdHM6IHtcblx0ICAgICAgICBzaXplOiAxMCxcblx0ICAgICAgICB1bml0czogJ3B0Jyxcblx0ICAgICAgICBzY2FsZTogMSAvIDE2XG5cdCAgICB9XG5cdH07XG5cblx0LyoqXG5cdCAqIFByb2Nlc3NlcyBwcm92aWRlZCBzb3VyY2UgYXR0cmlidXRlIGFuZCBzZXRzIHVwIHRoZSBhcHByb3ByaWF0ZSByZW5kZXJpbmcgd29ya2Zsb3dcblx0ICpcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIG9wdGlvbnMgSW5zdGFuY2Ugb3B0aW9ucyBmcm9tIEhvbGRlci5ydW5cblx0ICogQHBhcmFtIHJlbmRlclNldHRpbmdzIEluc3RhbmNlIGNvbmZpZ3VyYXRpb25cblx0ICogQHBhcmFtIHNyYyBJbWFnZSBVUkxcblx0ICogQHBhcmFtIGVsIEltYWdlIERPTSBlbGVtZW50XG5cdCAqL1xuXHRmdW5jdGlvbiBwcmVwYXJlSW1hZ2VFbGVtZW50KG9wdGlvbnMsIGVuZ2luZVNldHRpbmdzLCBzcmMsIGVsKSB7XG5cdCAgICB2YXIgaG9sZGVyRmxhZ3MgPSBwYXJzZVVSTChzcmMuc3Vic3RyKHNyYy5sYXN0SW5kZXhPZihvcHRpb25zLmRvbWFpbikpLCBvcHRpb25zKTtcblx0ICAgIGlmIChob2xkZXJGbGFncykge1xuXHQgICAgICAgIHByZXBhcmVET01FbGVtZW50KHtcblx0ICAgICAgICAgICAgbW9kZTogbnVsbCxcblx0ICAgICAgICAgICAgZWw6IGVsLFxuXHQgICAgICAgICAgICBmbGFnczogaG9sZGVyRmxhZ3MsXG5cdCAgICAgICAgICAgIGVuZ2luZVNldHRpbmdzOiBlbmdpbmVTZXR0aW5nc1xuXHQgICAgICAgIH0pO1xuXHQgICAgfVxuXHR9XG5cblx0LyoqXG5cdCAqIFByb2Nlc3NlcyBhIEhvbGRlciBVUkwgYW5kIGV4dHJhY3RzIGNvbmZpZ3VyYXRpb24gZnJvbSBxdWVyeSBzdHJpbmdcblx0ICpcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHVybCBVUkxcblx0ICogQHBhcmFtIGluc3RhbmNlT3B0aW9ucyBJbnN0YW5jZSBvcHRpb25zIGZyb20gSG9sZGVyLnJ1blxuXHQgKi9cblx0ZnVuY3Rpb24gcGFyc2VVUkwodXJsLCBpbnN0YW5jZU9wdGlvbnMpIHtcblx0ICAgIHZhciBob2xkZXIgPSB7XG5cdCAgICAgICAgdGhlbWU6IGV4dGVuZChBcHAuc2V0dGluZ3MudGhlbWVzLmdyYXksIG51bGwpLFxuXHQgICAgICAgIHN0eWxlc2hlZXRzOiBpbnN0YW5jZU9wdGlvbnMuc3R5bGVzaGVldHMsXG5cdCAgICAgICAgaW5zdGFuY2VPcHRpb25zOiBpbnN0YW5jZU9wdGlvbnNcblx0ICAgIH07XG5cblx0ICAgIHZhciBmaXJzdFF1ZXN0aW9uTWFyayA9IHVybC5pbmRleE9mKCc/Jyk7XG5cdCAgICB2YXIgcGFydHMgPSBbdXJsXTtcblxuXHQgICAgaWYgKGZpcnN0UXVlc3Rpb25NYXJrICE9PSAtMSkge1xuXHQgICAgICAgIHBhcnRzID0gW3VybC5zbGljZSgwLCBmaXJzdFF1ZXN0aW9uTWFyayksIHVybC5zbGljZShmaXJzdFF1ZXN0aW9uTWFyayArIDEpXTtcblx0ICAgIH1cblxuXHQgICAgdmFyIGJhc2ljcyA9IHBhcnRzWzBdLnNwbGl0KCcvJyk7XG5cblx0ICAgIGhvbGRlci5ob2xkZXJVUkwgPSB1cmw7XG5cblx0ICAgIHZhciBkaW1lbnNpb25zID0gYmFzaWNzWzFdO1xuXHQgICAgdmFyIGRpbWVuc2lvbkRhdGEgPSBkaW1lbnNpb25zLm1hdGNoKC8oW1xcZF0rcD8peChbXFxkXStwPykvKTtcblxuXHQgICAgaWYgKCFkaW1lbnNpb25EYXRhKSByZXR1cm4gZmFsc2U7XG5cblx0ICAgIGhvbGRlci5mbHVpZCA9IGRpbWVuc2lvbnMuaW5kZXhPZigncCcpICE9PSAtMTtcblxuXHQgICAgaG9sZGVyLmRpbWVuc2lvbnMgPSB7XG5cdCAgICAgICAgd2lkdGg6IGRpbWVuc2lvbkRhdGFbMV0ucmVwbGFjZSgncCcsICclJyksXG5cdCAgICAgICAgaGVpZ2h0OiBkaW1lbnNpb25EYXRhWzJdLnJlcGxhY2UoJ3AnLCAnJScpXG5cdCAgICB9O1xuXG5cdCAgICBpZiAocGFydHMubGVuZ3RoID09PSAyKSB7XG5cdCAgICAgICAgdmFyIG9wdGlvbnMgPSBxdWVyeXN0cmluZy5wYXJzZShwYXJ0c1sxXSk7XG5cblx0ICAgICAgICAvLyBEaW1lbnNpb25zXG5cblx0ICAgICAgICBpZiAodXRpbHMudHJ1dGh5KG9wdGlvbnMucmF0aW8pKSB7XG5cdCAgICAgICAgICAgIGhvbGRlci5mbHVpZCA9IHRydWU7XG5cdCAgICAgICAgICAgIHZhciByYXRpb1dpZHRoID0gcGFyc2VGbG9hdChob2xkZXIuZGltZW5zaW9ucy53aWR0aC5yZXBsYWNlKCclJywgJycpKTtcblx0ICAgICAgICAgICAgdmFyIHJhdGlvSGVpZ2h0ID0gcGFyc2VGbG9hdChob2xkZXIuZGltZW5zaW9ucy5oZWlnaHQucmVwbGFjZSgnJScsICcnKSk7XG5cblx0ICAgICAgICAgICAgcmF0aW9IZWlnaHQgPSBNYXRoLmZsb29yKDEwMCAqIChyYXRpb0hlaWdodCAvIHJhdGlvV2lkdGgpKTtcblx0ICAgICAgICAgICAgcmF0aW9XaWR0aCA9IDEwMDtcblxuXHQgICAgICAgICAgICBob2xkZXIuZGltZW5zaW9ucy53aWR0aCA9IHJhdGlvV2lkdGggKyAnJSc7XG5cdCAgICAgICAgICAgIGhvbGRlci5kaW1lbnNpb25zLmhlaWdodCA9IHJhdGlvSGVpZ2h0ICsgJyUnO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGhvbGRlci5hdXRvID0gdXRpbHMudHJ1dGh5KG9wdGlvbnMuYXV0byk7XG5cblx0ICAgICAgICAvLyBDb2xvcnNcblxuXHQgICAgICAgIGlmIChvcHRpb25zLmJnKSB7XG5cdCAgICAgICAgICAgIGhvbGRlci50aGVtZS5iZyA9IHV0aWxzLnBhcnNlQ29sb3Iob3B0aW9ucy5iZyk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgaWYgKG9wdGlvbnMuZmcpIHtcblx0ICAgICAgICAgICAgaG9sZGVyLnRoZW1lLmZnID0gdXRpbHMucGFyc2VDb2xvcihvcHRpb25zLmZnKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICAvL3RvZG86IGFkZCBhdXRvbWF0aWMgZm9yZWdyb3VuZCB0byB0aGVtZXMgd2l0aG91dCBmb3JlZ3JvdW5kXG5cdCAgICAgICAgaWYgKG9wdGlvbnMuYmcgJiYgIW9wdGlvbnMuZmcpIHtcblx0ICAgICAgICAgICAgaG9sZGVyLmF1dG9GZyA9IHRydWU7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgaWYgKG9wdGlvbnMudGhlbWUgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGhvbGRlci5pbnN0YW5jZU9wdGlvbnMudGhlbWVzLCBvcHRpb25zLnRoZW1lKSkge1xuXHQgICAgICAgICAgICBob2xkZXIudGhlbWUgPSBleHRlbmQoaG9sZGVyLmluc3RhbmNlT3B0aW9ucy50aGVtZXNbb3B0aW9ucy50aGVtZV0sIG51bGwpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIC8vIFRleHRcblxuXHQgICAgICAgIGlmIChvcHRpb25zLnRleHQpIHtcblx0ICAgICAgICAgICAgaG9sZGVyLnRleHQgPSBvcHRpb25zLnRleHQ7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgaWYgKG9wdGlvbnMudGV4dG1vZGUpIHtcblx0ICAgICAgICAgICAgaG9sZGVyLnRleHRtb2RlID0gb3B0aW9ucy50ZXh0bW9kZTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBpZiAob3B0aW9ucy5zaXplICYmIHBhcnNlRmxvYXQob3B0aW9ucy5zaXplKSkge1xuXHQgICAgICAgICAgICBob2xkZXIuc2l6ZSA9IHBhcnNlRmxvYXQob3B0aW9ucy5zaXplKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBpZiAob3B0aW9ucy5maXhlZFNpemUgIT0gbnVsbCkge1xuXHQgICAgICAgICAgICBob2xkZXIuZml4ZWRTaXplID0gdXRpbHMudHJ1dGh5KG9wdGlvbnMuZml4ZWRTaXplKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBpZiAob3B0aW9ucy5mb250KSB7XG5cdCAgICAgICAgICAgIGhvbGRlci5mb250ID0gb3B0aW9ucy5mb250O1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGlmIChvcHRpb25zLmFsaWduKSB7XG5cdCAgICAgICAgICAgIGhvbGRlci5hbGlnbiA9IG9wdGlvbnMuYWxpZ247XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgaWYgKG9wdGlvbnMubGluZVdyYXApIHtcblx0ICAgICAgICAgICAgaG9sZGVyLmxpbmVXcmFwID0gb3B0aW9ucy5saW5lV3JhcDtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBob2xkZXIubm93cmFwID0gdXRpbHMudHJ1dGh5KG9wdGlvbnMubm93cmFwKTtcblxuXHQgICAgICAgIC8vIE1pc2NlbGxhbmVvdXNcblxuXHQgICAgICAgIGhvbGRlci5vdXRsaW5lID0gdXRpbHMudHJ1dGh5KG9wdGlvbnMub3V0bGluZSk7XG5cblx0ICAgICAgICBpZiAodXRpbHMudHJ1dGh5KG9wdGlvbnMucmFuZG9tKSkge1xuXHQgICAgICAgICAgICBBcHAudmFycy5jYWNoZS50aGVtZUtleXMgPSBBcHAudmFycy5jYWNoZS50aGVtZUtleXMgfHwgT2JqZWN0LmtleXMoaG9sZGVyLmluc3RhbmNlT3B0aW9ucy50aGVtZXMpO1xuXHQgICAgICAgICAgICB2YXIgX3RoZW1lID0gQXBwLnZhcnMuY2FjaGUudGhlbWVLZXlzWzAgfCBNYXRoLnJhbmRvbSgpICogQXBwLnZhcnMuY2FjaGUudGhlbWVLZXlzLmxlbmd0aF07XG5cdCAgICAgICAgICAgIGhvbGRlci50aGVtZSA9IGV4dGVuZChob2xkZXIuaW5zdGFuY2VPcHRpb25zLnRoZW1lc1tfdGhlbWVdLCBudWxsKTtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBob2xkZXI7XG5cdH1cblxuXHQvKipcblx0ICogTW9kaWZpZXMgdGhlIERPTSB0byBmaXQgcGxhY2Vob2xkZXJzIGFuZCBzZXRzIHVwIHJlc2l6YWJsZSBpbWFnZSBjYWxsYmFja3MgKGZvciBmbHVpZCBhbmQgYXV0b21hdGljYWxseSBzaXplZCBwbGFjZWhvbGRlcnMpXG5cdCAqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSBzZXR0aW5ncyBET00gcHJlcCBzZXR0aW5nc1xuXHQgKi9cblx0ZnVuY3Rpb24gcHJlcGFyZURPTUVsZW1lbnQocHJlcFNldHRpbmdzKSB7XG5cdCAgICB2YXIgbW9kZSA9IHByZXBTZXR0aW5ncy5tb2RlO1xuXHQgICAgdmFyIGVsID0gcHJlcFNldHRpbmdzLmVsO1xuXHQgICAgdmFyIGZsYWdzID0gcHJlcFNldHRpbmdzLmZsYWdzO1xuXHQgICAgdmFyIF9lbmdpbmVTZXR0aW5ncyA9IHByZXBTZXR0aW5ncy5lbmdpbmVTZXR0aW5ncztcblx0ICAgIHZhciBkaW1lbnNpb25zID0gZmxhZ3MuZGltZW5zaW9ucyxcblx0ICAgICAgICB0aGVtZSA9IGZsYWdzLnRoZW1lO1xuXHQgICAgdmFyIGRpbWVuc2lvbnNDYXB0aW9uID0gZGltZW5zaW9ucy53aWR0aCArICd4JyArIGRpbWVuc2lvbnMuaGVpZ2h0O1xuXHQgICAgbW9kZSA9IG1vZGUgPT0gbnVsbCA/IChmbGFncy5mbHVpZCA/ICdmbHVpZCcgOiAnaW1hZ2UnKSA6IG1vZGU7XG5cdCAgICB2YXIgaG9sZGVyVGVtcGxhdGVSZSA9IC9ob2xkZXJfKFthLXpdKykvZztcblx0ICAgIHZhciBkaW1lbnNpb25zSW5UZXh0ID0gZmFsc2U7XG5cblx0ICAgIGlmIChmbGFncy50ZXh0ICE9IG51bGwpIHtcblx0ICAgICAgICB0aGVtZS50ZXh0ID0gZmxhZ3MudGV4dDtcblxuXHQgICAgICAgIC8vPG9iamVjdD4gU1ZHIGVtYmVkZGluZyBkb2Vzbid0IHBhcnNlIFVuaWNvZGUgcHJvcGVybHlcblx0ICAgICAgICBpZiAoZWwubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ29iamVjdCcpIHtcblx0ICAgICAgICAgICAgdmFyIHRleHRMaW5lcyA9IHRoZW1lLnRleHQuc3BsaXQoJ1xcXFxuJyk7XG5cdCAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgdGV4dExpbmVzLmxlbmd0aDsgaysrKSB7XG5cdCAgICAgICAgICAgICAgICB0ZXh0TGluZXNba10gPSB1dGlscy5lbmNvZGVIdG1sRW50aXR5KHRleHRMaW5lc1trXSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdGhlbWUudGV4dCA9IHRleHRMaW5lcy5qb2luKCdcXFxcbicpO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgaWYgKHRoZW1lLnRleHQpIHtcblx0ICAgICAgICB2YXIgaG9sZGVyVGVtcGxhdGVNYXRjaGVzID0gdGhlbWUudGV4dC5tYXRjaChob2xkZXJUZW1wbGF0ZVJlKTtcblxuXHQgICAgICAgIGlmIChob2xkZXJUZW1wbGF0ZU1hdGNoZXMgIT09IG51bGwpIHtcblx0ICAgICAgICAgICAgLy90b2RvOiBvcHRpbWl6ZSB0ZW1wbGF0ZSByZXBsYWNlbWVudFxuXHQgICAgICAgICAgICBob2xkZXJUZW1wbGF0ZU1hdGNoZXMuZm9yRWFjaChmdW5jdGlvbiAobWF0Y2gpIHtcblx0ICAgICAgICAgICAgICAgIGlmIChtYXRjaCA9PT0gJ2hvbGRlcl9kaW1lbnNpb25zJykge1xuXHQgICAgICAgICAgICAgICAgICAgIHRoZW1lLnRleHQgPSB0aGVtZS50ZXh0LnJlcGxhY2UobWF0Y2gsIGRpbWVuc2lvbnNDYXB0aW9uKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICB2YXIgaG9sZGVyVVJMID0gZmxhZ3MuaG9sZGVyVVJMO1xuXHQgICAgdmFyIGVuZ2luZVNldHRpbmdzID0gZXh0ZW5kKF9lbmdpbmVTZXR0aW5ncywgbnVsbCk7XG5cblx0ICAgIGlmIChmbGFncy5mb250KSB7XG5cdCAgICAgICAgLypcblx0ICAgICAgICBJZiBleHRlcm5hbCBmb250cyBhcmUgdXNlZCBpbiBhIDxpbWc+IHBsYWNlaG9sZGVyIHJlbmRlcmVkIHdpdGggU1ZHLCBIb2xkZXIgZmFsbHMgYmFjayB0byBjYW52YXMuXG5cblx0ICAgICAgICBUaGlzIGlzIGRvbmUgYmVjYXVzZSBGaXJlZm94IGFuZCBDaHJvbWUgZGlzYWxsb3cgZW1iZWRkZWQgU1ZHcyBmcm9tIHJlZmVyZW5jaW5nIGV4dGVybmFsIGFzc2V0cy5cblx0ICAgICAgICBUaGUgd29ya2Fyb3VuZCBpcyBlaXRoZXIgdG8gY2hhbmdlIHRoZSBwbGFjZWhvbGRlciB0YWcgZnJvbSA8aW1nPiB0byA8b2JqZWN0PiBvciB0byB1c2UgdGhlIGNhbnZhcyByZW5kZXJlci5cblx0ICAgICAgICAqL1xuXHQgICAgICAgIHRoZW1lLmZvbnQgPSBmbGFncy5mb250O1xuXHQgICAgICAgIGlmICghZW5naW5lU2V0dGluZ3Mubm9Gb250RmFsbGJhY2sgJiYgZWwubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2ltZycgJiYgQXBwLnNldHVwLnN1cHBvcnRzQ2FudmFzICYmIGVuZ2luZVNldHRpbmdzLnJlbmRlcmVyID09PSAnc3ZnJykge1xuXHQgICAgICAgICAgICBlbmdpbmVTZXR0aW5ncyA9IGV4dGVuZChlbmdpbmVTZXR0aW5ncywge1xuXHQgICAgICAgICAgICAgICAgcmVuZGVyZXI6ICdjYW52YXMnXG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgLy9DaHJvbWUgYW5kIE9wZXJhIHJlcXVpcmUgYSBxdWljayAxMG1zIHJlLXJlbmRlciBpZiB3ZWIgZm9udHMgYXJlIHVzZWQgd2l0aCBjYW52YXNcblx0ICAgIGlmIChmbGFncy5mb250ICYmIGVuZ2luZVNldHRpbmdzLnJlbmRlcmVyID09ICdjYW52YXMnKSB7XG5cdCAgICAgICAgZW5naW5lU2V0dGluZ3MucmVSZW5kZXIgPSB0cnVlO1xuXHQgICAgfVxuXG5cdCAgICBpZiAobW9kZSA9PSAnYmFja2dyb3VuZCcpIHtcblx0ICAgICAgICBpZiAoZWwuZ2V0QXR0cmlidXRlKCdkYXRhLWJhY2tncm91bmQtc3JjJykgPT0gbnVsbCkge1xuXHQgICAgICAgICAgICBET00uc2V0QXR0cihlbCwge1xuXHQgICAgICAgICAgICAgICAgJ2RhdGEtYmFja2dyb3VuZC1zcmMnOiBob2xkZXJVUkxcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgICB2YXIgZG9tUHJvcHMgPSB7fTtcblx0ICAgICAgICBkb21Qcm9wc1tBcHAudmFycy5kYXRhQXR0cl0gPSBob2xkZXJVUkw7XG5cdCAgICAgICAgRE9NLnNldEF0dHIoZWwsIGRvbVByb3BzKTtcblx0ICAgIH1cblxuXHQgICAgZmxhZ3MudGhlbWUgPSB0aGVtZTtcblxuXHQgICAgLy90b2RvIGNvbnNpZGVyIHVzaW5nIGFsbCByZW5kZXJTZXR0aW5ncyBpbiBob2xkZXJEYXRhXG5cdCAgICBlbC5ob2xkZXJEYXRhID0ge1xuXHQgICAgICAgIGZsYWdzOiBmbGFncyxcblx0ICAgICAgICBlbmdpbmVTZXR0aW5nczogZW5naW5lU2V0dGluZ3Ncblx0ICAgIH07XG5cblx0ICAgIGlmIChtb2RlID09ICdpbWFnZScgfHwgbW9kZSA9PSAnZmx1aWQnKSB7XG5cdCAgICAgICAgRE9NLnNldEF0dHIoZWwsIHtcblx0ICAgICAgICAgICAgJ2FsdCc6IHRoZW1lLnRleHQgPyAoZGltZW5zaW9uc0luVGV4dCA/IHRoZW1lLnRleHQgOiB0aGVtZS50ZXh0ICsgJyBbJyArIGRpbWVuc2lvbnNDYXB0aW9uICsgJ10nKSA6IGRpbWVuc2lvbnNDYXB0aW9uXG5cdCAgICAgICAgfSk7XG5cdCAgICB9XG5cblx0ICAgIHZhciByZW5kZXJTZXR0aW5ncyA9IHtcblx0ICAgICAgICBtb2RlOiBtb2RlLFxuXHQgICAgICAgIGVsOiBlbCxcblx0ICAgICAgICBob2xkZXJTZXR0aW5nczoge1xuXHQgICAgICAgICAgICBkaW1lbnNpb25zOiBkaW1lbnNpb25zLFxuXHQgICAgICAgICAgICB0aGVtZTogdGhlbWUsXG5cdCAgICAgICAgICAgIGZsYWdzOiBmbGFnc1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgZW5naW5lU2V0dGluZ3M6IGVuZ2luZVNldHRpbmdzXG5cdCAgICB9O1xuXG5cdCAgICBpZiAobW9kZSA9PSAnaW1hZ2UnKSB7XG5cdCAgICAgICAgaWYgKCFmbGFncy5hdXRvKSB7XG5cdCAgICAgICAgICAgIGVsLnN0eWxlLndpZHRoID0gZGltZW5zaW9ucy53aWR0aCArICdweCc7XG5cdCAgICAgICAgICAgIGVsLnN0eWxlLmhlaWdodCA9IGRpbWVuc2lvbnMuaGVpZ2h0ICsgJ3B4Jztcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBpZiAoZW5naW5lU2V0dGluZ3MucmVuZGVyZXIgPT0gJ2h0bWwnKSB7XG5cdCAgICAgICAgICAgIGVsLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IHRoZW1lLmJnO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIHJlbmRlcihyZW5kZXJTZXR0aW5ncyk7XG5cblx0ICAgICAgICAgICAgaWYgKGZsYWdzLnRleHRtb2RlID09ICdleGFjdCcpIHtcblx0ICAgICAgICAgICAgICAgIGVsLmhvbGRlckRhdGEucmVzaXplVXBkYXRlID0gdHJ1ZTtcblx0ICAgICAgICAgICAgICAgIEFwcC52YXJzLnJlc2l6YWJsZUltYWdlcy5wdXNoKGVsKTtcblx0ICAgICAgICAgICAgICAgIHVwZGF0ZVJlc2l6YWJsZUVsZW1lbnRzKGVsKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH0gZWxzZSBpZiAobW9kZSA9PSAnYmFja2dyb3VuZCcgJiYgZW5naW5lU2V0dGluZ3MucmVuZGVyZXIgIT0gJ2h0bWwnKSB7XG5cdCAgICAgICAgcmVuZGVyKHJlbmRlclNldHRpbmdzKTtcblx0ICAgIH0gZWxzZSBpZiAobW9kZSA9PSAnZmx1aWQnKSB7XG5cdCAgICAgICAgZWwuaG9sZGVyRGF0YS5yZXNpemVVcGRhdGUgPSB0cnVlO1xuXG5cdCAgICAgICAgaWYgKGRpbWVuc2lvbnMuaGVpZ2h0LnNsaWNlKC0xKSA9PSAnJScpIHtcblx0ICAgICAgICAgICAgZWwuc3R5bGUuaGVpZ2h0ID0gZGltZW5zaW9ucy5oZWlnaHQ7XG5cdCAgICAgICAgfSBlbHNlIGlmIChmbGFncy5hdXRvID09IG51bGwgfHwgIWZsYWdzLmF1dG8pIHtcblx0ICAgICAgICAgICAgZWwuc3R5bGUuaGVpZ2h0ID0gZGltZW5zaW9ucy5oZWlnaHQgKyAncHgnO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAoZGltZW5zaW9ucy53aWR0aC5zbGljZSgtMSkgPT0gJyUnKSB7XG5cdCAgICAgICAgICAgIGVsLnN0eWxlLndpZHRoID0gZGltZW5zaW9ucy53aWR0aDtcblx0ICAgICAgICB9IGVsc2UgaWYgKGZsYWdzLmF1dG8gPT0gbnVsbCB8fCAhZmxhZ3MuYXV0bykge1xuXHQgICAgICAgICAgICBlbC5zdHlsZS53aWR0aCA9IGRpbWVuc2lvbnMud2lkdGggKyAncHgnO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAoZWwuc3R5bGUuZGlzcGxheSA9PSAnaW5saW5lJyB8fCBlbC5zdHlsZS5kaXNwbGF5ID09PSAnJyB8fCBlbC5zdHlsZS5kaXNwbGF5ID09ICdub25lJykge1xuXHQgICAgICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBzZXRJbml0aWFsRGltZW5zaW9ucyhlbCk7XG5cblx0ICAgICAgICBpZiAoZW5naW5lU2V0dGluZ3MucmVuZGVyZXIgPT0gJ2h0bWwnKSB7XG5cdCAgICAgICAgICAgIGVsLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IHRoZW1lLmJnO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIEFwcC52YXJzLnJlc2l6YWJsZUltYWdlcy5wdXNoKGVsKTtcblx0ICAgICAgICAgICAgdXBkYXRlUmVzaXphYmxlRWxlbWVudHMoZWwpO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblx0fVxuXG5cdC8qKlxuXHQgKiBDb3JlIGZ1bmN0aW9uIHRoYXQgdGFrZXMgb3V0cHV0IGZyb20gcmVuZGVyZXJzIGFuZCBzZXRzIGl0IGFzIHRoZSBzb3VyY2Ugb3IgYmFja2dyb3VuZC1pbWFnZSBvZiB0aGUgdGFyZ2V0IGVsZW1lbnRcblx0ICpcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHJlbmRlclNldHRpbmdzIFJlbmRlcmVyIHNldHRpbmdzXG5cdCAqL1xuXHRmdW5jdGlvbiByZW5kZXIocmVuZGVyU2V0dGluZ3MpIHtcblx0ICAgIHZhciBpbWFnZSA9IG51bGw7XG5cdCAgICB2YXIgbW9kZSA9IHJlbmRlclNldHRpbmdzLm1vZGU7XG5cdCAgICB2YXIgZWwgPSByZW5kZXJTZXR0aW5ncy5lbDtcblx0ICAgIHZhciBob2xkZXJTZXR0aW5ncyA9IHJlbmRlclNldHRpbmdzLmhvbGRlclNldHRpbmdzO1xuXHQgICAgdmFyIGVuZ2luZVNldHRpbmdzID0gcmVuZGVyU2V0dGluZ3MuZW5naW5lU2V0dGluZ3M7XG5cblx0ICAgIHN3aXRjaCAoZW5naW5lU2V0dGluZ3MucmVuZGVyZXIpIHtcblx0ICAgICAgICBjYXNlICdzdmcnOlxuXHQgICAgICAgICAgICBpZiAoIUFwcC5zZXR1cC5zdXBwb3J0c1NWRykgcmV0dXJuO1xuXHQgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICBjYXNlICdjYW52YXMnOlxuXHQgICAgICAgICAgICBpZiAoIUFwcC5zZXR1cC5zdXBwb3J0c0NhbnZhcykgcmV0dXJuO1xuXHQgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICBkZWZhdWx0OlxuXHQgICAgICAgICAgICByZXR1cm47XG5cdCAgICB9XG5cblx0ICAgIC8vdG9kbzogbW92ZSBnZW5lcmF0aW9uIG9mIHNjZW5lIHVwIHRvIGZsYWcgZ2VuZXJhdGlvbiB0byByZWR1Y2UgZXh0cmEgb2JqZWN0IGNyZWF0aW9uXG5cdCAgICB2YXIgc2NlbmUgPSB7XG5cdCAgICAgICAgd2lkdGg6IGhvbGRlclNldHRpbmdzLmRpbWVuc2lvbnMud2lkdGgsXG5cdCAgICAgICAgaGVpZ2h0OiBob2xkZXJTZXR0aW5ncy5kaW1lbnNpb25zLmhlaWdodCxcblx0ICAgICAgICB0aGVtZTogaG9sZGVyU2V0dGluZ3MudGhlbWUsXG5cdCAgICAgICAgZmxhZ3M6IGhvbGRlclNldHRpbmdzLmZsYWdzXG5cdCAgICB9O1xuXG5cdCAgICB2YXIgc2NlbmVHcmFwaCA9IGJ1aWxkU2NlbmVHcmFwaChzY2VuZSk7XG5cblx0ICAgIGZ1bmN0aW9uIGdldFJlbmRlcmVkSW1hZ2UoKSB7XG5cdCAgICAgICAgdmFyIGltYWdlID0gbnVsbDtcblx0ICAgICAgICBzd2l0Y2ggKGVuZ2luZVNldHRpbmdzLnJlbmRlcmVyKSB7XG5cdCAgICAgICAgICAgIGNhc2UgJ2NhbnZhcyc6XG5cdCAgICAgICAgICAgICAgICBpbWFnZSA9IHNnQ2FudmFzUmVuZGVyZXIoc2NlbmVHcmFwaCwgcmVuZGVyU2V0dGluZ3MpO1xuXHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgIGNhc2UgJ3N2Zyc6XG5cdCAgICAgICAgICAgICAgICBpbWFnZSA9IHN2Z1JlbmRlcmVyKHNjZW5lR3JhcGgsIHJlbmRlclNldHRpbmdzKTtcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICBkZWZhdWx0OlxuXHQgICAgICAgICAgICAgICAgdGhyb3cgJ0hvbGRlcjogaW52YWxpZCByZW5kZXJlcjogJyArIGVuZ2luZVNldHRpbmdzLnJlbmRlcmVyO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHJldHVybiBpbWFnZTtcblx0ICAgIH1cblxuXHQgICAgaW1hZ2UgPSBnZXRSZW5kZXJlZEltYWdlKCk7XG5cblx0ICAgIGlmIChpbWFnZSA9PSBudWxsKSB7XG5cdCAgICAgICAgdGhyb3cgJ0hvbGRlcjogY291bGRuXFwndCByZW5kZXIgcGxhY2Vob2xkZXInO1xuXHQgICAgfVxuXG5cdCAgICAvL3RvZG86IGFkZCA8b2JqZWN0PiBjYW52YXMgcmVuZGVyaW5nXG5cdCAgICBpZiAobW9kZSA9PSAnYmFja2dyb3VuZCcpIHtcblx0ICAgICAgICBlbC5zdHlsZS5iYWNrZ3JvdW5kSW1hZ2UgPSAndXJsKCcgKyBpbWFnZSArICcpJztcblxuXHQgICAgICAgIGlmICghZW5naW5lU2V0dGluZ3Mubm9CYWNrZ3JvdW5kU2l6ZSkge1xuXHQgICAgICAgICAgICBlbC5zdHlsZS5iYWNrZ3JvdW5kU2l6ZSA9IHNjZW5lLndpZHRoICsgJ3B4ICcgKyBzY2VuZS5oZWlnaHQgKyAncHgnO1xuXHQgICAgICAgIH1cblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgICAgaWYgKGVsLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdpbWcnKSB7XG5cdCAgICAgICAgICAgIERPTS5zZXRBdHRyKGVsLCB7XG5cdCAgICAgICAgICAgICAgICAnc3JjJzogaW1hZ2Vcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfSBlbHNlIGlmIChlbC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnb2JqZWN0Jykge1xuXHQgICAgICAgICAgICBET00uc2V0QXR0cihlbCwge1xuXHQgICAgICAgICAgICAgICAgJ2RhdGEnOiBpbWFnZSxcblx0ICAgICAgICAgICAgICAgICd0eXBlJzogJ2ltYWdlL3N2Zyt4bWwnXG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAoZW5naW5lU2V0dGluZ3MucmVSZW5kZXIpIHtcblx0ICAgICAgICAgICAgZ2xvYmFsLnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgdmFyIGltYWdlID0gZ2V0UmVuZGVyZWRJbWFnZSgpO1xuXHQgICAgICAgICAgICAgICAgaWYgKGltYWdlID09IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgICAgICB0aHJvdyAnSG9sZGVyOiBjb3VsZG5cXCd0IHJlbmRlciBwbGFjZWhvbGRlcic7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAvL3RvZG86IHJlZmFjdG9yIHRoaXMgY29kZSBpbnRvIGEgZnVuY3Rpb25cblx0ICAgICAgICAgICAgICAgIGlmIChlbC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnaW1nJykge1xuXHQgICAgICAgICAgICAgICAgICAgIERPTS5zZXRBdHRyKGVsLCB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICdzcmMnOiBpbWFnZVxuXHQgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChlbC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnb2JqZWN0Jykge1xuXHQgICAgICAgICAgICAgICAgICAgIERPTS5zZXRBdHRyKGVsLCB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICdkYXRhJzogaW1hZ2UsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICd0eXBlJzogJ2ltYWdlL3N2Zyt4bWwnXG5cdCAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0sIDE1MCk7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHQgICAgLy90b2RvOiBhY2NvdW50IGZvciByZS1yZW5kZXJpbmdcblx0ICAgIERPTS5zZXRBdHRyKGVsLCB7XG5cdCAgICAgICAgJ2RhdGEtaG9sZGVyLXJlbmRlcmVkJzogdHJ1ZVxuXHQgICAgfSk7XG5cdH1cblxuXHQvKipcblx0ICogQ29yZSBmdW5jdGlvbiB0aGF0IHRha2VzIGEgSG9sZGVyIHNjZW5lIGRlc2NyaXB0aW9uIGFuZCBidWlsZHMgYSBzY2VuZSBncmFwaFxuXHQgKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0gc2NlbmUgSG9sZGVyIHNjZW5lIG9iamVjdFxuXHQgKi9cblx0Ly90b2RvOiBtYWtlIHRoaXMgZnVuY3Rpb24gcmV1c2FibGVcblx0Ly90b2RvOiBtZXJnZSBhcHAgZGVmYXVsdHMgYW5kIHNldHVwIHByb3BlcnRpZXMgaW50byB0aGUgc2NlbmUgYXJndW1lbnRcblx0ZnVuY3Rpb24gYnVpbGRTY2VuZUdyYXBoKHNjZW5lKSB7XG5cdCAgICB2YXIgZm9udFNpemUgPSBBcHAuZGVmYXVsdHMuc2l6ZTtcblx0ICAgIHZhciBmaXhlZFNpemUgPSBzY2VuZS5mbGFncy5maXhlZFNpemUgIT0gbnVsbCA/IHNjZW5lLmZsYWdzLmZpeGVkU2l6ZSA6IHNjZW5lLnRoZW1lLmZpeGVkU2l6ZTtcblx0ICAgIGlmIChwYXJzZUZsb2F0KHNjZW5lLnRoZW1lLnNpemUpKSB7XG5cdCAgICAgICAgZm9udFNpemUgPSBzY2VuZS50aGVtZS5zaXplO1xuXHQgICAgfSBlbHNlIGlmIChwYXJzZUZsb2F0KHNjZW5lLmZsYWdzLnNpemUpKSB7XG5cdCAgICAgICAgZm9udFNpemUgPSBzY2VuZS5mbGFncy5zaXplO1xuXHQgICAgfVxuXG5cdCAgICBzY2VuZS5mb250ID0ge1xuXHQgICAgICAgIGZhbWlseTogc2NlbmUudGhlbWUuZm9udCA/IHNjZW5lLnRoZW1lLmZvbnQgOiAnQXJpYWwsIEhlbHZldGljYSwgT3BlbiBTYW5zLCBzYW5zLXNlcmlmJyxcblx0ICAgICAgICBzaXplOiBmaXhlZFNpemUgPyBmb250U2l6ZSA6IHRleHRTaXplKHNjZW5lLndpZHRoLCBzY2VuZS5oZWlnaHQsIGZvbnRTaXplLCBBcHAuZGVmYXVsdHMuc2NhbGUpLFxuXHQgICAgICAgIHVuaXRzOiBzY2VuZS50aGVtZS51bml0cyA/IHNjZW5lLnRoZW1lLnVuaXRzIDogQXBwLmRlZmF1bHRzLnVuaXRzLFxuXHQgICAgICAgIHdlaWdodDogc2NlbmUudGhlbWUuZm9udHdlaWdodCA/IHNjZW5lLnRoZW1lLmZvbnR3ZWlnaHQgOiAnYm9sZCdcblx0ICAgIH07XG5cblx0ICAgIHNjZW5lLnRleHQgPSBzY2VuZS50aGVtZS50ZXh0IHx8IE1hdGguZmxvb3Ioc2NlbmUud2lkdGgpICsgJ3gnICsgTWF0aC5mbG9vcihzY2VuZS5oZWlnaHQpO1xuXG5cdCAgICBzY2VuZS5ub1dyYXAgPSBzY2VuZS50aGVtZS5ub3dyYXAgfHwgc2NlbmUuZmxhZ3Mubm93cmFwO1xuXG5cdCAgICBzY2VuZS5hbGlnbiA9IHNjZW5lLnRoZW1lLmFsaWduIHx8IHNjZW5lLmZsYWdzLmFsaWduIHx8ICdjZW50ZXInO1xuXG5cdCAgICBzd2l0Y2ggKHNjZW5lLmZsYWdzLnRleHRtb2RlKSB7XG5cdCAgICAgICAgY2FzZSAnbGl0ZXJhbCc6XG5cdCAgICAgICAgICAgIHNjZW5lLnRleHQgPSBzY2VuZS5mbGFncy5kaW1lbnNpb25zLndpZHRoICsgJ3gnICsgc2NlbmUuZmxhZ3MuZGltZW5zaW9ucy5oZWlnaHQ7XG5cdCAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgIGNhc2UgJ2V4YWN0Jzpcblx0ICAgICAgICAgICAgaWYgKCFzY2VuZS5mbGFncy5leGFjdERpbWVuc2lvbnMpIGJyZWFrO1xuXHQgICAgICAgICAgICBzY2VuZS50ZXh0ID0gTWF0aC5mbG9vcihzY2VuZS5mbGFncy5leGFjdERpbWVuc2lvbnMud2lkdGgpICsgJ3gnICsgTWF0aC5mbG9vcihzY2VuZS5mbGFncy5leGFjdERpbWVuc2lvbnMuaGVpZ2h0KTtcblx0ICAgICAgICAgICAgYnJlYWs7XG5cdCAgICB9XG5cblx0ICAgIHZhciBsaW5lV3JhcCA9IHNjZW5lLmZsYWdzLmxpbmVXcmFwIHx8IEFwcC5zZXR1cC5saW5lV3JhcFJhdGlvO1xuXHQgICAgdmFyIHNjZW5lTWFyZ2luID0gc2NlbmUud2lkdGggKiBsaW5lV3JhcDtcblx0ICAgIHZhciBtYXhMaW5lV2lkdGggPSBzY2VuZU1hcmdpbjtcblxuXHQgICAgdmFyIHNjZW5lR3JhcGggPSBuZXcgU2NlbmVHcmFwaCh7XG5cdCAgICAgICAgd2lkdGg6IHNjZW5lLndpZHRoLFxuXHQgICAgICAgIGhlaWdodDogc2NlbmUuaGVpZ2h0XG5cdCAgICB9KTtcblxuXHQgICAgdmFyIFNoYXBlID0gc2NlbmVHcmFwaC5TaGFwZTtcblxuXHQgICAgdmFyIGhvbGRlckJnID0gbmV3IFNoYXBlLlJlY3QoJ2hvbGRlckJnJywge1xuXHQgICAgICAgIGZpbGw6IHNjZW5lLnRoZW1lLmJnXG5cdCAgICB9KTtcblxuXHQgICAgaG9sZGVyQmcucmVzaXplKHNjZW5lLndpZHRoLCBzY2VuZS5oZWlnaHQpO1xuXHQgICAgc2NlbmVHcmFwaC5yb290LmFkZChob2xkZXJCZyk7XG5cblx0ICAgIGlmIChzY2VuZS5mbGFncy5vdXRsaW5lKSB7XG5cdCAgICAgICAgdmFyIG91dGxpbmVDb2xvciA9IG5ldyBDb2xvcihob2xkZXJCZy5wcm9wZXJ0aWVzLmZpbGwpO1xuXHQgICAgICAgIG91dGxpbmVDb2xvciA9IG91dGxpbmVDb2xvci5saWdodGVuKG91dGxpbmVDb2xvci5saWdodGVyVGhhbignN2Y3ZjdmJykgPyAtMC4xIDogMC4xKTtcblx0ICAgICAgICBob2xkZXJCZy5wcm9wZXJ0aWVzLm91dGxpbmUgPSB7XG5cdCAgICAgICAgICAgIGZpbGw6IG91dGxpbmVDb2xvci50b0hleCh0cnVlKSxcblx0ICAgICAgICAgICAgd2lkdGg6IDJcblx0ICAgICAgICB9O1xuXHQgICAgfVxuXG5cdCAgICB2YXIgaG9sZGVyVGV4dENvbG9yID0gc2NlbmUudGhlbWUuZmc7XG5cblx0ICAgIGlmIChzY2VuZS5mbGFncy5hdXRvRmcpIHtcblx0ICAgICAgICB2YXIgaG9sZGVyQmdDb2xvciA9IG5ldyBDb2xvcihob2xkZXJCZy5wcm9wZXJ0aWVzLmZpbGwpO1xuXHQgICAgICAgIHZhciBsaWdodENvbG9yID0gbmV3IENvbG9yKCdmZmYnKTtcblx0ICAgICAgICB2YXIgZGFya0NvbG9yID0gbmV3IENvbG9yKCcwMDAnLCB7XG5cdCAgICAgICAgICAgICdhbHBoYSc6IDAuMjg1NzE0XG5cdCAgICAgICAgfSk7XG5cblx0ICAgICAgICBob2xkZXJUZXh0Q29sb3IgPSBob2xkZXJCZ0NvbG9yLmJsZW5kQWxwaGEoaG9sZGVyQmdDb2xvci5saWdodGVyVGhhbignN2Y3ZjdmJykgPyBkYXJrQ29sb3IgOiBsaWdodENvbG9yKS50b0hleCh0cnVlKTtcblx0ICAgIH1cblxuXHQgICAgdmFyIGhvbGRlclRleHRHcm91cCA9IG5ldyBTaGFwZS5Hcm91cCgnaG9sZGVyVGV4dEdyb3VwJywge1xuXHQgICAgICAgIHRleHQ6IHNjZW5lLnRleHQsXG5cdCAgICAgICAgYWxpZ246IHNjZW5lLmFsaWduLFxuXHQgICAgICAgIGZvbnQ6IHNjZW5lLmZvbnQsXG5cdCAgICAgICAgZmlsbDogaG9sZGVyVGV4dENvbG9yXG5cdCAgICB9KTtcblxuXHQgICAgaG9sZGVyVGV4dEdyb3VwLm1vdmVUbyhudWxsLCBudWxsLCAxKTtcblx0ICAgIHNjZW5lR3JhcGgucm9vdC5hZGQoaG9sZGVyVGV4dEdyb3VwKTtcblxuXHQgICAgdmFyIHRwZGF0YSA9IGhvbGRlclRleHRHcm91cC50ZXh0UG9zaXRpb25EYXRhID0gc3RhZ2luZ1JlbmRlcmVyKHNjZW5lR3JhcGgpO1xuXHQgICAgaWYgKCF0cGRhdGEpIHtcblx0ICAgICAgICB0aHJvdyAnSG9sZGVyOiBzdGFnaW5nIGZhbGxiYWNrIG5vdCBzdXBwb3J0ZWQgeWV0Lic7XG5cdCAgICB9XG5cdCAgICBob2xkZXJUZXh0R3JvdXAucHJvcGVydGllcy5sZWFkaW5nID0gdHBkYXRhLmJvdW5kaW5nQm94LmhlaWdodDtcblxuXHQgICAgdmFyIHRleHROb2RlID0gbnVsbDtcblx0ICAgIHZhciBsaW5lID0gbnVsbDtcblxuXHQgICAgZnVuY3Rpb24gZmluYWxpemVMaW5lKHBhcmVudCwgbGluZSwgd2lkdGgsIGhlaWdodCkge1xuXHQgICAgICAgIGxpbmUud2lkdGggPSB3aWR0aDtcblx0ICAgICAgICBsaW5lLmhlaWdodCA9IGhlaWdodDtcblx0ICAgICAgICBwYXJlbnQud2lkdGggPSBNYXRoLm1heChwYXJlbnQud2lkdGgsIGxpbmUud2lkdGgpO1xuXHQgICAgICAgIHBhcmVudC5oZWlnaHQgKz0gbGluZS5oZWlnaHQ7XG5cdCAgICB9XG5cblx0ICAgIGlmICh0cGRhdGEubGluZUNvdW50ID4gMSkge1xuXHQgICAgICAgIHZhciBvZmZzZXRYID0gMDtcblx0ICAgICAgICB2YXIgb2Zmc2V0WSA9IDA7XG5cdCAgICAgICAgdmFyIGxpbmVJbmRleCA9IDA7XG5cdCAgICAgICAgdmFyIGxpbmVLZXk7XG5cdCAgICAgICAgbGluZSA9IG5ldyBTaGFwZS5Hcm91cCgnbGluZScgKyBsaW5lSW5kZXgpO1xuXG5cdCAgICAgICAgLy9Eb3VibGUgbWFyZ2luIHNvIHRoYXQgbGVmdC9yaWdodC1hbGlnbmVkIG5leHQgaXMgbm90IGZsdXNoIHdpdGggZWRnZSBvZiBpbWFnZVxuXHQgICAgICAgIGlmIChzY2VuZS5hbGlnbiA9PT0gJ2xlZnQnIHx8IHNjZW5lLmFsaWduID09PSAncmlnaHQnKSB7XG5cdCAgICAgICAgICAgIG1heExpbmVXaWR0aCA9IHNjZW5lLndpZHRoICogKDEgLSAoMSAtIGxpbmVXcmFwKSAqIDIpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHBkYXRhLndvcmRzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgIHZhciB3b3JkID0gdHBkYXRhLndvcmRzW2ldO1xuXHQgICAgICAgICAgICB0ZXh0Tm9kZSA9IG5ldyBTaGFwZS5UZXh0KHdvcmQudGV4dCk7XG5cdCAgICAgICAgICAgIHZhciBuZXdsaW5lID0gd29yZC50ZXh0ID09ICdcXFxcbic7XG5cdCAgICAgICAgICAgIGlmICghc2NlbmUubm9XcmFwICYmIChvZmZzZXRYICsgd29yZC53aWR0aCA+PSBtYXhMaW5lV2lkdGggfHwgbmV3bGluZSA9PT0gdHJ1ZSkpIHtcblx0ICAgICAgICAgICAgICAgIGZpbmFsaXplTGluZShob2xkZXJUZXh0R3JvdXAsIGxpbmUsIG9mZnNldFgsIGhvbGRlclRleHRHcm91cC5wcm9wZXJ0aWVzLmxlYWRpbmcpO1xuXHQgICAgICAgICAgICAgICAgaG9sZGVyVGV4dEdyb3VwLmFkZChsaW5lKTtcblx0ICAgICAgICAgICAgICAgIG9mZnNldFggPSAwO1xuXHQgICAgICAgICAgICAgICAgb2Zmc2V0WSArPSBob2xkZXJUZXh0R3JvdXAucHJvcGVydGllcy5sZWFkaW5nO1xuXHQgICAgICAgICAgICAgICAgbGluZUluZGV4ICs9IDE7XG5cdCAgICAgICAgICAgICAgICBsaW5lID0gbmV3IFNoYXBlLkdyb3VwKCdsaW5lJyArIGxpbmVJbmRleCk7XG5cdCAgICAgICAgICAgICAgICBsaW5lLnkgPSBvZmZzZXRZO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGlmIChuZXdsaW5lID09PSB0cnVlKSB7XG5cdCAgICAgICAgICAgICAgICBjb250aW51ZTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB0ZXh0Tm9kZS5tb3ZlVG8ob2Zmc2V0WCwgMCk7XG5cdCAgICAgICAgICAgIG9mZnNldFggKz0gdHBkYXRhLnNwYWNlV2lkdGggKyB3b3JkLndpZHRoO1xuXHQgICAgICAgICAgICBsaW5lLmFkZCh0ZXh0Tm9kZSk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgZmluYWxpemVMaW5lKGhvbGRlclRleHRHcm91cCwgbGluZSwgb2Zmc2V0WCwgaG9sZGVyVGV4dEdyb3VwLnByb3BlcnRpZXMubGVhZGluZyk7XG5cdCAgICAgICAgaG9sZGVyVGV4dEdyb3VwLmFkZChsaW5lKTtcblxuXHQgICAgICAgIGlmIChzY2VuZS5hbGlnbiA9PT0gJ2xlZnQnKSB7XG5cdCAgICAgICAgICAgIGhvbGRlclRleHRHcm91cC5tb3ZlVG8oc2NlbmUud2lkdGggLSBzY2VuZU1hcmdpbiwgbnVsbCwgbnVsbCk7XG5cdCAgICAgICAgfSBlbHNlIGlmIChzY2VuZS5hbGlnbiA9PT0gJ3JpZ2h0Jykge1xuXHQgICAgICAgICAgICBmb3IgKGxpbmVLZXkgaW4gaG9sZGVyVGV4dEdyb3VwLmNoaWxkcmVuKSB7XG5cdCAgICAgICAgICAgICAgICBsaW5lID0gaG9sZGVyVGV4dEdyb3VwLmNoaWxkcmVuW2xpbmVLZXldO1xuXHQgICAgICAgICAgICAgICAgbGluZS5tb3ZlVG8oc2NlbmUud2lkdGggLSBsaW5lLndpZHRoLCBudWxsLCBudWxsKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIGhvbGRlclRleHRHcm91cC5tb3ZlVG8oMCAtIChzY2VuZS53aWR0aCAtIHNjZW5lTWFyZ2luKSwgbnVsbCwgbnVsbCk7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgZm9yIChsaW5lS2V5IGluIGhvbGRlclRleHRHcm91cC5jaGlsZHJlbikge1xuXHQgICAgICAgICAgICAgICAgbGluZSA9IGhvbGRlclRleHRHcm91cC5jaGlsZHJlbltsaW5lS2V5XTtcblx0ICAgICAgICAgICAgICAgIGxpbmUubW92ZVRvKChob2xkZXJUZXh0R3JvdXAud2lkdGggLSBsaW5lLndpZHRoKSAvIDIsIG51bGwsIG51bGwpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgaG9sZGVyVGV4dEdyb3VwLm1vdmVUbygoc2NlbmUud2lkdGggLSBob2xkZXJUZXh0R3JvdXAud2lkdGgpIC8gMiwgbnVsbCwgbnVsbCk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgaG9sZGVyVGV4dEdyb3VwLm1vdmVUbyhudWxsLCAoc2NlbmUuaGVpZ2h0IC0gaG9sZGVyVGV4dEdyb3VwLmhlaWdodCkgLyAyLCBudWxsKTtcblxuXHQgICAgICAgIC8vSWYgdGhlIHRleHQgZXhjZWVkcyB2ZXJ0aWNhbCBzcGFjZSwgbW92ZSBpdCBkb3duIHNvIHRoZSBmaXJzdCBsaW5lIGlzIHZpc2libGVcblx0ICAgICAgICBpZiAoKHNjZW5lLmhlaWdodCAtIGhvbGRlclRleHRHcm91cC5oZWlnaHQpIC8gMiA8IDApIHtcblx0ICAgICAgICAgICAgaG9sZGVyVGV4dEdyb3VwLm1vdmVUbyhudWxsLCAwLCBudWxsKTtcblx0ICAgICAgICB9XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICAgIHRleHROb2RlID0gbmV3IFNoYXBlLlRleHQoc2NlbmUudGV4dCk7XG5cdCAgICAgICAgbGluZSA9IG5ldyBTaGFwZS5Hcm91cCgnbGluZTAnKTtcblx0ICAgICAgICBsaW5lLmFkZCh0ZXh0Tm9kZSk7XG5cdCAgICAgICAgaG9sZGVyVGV4dEdyb3VwLmFkZChsaW5lKTtcblxuXHQgICAgICAgIGlmIChzY2VuZS5hbGlnbiA9PT0gJ2xlZnQnKSB7XG5cdCAgICAgICAgICAgIGhvbGRlclRleHRHcm91cC5tb3ZlVG8oc2NlbmUud2lkdGggLSBzY2VuZU1hcmdpbiwgbnVsbCwgbnVsbCk7XG5cdCAgICAgICAgfSBlbHNlIGlmIChzY2VuZS5hbGlnbiA9PT0gJ3JpZ2h0Jykge1xuXHQgICAgICAgICAgICBob2xkZXJUZXh0R3JvdXAubW92ZVRvKDAgLSAoc2NlbmUud2lkdGggLSBzY2VuZU1hcmdpbiksIG51bGwsIG51bGwpO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIGhvbGRlclRleHRHcm91cC5tb3ZlVG8oKHNjZW5lLndpZHRoIC0gdHBkYXRhLmJvdW5kaW5nQm94LndpZHRoKSAvIDIsIG51bGwsIG51bGwpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGhvbGRlclRleHRHcm91cC5tb3ZlVG8obnVsbCwgKHNjZW5lLmhlaWdodCAtIHRwZGF0YS5ib3VuZGluZ0JveC5oZWlnaHQpIC8gMiwgbnVsbCk7XG5cdCAgICB9XG5cblx0ICAgIC8vdG9kbzogcmVuZGVybGlzdFxuXHQgICAgcmV0dXJuIHNjZW5lR3JhcGg7XG5cdH1cblxuXHQvKipcblx0ICogQWRhcHRpdmUgdGV4dCBzaXppbmcgZnVuY3Rpb25cblx0ICpcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHdpZHRoIFBhcmVudCB3aWR0aFxuXHQgKiBAcGFyYW0gaGVpZ2h0IFBhcmVudCBoZWlnaHRcblx0ICogQHBhcmFtIGZvbnRTaXplIFJlcXVlc3RlZCB0ZXh0IHNpemVcblx0ICogQHBhcmFtIHNjYWxlIFByb3BvcnRpb25hbCBzY2FsZSBvZiB0ZXh0XG5cdCAqL1xuXHRmdW5jdGlvbiB0ZXh0U2l6ZSh3aWR0aCwgaGVpZ2h0LCBmb250U2l6ZSwgc2NhbGUpIHtcblx0ICAgIHZhciBzdGFnZVdpZHRoID0gcGFyc2VJbnQod2lkdGgsIDEwKTtcblx0ICAgIHZhciBzdGFnZUhlaWdodCA9IHBhcnNlSW50KGhlaWdodCwgMTApO1xuXG5cdCAgICB2YXIgYmlnU2lkZSA9IE1hdGgubWF4KHN0YWdlV2lkdGgsIHN0YWdlSGVpZ2h0KTtcblx0ICAgIHZhciBzbWFsbFNpZGUgPSBNYXRoLm1pbihzdGFnZVdpZHRoLCBzdGFnZUhlaWdodCk7XG5cblx0ICAgIHZhciBuZXdIZWlnaHQgPSAwLjggKiBNYXRoLm1pbihzbWFsbFNpZGUsIGJpZ1NpZGUgKiBzY2FsZSk7XG5cdCAgICByZXR1cm4gTWF0aC5yb3VuZChNYXRoLm1heChmb250U2l6ZSwgbmV3SGVpZ2h0KSk7XG5cdH1cblxuXHQvKipcblx0ICogSXRlcmF0ZXMgb3ZlciByZXNpemFibGUgKGZsdWlkIG9yIGF1dG8pIHBsYWNlaG9sZGVycyBhbmQgcmVuZGVycyB0aGVtXG5cdCAqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSBlbGVtZW50IE9wdGlvbmFsIGVsZW1lbnQgc2VsZWN0b3IsIHNwZWNpZmllZCBvbmx5IGlmIGEgc3BlY2lmaWMgZWxlbWVudCBuZWVkcyB0byBiZSByZS1yZW5kZXJlZFxuXHQgKi9cblx0ZnVuY3Rpb24gdXBkYXRlUmVzaXphYmxlRWxlbWVudHMoZWxlbWVudCkge1xuXHQgICAgdmFyIGltYWdlcztcblx0ICAgIGlmIChlbGVtZW50ID09IG51bGwgfHwgZWxlbWVudC5ub2RlVHlwZSA9PSBudWxsKSB7XG5cdCAgICAgICAgaW1hZ2VzID0gQXBwLnZhcnMucmVzaXphYmxlSW1hZ2VzO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgICBpbWFnZXMgPSBbZWxlbWVudF07XG5cdCAgICB9XG5cdCAgICBmb3IgKHZhciBpID0gMCwgbCA9IGltYWdlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0ICAgICAgICB2YXIgZWwgPSBpbWFnZXNbaV07XG5cdCAgICAgICAgaWYgKGVsLmhvbGRlckRhdGEpIHtcblx0ICAgICAgICAgICAgdmFyIGZsYWdzID0gZWwuaG9sZGVyRGF0YS5mbGFncztcblx0ICAgICAgICAgICAgdmFyIGRpbWVuc2lvbnMgPSBkaW1lbnNpb25DaGVjayhlbCk7XG5cdCAgICAgICAgICAgIGlmIChkaW1lbnNpb25zKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoIWVsLmhvbGRlckRhdGEucmVzaXplVXBkYXRlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIGlmIChmbGFncy5mbHVpZCAmJiBmbGFncy5hdXRvKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGZsdWlkQ29uZmlnID0gZWwuaG9sZGVyRGF0YS5mbHVpZENvbmZpZztcblx0ICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGZsdWlkQ29uZmlnLm1vZGUpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnd2lkdGgnOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGltZW5zaW9ucy5oZWlnaHQgPSBkaW1lbnNpb25zLndpZHRoIC8gZmx1aWRDb25maWcucmF0aW87XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnaGVpZ2h0Jzpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpbWVuc2lvbnMud2lkdGggPSBkaW1lbnNpb25zLmhlaWdodCAqIGZsdWlkQ29uZmlnLnJhdGlvO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICB2YXIgc2V0dGluZ3MgPSB7XG5cdCAgICAgICAgICAgICAgICAgICAgbW9kZTogJ2ltYWdlJyxcblx0ICAgICAgICAgICAgICAgICAgICBob2xkZXJTZXR0aW5nczoge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBkaW1lbnNpb25zOiBkaW1lbnNpb25zLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGVtZTogZmxhZ3MudGhlbWUsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGZsYWdzOiBmbGFnc1xuXHQgICAgICAgICAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgICAgICAgICAgZWw6IGVsLFxuXHQgICAgICAgICAgICAgICAgICAgIGVuZ2luZVNldHRpbmdzOiBlbC5ob2xkZXJEYXRhLmVuZ2luZVNldHRpbmdzXG5cdCAgICAgICAgICAgICAgICB9O1xuXG5cdCAgICAgICAgICAgICAgICBpZiAoZmxhZ3MudGV4dG1vZGUgPT0gJ2V4YWN0Jykge1xuXHQgICAgICAgICAgICAgICAgICAgIGZsYWdzLmV4YWN0RGltZW5zaW9ucyA9IGRpbWVuc2lvbnM7XG5cdCAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MuaG9sZGVyU2V0dGluZ3MuZGltZW5zaW9ucyA9IGZsYWdzLmRpbWVuc2lvbnM7XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIHJlbmRlcihzZXR0aW5ncyk7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICBzZXRJbnZpc2libGUoZWwpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgdXAgYXNwZWN0IHJhdGlvIG1ldGFkYXRhIGZvciBmbHVpZCBwbGFjZWhvbGRlcnMsIGluIG9yZGVyIHRvIHByZXNlcnZlIHByb3BvcnRpb25zIHdoZW4gcmVzaXppbmdcblx0ICpcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIGVsIEltYWdlIERPTSBlbGVtZW50XG5cdCAqL1xuXHRmdW5jdGlvbiBzZXRJbml0aWFsRGltZW5zaW9ucyhlbCkge1xuXHQgICAgaWYgKGVsLmhvbGRlckRhdGEpIHtcblx0ICAgICAgICB2YXIgZGltZW5zaW9ucyA9IGRpbWVuc2lvbkNoZWNrKGVsKTtcblx0ICAgICAgICBpZiAoZGltZW5zaW9ucykge1xuXHQgICAgICAgICAgICB2YXIgZmxhZ3MgPSBlbC5ob2xkZXJEYXRhLmZsYWdzO1xuXG5cdCAgICAgICAgICAgIHZhciBmbHVpZENvbmZpZyA9IHtcblx0ICAgICAgICAgICAgICAgIGZsdWlkSGVpZ2h0OiBmbGFncy5kaW1lbnNpb25zLmhlaWdodC5zbGljZSgtMSkgPT0gJyUnLFxuXHQgICAgICAgICAgICAgICAgZmx1aWRXaWR0aDogZmxhZ3MuZGltZW5zaW9ucy53aWR0aC5zbGljZSgtMSkgPT0gJyUnLFxuXHQgICAgICAgICAgICAgICAgbW9kZTogbnVsbCxcblx0ICAgICAgICAgICAgICAgIGluaXRpYWxEaW1lbnNpb25zOiBkaW1lbnNpb25zXG5cdCAgICAgICAgICAgIH07XG5cblx0ICAgICAgICAgICAgaWYgKGZsdWlkQ29uZmlnLmZsdWlkV2lkdGggJiYgIWZsdWlkQ29uZmlnLmZsdWlkSGVpZ2h0KSB7XG5cdCAgICAgICAgICAgICAgICBmbHVpZENvbmZpZy5tb2RlID0gJ3dpZHRoJztcblx0ICAgICAgICAgICAgICAgIGZsdWlkQ29uZmlnLnJhdGlvID0gZmx1aWRDb25maWcuaW5pdGlhbERpbWVuc2lvbnMud2lkdGggLyBwYXJzZUZsb2F0KGZsYWdzLmRpbWVuc2lvbnMuaGVpZ2h0KTtcblx0ICAgICAgICAgICAgfSBlbHNlIGlmICghZmx1aWRDb25maWcuZmx1aWRXaWR0aCAmJiBmbHVpZENvbmZpZy5mbHVpZEhlaWdodCkge1xuXHQgICAgICAgICAgICAgICAgZmx1aWRDb25maWcubW9kZSA9ICdoZWlnaHQnO1xuXHQgICAgICAgICAgICAgICAgZmx1aWRDb25maWcucmF0aW8gPSBwYXJzZUZsb2F0KGZsYWdzLmRpbWVuc2lvbnMud2lkdGgpIC8gZmx1aWRDb25maWcuaW5pdGlhbERpbWVuc2lvbnMuaGVpZ2h0O1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgZWwuaG9sZGVyRGF0YS5mbHVpZENvbmZpZyA9IGZsdWlkQ29uZmlnO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIHNldEludmlzaWJsZShlbCk7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHR9XG5cblx0LyoqXG5cdCAqIEl0ZXJhdGVzIHRocm91Z2ggYWxsIGN1cnJlbnQgaW52aXNpYmxlIGltYWdlcywgYW5kIGlmIHRoZXkncmUgdmlzaWJsZSwgcmVuZGVycyB0aGVtIGFuZCByZW1vdmVzIHRoZW0gZnJvbSBmdXJ0aGVyIGNoZWNrcy4gUnVucyBldmVyeSBhbmltYXRpb24gZnJhbWUuXG5cdCAqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRmdW5jdGlvbiB2aXNpYmlsaXR5Q2hlY2soKSB7XG5cdCAgICB2YXIgcmVuZGVyYWJsZUltYWdlcyA9IFtdO1xuXHQgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhBcHAudmFycy5pbnZpc2libGVJbWFnZXMpO1xuXHQgICAgdmFyIGVsO1xuXG5cdCAgICBrZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuXHQgICAgICAgIGVsID0gQXBwLnZhcnMuaW52aXNpYmxlSW1hZ2VzW2tleV07XG5cdCAgICAgICAgaWYgKGRpbWVuc2lvbkNoZWNrKGVsKSAmJiBlbC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09ICdpbWcnKSB7XG5cdCAgICAgICAgICAgIHJlbmRlcmFibGVJbWFnZXMucHVzaChlbCk7XG5cdCAgICAgICAgICAgIGRlbGV0ZSBBcHAudmFycy5pbnZpc2libGVJbWFnZXNba2V5XTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblxuXHQgICAgaWYgKHJlbmRlcmFibGVJbWFnZXMubGVuZ3RoKSB7XG5cdCAgICAgICAgSG9sZGVyLnJ1bih7XG5cdCAgICAgICAgICAgIGltYWdlczogcmVuZGVyYWJsZUltYWdlc1xuXHQgICAgICAgIH0pO1xuXHQgICAgfVxuXG5cdCAgICAvLyBEb25lIHRvIHByZXZlbnQgMTAwJSBDUFUgdXNhZ2UgdmlhIGFnZ3Jlc3NpdmUgY2FsbGluZyBvZiByZXF1ZXN0QW5pbWF0aW9uRnJhbWVcblx0ICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIGdsb2JhbC5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUodmlzaWJpbGl0eUNoZWNrKTtcblx0ICAgIH0sIDEwKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBTdGFydHMgY2hlY2tpbmcgZm9yIGludmlzaWJsZSBwbGFjZWhvbGRlcnMgaWYgbm90IGRvaW5nIHNvIHlldC4gRG9lcyBub3RoaW5nIG90aGVyd2lzZS5cblx0ICpcblx0ICogQHByaXZhdGVcblx0ICovXG5cdGZ1bmN0aW9uIHN0YXJ0VmlzaWJpbGl0eUNoZWNrKCkge1xuXHQgICAgaWYgKCFBcHAudmFycy52aXNpYmlsaXR5Q2hlY2tTdGFydGVkKSB7XG5cdCAgICAgICAgZ2xvYmFsLnJlcXVlc3RBbmltYXRpb25GcmFtZSh2aXNpYmlsaXR5Q2hlY2spO1xuXHQgICAgICAgIEFwcC52YXJzLnZpc2liaWxpdHlDaGVja1N0YXJ0ZWQgPSB0cnVlO1xuXHQgICAgfVxuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgYSB1bmlxdWUgSUQgZm9yIGFuIGltYWdlIGRldGVjdGVkIHRvIGJlIGludmlzaWJsZSBhbmQgYWRkcyBpdCB0byB0aGUgbWFwIG9mIGludmlzaWJsZSBpbWFnZXMgY2hlY2tlZCBieSB2aXNpYmlsaXR5Q2hlY2tcblx0ICpcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIGVsIEludmlzaWJsZSBET00gZWxlbWVudFxuXHQgKi9cblx0ZnVuY3Rpb24gc2V0SW52aXNpYmxlKGVsKSB7XG5cdCAgICBpZiAoIWVsLmhvbGRlckRhdGEuaW52aXNpYmxlSWQpIHtcblx0ICAgICAgICBBcHAudmFycy5pbnZpc2libGVJZCArPSAxO1xuXHQgICAgICAgIEFwcC52YXJzLmludmlzaWJsZUltYWdlc1snaScgKyBBcHAudmFycy5pbnZpc2libGVJZF0gPSBlbDtcblx0ICAgICAgICBlbC5ob2xkZXJEYXRhLmludmlzaWJsZUlkID0gQXBwLnZhcnMuaW52aXNpYmxlSWQ7XG5cdCAgICB9XG5cdH1cblxuXHQvL3RvZG86IHNlZSBpZiBwb3NzaWJsZSB0byBjb252ZXJ0IHN0YWdpbmdSZW5kZXJlciB0byB1c2UgSFRNTCBvbmx5XG5cdHZhciBzdGFnaW5nUmVuZGVyZXIgPSAoZnVuY3Rpb24oKSB7XG5cdCAgICB2YXIgc3ZnID0gbnVsbCxcblx0ICAgICAgICBzdGFnaW5nVGV4dCA9IG51bGwsXG5cdCAgICAgICAgc3RhZ2luZ1RleHROb2RlID0gbnVsbDtcblx0ICAgIHJldHVybiBmdW5jdGlvbihncmFwaCkge1xuXHQgICAgICAgIHZhciByb290Tm9kZSA9IGdyYXBoLnJvb3Q7XG5cdCAgICAgICAgaWYgKEFwcC5zZXR1cC5zdXBwb3J0c1NWRykge1xuXHQgICAgICAgICAgICB2YXIgZmlyc3RUaW1lU2V0dXAgPSBmYWxzZTtcblx0ICAgICAgICAgICAgdmFyIHRub2RlID0gZnVuY3Rpb24odGV4dCkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRleHQpO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICBpZiAoc3ZnID09IG51bGwgfHwgc3ZnLnBhcmVudE5vZGUgIT09IGRvY3VtZW50LmJvZHkpIHtcblx0ICAgICAgICAgICAgICAgIGZpcnN0VGltZVNldHVwID0gdHJ1ZTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHN2ZyA9IFNWRy5pbml0U1ZHKHN2Zywgcm9vdE5vZGUucHJvcGVydGllcy53aWR0aCwgcm9vdE5vZGUucHJvcGVydGllcy5oZWlnaHQpO1xuXHQgICAgICAgICAgICAvL1Nob3cgc3RhZ2luZyBlbGVtZW50IGJlZm9yZSBzdGFnaW5nXG5cdCAgICAgICAgICAgIHN2Zy5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcblxuXHQgICAgICAgICAgICBpZiAoZmlyc3RUaW1lU2V0dXApIHtcblx0ICAgICAgICAgICAgICAgIHN0YWdpbmdUZXh0ID0gRE9NLm5ld0VsKCd0ZXh0JywgU1ZHX05TKTtcblx0ICAgICAgICAgICAgICAgIHN0YWdpbmdUZXh0Tm9kZSA9IHRub2RlKG51bGwpO1xuXHQgICAgICAgICAgICAgICAgRE9NLnNldEF0dHIoc3RhZ2luZ1RleHQsIHtcblx0ICAgICAgICAgICAgICAgICAgICB4OiAwXG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgIHN0YWdpbmdUZXh0LmFwcGVuZENoaWxkKHN0YWdpbmdUZXh0Tm9kZSk7XG5cdCAgICAgICAgICAgICAgICBzdmcuYXBwZW5kQ2hpbGQoc3RhZ2luZ1RleHQpO1xuXHQgICAgICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChzdmcpO1xuXHQgICAgICAgICAgICAgICAgc3ZnLnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcblx0ICAgICAgICAgICAgICAgIHN2Zy5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG5cdCAgICAgICAgICAgICAgICBzdmcuc3R5bGUudG9wID0gJy0xMDAlJztcblx0ICAgICAgICAgICAgICAgIHN2Zy5zdHlsZS5sZWZ0ID0gJy0xMDAlJztcblx0ICAgICAgICAgICAgICAgIC8vdG9kbzogd29ya2Fyb3VuZCBmb3IgemVyby1kaW1lbnNpb24gPHN2Zz4gdGFnIGluIE9wZXJhIDEyXG5cdCAgICAgICAgICAgICAgICAvL3N2Zy5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgMCk7XG5cdCAgICAgICAgICAgICAgICAvL3N2Zy5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIDApO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgdmFyIGhvbGRlclRleHRHcm91cCA9IHJvb3ROb2RlLmNoaWxkcmVuLmhvbGRlclRleHRHcm91cDtcblx0ICAgICAgICAgICAgdmFyIGh0Z1Byb3BzID0gaG9sZGVyVGV4dEdyb3VwLnByb3BlcnRpZXM7XG5cdCAgICAgICAgICAgIERPTS5zZXRBdHRyKHN0YWdpbmdUZXh0LCB7XG5cdCAgICAgICAgICAgICAgICAneSc6IGh0Z1Byb3BzLmZvbnQuc2l6ZSxcblx0ICAgICAgICAgICAgICAgICdzdHlsZSc6IHV0aWxzLmNzc1Byb3BzKHtcblx0ICAgICAgICAgICAgICAgICAgICAnZm9udC13ZWlnaHQnOiBodGdQcm9wcy5mb250LndlaWdodCxcblx0ICAgICAgICAgICAgICAgICAgICAnZm9udC1zaXplJzogaHRnUHJvcHMuZm9udC5zaXplICsgaHRnUHJvcHMuZm9udC51bml0cyxcblx0ICAgICAgICAgICAgICAgICAgICAnZm9udC1mYW1pbHknOiBodGdQcm9wcy5mb250LmZhbWlseVxuXHQgICAgICAgICAgICAgICAgfSlcblx0ICAgICAgICAgICAgfSk7XG5cblx0ICAgICAgICAgICAgLy9VbmVzY2FwZSBIVE1MIGVudGl0aWVzIHRvIGdldCBhcHByb3hpbWF0ZWx5IHRoZSByaWdodCB3aWR0aFxuXHQgICAgICAgICAgICB2YXIgdHh0ID0gRE9NLm5ld0VsKCd0ZXh0YXJlYScpO1xuXHQgICAgICAgICAgICB0eHQuaW5uZXJIVE1MID0gaHRnUHJvcHMudGV4dDtcblx0ICAgICAgICAgICAgc3RhZ2luZ1RleHROb2RlLm5vZGVWYWx1ZSA9IHR4dC52YWx1ZTtcblxuXHQgICAgICAgICAgICAvL0dldCBib3VuZGluZyBib3ggZm9yIHRoZSB3aG9sZSBzdHJpbmcgKHRvdGFsIHdpZHRoIGFuZCBoZWlnaHQpXG5cdCAgICAgICAgICAgIHZhciBzdGFnaW5nVGV4dEJCb3ggPSBzdGFnaW5nVGV4dC5nZXRCQm94KCk7XG5cblx0ICAgICAgICAgICAgLy9HZXQgbGluZSBjb3VudCBhbmQgc3BsaXQgdGhlIHN0cmluZyBpbnRvIHdvcmRzXG5cdCAgICAgICAgICAgIHZhciBsaW5lQ291bnQgPSBNYXRoLmNlaWwoc3RhZ2luZ1RleHRCQm94LndpZHRoIC8gcm9vdE5vZGUucHJvcGVydGllcy53aWR0aCk7XG5cdCAgICAgICAgICAgIHZhciB3b3JkcyA9IGh0Z1Byb3BzLnRleHQuc3BsaXQoJyAnKTtcblx0ICAgICAgICAgICAgdmFyIG5ld2xpbmVzID0gaHRnUHJvcHMudGV4dC5tYXRjaCgvXFxcXG4vZyk7XG5cdCAgICAgICAgICAgIGxpbmVDb3VudCArPSBuZXdsaW5lcyA9PSBudWxsID8gMCA6IG5ld2xpbmVzLmxlbmd0aDtcblxuXHQgICAgICAgICAgICAvL0dldCBib3VuZGluZyBib3ggZm9yIHRoZSBzdHJpbmcgd2l0aCBzcGFjZXMgcmVtb3ZlZFxuXHQgICAgICAgICAgICBzdGFnaW5nVGV4dE5vZGUubm9kZVZhbHVlID0gaHRnUHJvcHMudGV4dC5yZXBsYWNlKC9bIF0rL2csICcnKTtcblx0ICAgICAgICAgICAgdmFyIGNvbXB1dGVkTm9TcGFjZUxlbmd0aCA9IHN0YWdpbmdUZXh0LmdldENvbXB1dGVkVGV4dExlbmd0aCgpO1xuXG5cdCAgICAgICAgICAgIC8vQ29tcHV0ZSBhdmVyYWdlIHNwYWNlIHdpZHRoXG5cdCAgICAgICAgICAgIHZhciBkaWZmTGVuZ3RoID0gc3RhZ2luZ1RleHRCQm94LndpZHRoIC0gY29tcHV0ZWROb1NwYWNlTGVuZ3RoO1xuXHQgICAgICAgICAgICB2YXIgc3BhY2VXaWR0aCA9IE1hdGgucm91bmQoZGlmZkxlbmd0aCAvIE1hdGgubWF4KDEsIHdvcmRzLmxlbmd0aCAtIDEpKTtcblxuXHQgICAgICAgICAgICAvL0dldCB3aWR0aHMgZm9yIGV2ZXJ5IHdvcmQgd2l0aCBzcGFjZSBvbmx5IGlmIHRoZXJlIGlzIG1vcmUgdGhhbiBvbmUgbGluZVxuXHQgICAgICAgICAgICB2YXIgd29yZFdpZHRocyA9IFtdO1xuXHQgICAgICAgICAgICBpZiAobGluZUNvdW50ID4gMSkge1xuXHQgICAgICAgICAgICAgICAgc3RhZ2luZ1RleHROb2RlLm5vZGVWYWx1ZSA9ICcnO1xuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB3b3Jkcy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgICAgIGlmICh3b3Jkc1tpXS5sZW5ndGggPT09IDApIGNvbnRpbnVlO1xuXHQgICAgICAgICAgICAgICAgICAgIHN0YWdpbmdUZXh0Tm9kZS5ub2RlVmFsdWUgPSB1dGlscy5kZWNvZGVIdG1sRW50aXR5KHdvcmRzW2ldKTtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgYmJveCA9IHN0YWdpbmdUZXh0LmdldEJCb3goKTtcblx0ICAgICAgICAgICAgICAgICAgICB3b3JkV2lkdGhzLnB1c2goe1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiB3b3Jkc1tpXSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IGJib3gud2lkdGhcblx0ICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vSGlkZSBzdGFnaW5nIGVsZW1lbnQgYWZ0ZXIgc3RhZ2luZ1xuXHQgICAgICAgICAgICBzdmcuc3R5bGUuZGlzcGxheSA9ICdub25lJztcblxuXHQgICAgICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICAgICAgc3BhY2VXaWR0aDogc3BhY2VXaWR0aCxcblx0ICAgICAgICAgICAgICAgIGxpbmVDb3VudDogbGluZUNvdW50LFxuXHQgICAgICAgICAgICAgICAgYm91bmRpbmdCb3g6IHN0YWdpbmdUZXh0QkJveCxcblx0ICAgICAgICAgICAgICAgIHdvcmRzOiB3b3JkV2lkdGhzXG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgLy90b2RvOiBjYW52YXMgZmFsbGJhY2sgZm9yIG1lYXN1cmluZyB0ZXh0IG9uIGFuZHJvaWQgMi4zXG5cdCAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHR9KSgpO1xuXG5cdC8vSGVscGVyc1xuXG5cdC8qKlxuXHQgKiBQcmV2ZW50cyBhIGZ1bmN0aW9uIGZyb20gYmVpbmcgY2FsbGVkIHRvbyBvZnRlbiwgd2FpdHMgdW50aWwgYSB0aW1lciBlbGFwc2VzIHRvIGNhbGwgaXQgYWdhaW5cblx0ICpcblx0ICogQHBhcmFtIGZuIEZ1bmN0aW9uIHRvIGNhbGxcblx0ICovXG5cdGZ1bmN0aW9uIGRlYm91bmNlKGZuKSB7XG5cdCAgICBpZiAoIUFwcC52YXJzLmRlYm91bmNlVGltZXIpIGZuLmNhbGwodGhpcyk7XG5cdCAgICBpZiAoQXBwLnZhcnMuZGVib3VuY2VUaW1lcikgZ2xvYmFsLmNsZWFyVGltZW91dChBcHAudmFycy5kZWJvdW5jZVRpbWVyKTtcblx0ICAgIEFwcC52YXJzLmRlYm91bmNlVGltZXIgPSBnbG9iYWwuc2V0VGltZW91dChmdW5jdGlvbigpIHtcblx0ICAgICAgICBBcHAudmFycy5kZWJvdW5jZVRpbWVyID0gbnVsbDtcblx0ICAgICAgICBmbi5jYWxsKHRoaXMpO1xuXHQgICAgfSwgQXBwLnNldHVwLmRlYm91bmNlKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBIb2xkZXItc3BlY2lmaWMgcmVzaXplL29yaWVudGF0aW9uIGNoYW5nZSBjYWxsYmFjaywgZGVib3VuY2VkIHRvIHByZXZlbnQgZXhjZXNzaXZlIGV4ZWN1dGlvblxuXHQgKi9cblx0ZnVuY3Rpb24gcmVzaXplRXZlbnQoKSB7XG5cdCAgICBkZWJvdW5jZShmdW5jdGlvbigpIHtcblx0ICAgICAgICB1cGRhdGVSZXNpemFibGVFbGVtZW50cyhudWxsKTtcblx0ICAgIH0pO1xuXHR9XG5cblx0Ly9TZXQgdXAgZmxhZ3NcblxuXHRmb3IgKHZhciBmbGFnIGluIEFwcC5mbGFncykge1xuXHQgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoQXBwLmZsYWdzLCBmbGFnKSkgY29udGludWU7XG5cdCAgICBBcHAuZmxhZ3NbZmxhZ10ubWF0Y2ggPSBmdW5jdGlvbih2YWwpIHtcblx0ICAgICAgICByZXR1cm4gdmFsLm1hdGNoKHRoaXMucmVnZXgpO1xuXHQgICAgfTtcblx0fVxuXG5cdC8vUHJvcGVydGllcyBzZXQgb25jZSBvbiBzZXR1cFxuXG5cdEFwcC5zZXR1cCA9IHtcblx0ICAgIHJlbmRlcmVyOiAnaHRtbCcsXG5cdCAgICBkZWJvdW5jZTogMTAwLFxuXHQgICAgcmF0aW86IDEsXG5cdCAgICBzdXBwb3J0c0NhbnZhczogZmFsc2UsXG5cdCAgICBzdXBwb3J0c1NWRzogZmFsc2UsXG5cdCAgICBsaW5lV3JhcFJhdGlvOiAwLjksXG5cdCAgICBkYXRhQXR0cjogJ2RhdGEtc3JjJyxcblx0ICAgIHJlbmRlcmVyczogWydodG1sJywgJ2NhbnZhcycsICdzdmcnXVxuXHR9O1xuXG5cdC8vUHJvcGVydGllcyBtb2RpZmllZCBkdXJpbmcgcnVudGltZVxuXG5cdEFwcC52YXJzID0ge1xuXHQgICAgcHJlZW1wdGVkOiBmYWxzZSxcblx0ICAgIHJlc2l6YWJsZUltYWdlczogW10sXG5cdCAgICBpbnZpc2libGVJbWFnZXM6IHt9LFxuXHQgICAgaW52aXNpYmxlSWQ6IDAsXG5cdCAgICB2aXNpYmlsaXR5Q2hlY2tTdGFydGVkOiBmYWxzZSxcblx0ICAgIGRlYm91bmNlVGltZXI6IG51bGwsXG5cdCAgICBjYWNoZToge31cblx0fTtcblxuXHQvL1ByZS1mbGlnaHRcblxuXHQoZnVuY3Rpb24oKSB7XG5cdCAgICB2YXIgY2FudmFzID0gRE9NLm5ld0VsKCdjYW52YXMnKTtcblxuXHQgICAgaWYgKGNhbnZhcy5nZXRDb250ZXh0KSB7XG5cdCAgICAgICAgaWYgKGNhbnZhcy50b0RhdGFVUkwoJ2ltYWdlL3BuZycpLmluZGV4T2YoJ2RhdGE6aW1hZ2UvcG5nJykgIT0gLTEpIHtcblx0ICAgICAgICAgICAgQXBwLnNldHVwLnJlbmRlcmVyID0gJ2NhbnZhcyc7XG5cdCAgICAgICAgICAgIEFwcC5zZXR1cC5zdXBwb3J0c0NhbnZhcyA9IHRydWU7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICBpZiAoISFkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMgJiYgISFkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoU1ZHX05TLCAnc3ZnJykuY3JlYXRlU1ZHUmVjdCkge1xuXHQgICAgICAgIEFwcC5zZXR1cC5yZW5kZXJlciA9ICdzdmcnO1xuXHQgICAgICAgIEFwcC5zZXR1cC5zdXBwb3J0c1NWRyA9IHRydWU7XG5cdCAgICB9XG5cdH0pKCk7XG5cblx0Ly9TdGFydHMgY2hlY2tpbmcgZm9yIGludmlzaWJsZSBwbGFjZWhvbGRlcnNcblx0c3RhcnRWaXNpYmlsaXR5Q2hlY2soKTtcblxuXHRpZiAob25Eb21SZWFkeSkge1xuXHQgICAgb25Eb21SZWFkeShmdW5jdGlvbigpIHtcblx0ICAgICAgICBpZiAoIUFwcC52YXJzLnByZWVtcHRlZCkge1xuXHQgICAgICAgICAgICBIb2xkZXIucnVuKCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmIChnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcikge1xuXHQgICAgICAgICAgICBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgcmVzaXplRXZlbnQsIGZhbHNlKTtcblx0ICAgICAgICAgICAgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIoJ29yaWVudGF0aW9uY2hhbmdlJywgcmVzaXplRXZlbnQsIGZhbHNlKTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICBnbG9iYWwuYXR0YWNoRXZlbnQoJ29ucmVzaXplJywgcmVzaXplRXZlbnQpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGlmICh0eXBlb2YgZ2xvYmFsLlR1cmJvbGlua3MgPT0gJ29iamVjdCcpIHtcblx0ICAgICAgICAgICAgZ2xvYmFsLmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3BhZ2U6Y2hhbmdlJywgZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICBIb2xkZXIucnVuKCk7XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHR9XG5cblx0bW9kdWxlLmV4cG9ydHMgPSBIb2xkZXI7XG5cblx0LyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovfS5jYWxsKGV4cG9ydHMsIChmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0oKSkpKVxuXG4vKioqLyB9KSxcbi8qIDIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHQvKiFcblx0ICogb25Eb21SZWFkeS5qcyAxLjQuMCAoYykgMjAxMyBUdWJhbCBNYXJ0aW4gLSBNSVQgbGljZW5zZVxuXHQgKlxuXHQgKiBTcGVjaWFsbHkgbW9kaWZpZWQgdG8gd29yayB3aXRoIEhvbGRlci5qc1xuXHQgKi9cblxuXHRmdW5jdGlvbiBfb25Eb21SZWFkeSh3aW4pIHtcblx0ICAgIC8vTGF6eSBsb2FkaW5nIGZpeCBmb3IgRmlyZWZveCA8IDMuNlxuXHQgICAgLy9odHRwOi8vd2VicmVmbGVjdGlvbi5ibG9nc3BvdC5jb20vMjAwOS8xMS8xOTUtY2hhcnMtdG8taGVscC1sYXp5LWxvYWRpbmcuaHRtbFxuXHQgICAgaWYgKGRvY3VtZW50LnJlYWR5U3RhdGUgPT0gbnVsbCAmJiBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKSB7XG5cdCAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIkRPTUNvbnRlbnRMb2FkZWRcIiwgZnVuY3Rpb24gRE9NQ29udGVudExvYWRlZCgpIHtcblx0ICAgICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIkRPTUNvbnRlbnRMb2FkZWRcIiwgRE9NQ29udGVudExvYWRlZCwgZmFsc2UpO1xuXHQgICAgICAgICAgICBkb2N1bWVudC5yZWFkeVN0YXRlID0gXCJjb21wbGV0ZVwiO1xuXHQgICAgICAgIH0sIGZhbHNlKTtcblx0ICAgICAgICBkb2N1bWVudC5yZWFkeVN0YXRlID0gXCJsb2FkaW5nXCI7XG5cdCAgICB9XG5cdCAgICBcblx0ICAgIHZhciBkb2MgPSB3aW4uZG9jdW1lbnQsXG5cdCAgICAgICAgZG9jRWxlbSA9IGRvYy5kb2N1bWVudEVsZW1lbnQsXG5cdCAgICBcblx0ICAgICAgICBMT0FEID0gXCJsb2FkXCIsXG5cdCAgICAgICAgRkFMU0UgPSBmYWxzZSxcblx0ICAgICAgICBPTkxPQUQgPSBcIm9uXCIrTE9BRCxcblx0ICAgICAgICBDT01QTEVURSA9IFwiY29tcGxldGVcIixcblx0ICAgICAgICBSRUFEWVNUQVRFID0gXCJyZWFkeVN0YXRlXCIsXG5cdCAgICAgICAgQVRUQUNIRVZFTlQgPSBcImF0dGFjaEV2ZW50XCIsXG5cdCAgICAgICAgREVUQUNIRVZFTlQgPSBcImRldGFjaEV2ZW50XCIsXG5cdCAgICAgICAgQURERVZFTlRMSVNURU5FUiA9IFwiYWRkRXZlbnRMaXN0ZW5lclwiLFxuXHQgICAgICAgIERPTUNPTlRFTlRMT0FERUQgPSBcIkRPTUNvbnRlbnRMb2FkZWRcIixcblx0ICAgICAgICBPTlJFQURZU1RBVEVDSEFOR0UgPSBcIm9ucmVhZHlzdGF0ZWNoYW5nZVwiLFxuXHQgICAgICAgIFJFTU9WRUVWRU5UTElTVEVORVIgPSBcInJlbW92ZUV2ZW50TGlzdGVuZXJcIixcblx0ICAgIFxuXHQgICAgICAgIC8vIFczQyBFdmVudCBtb2RlbFxuXHQgICAgICAgIHczYyA9IEFEREVWRU5UTElTVEVORVIgaW4gZG9jLFxuXHQgICAgICAgIF90b3AgPSBGQUxTRSxcblx0ICAgIFxuXHQgICAgICAgIC8vIGlzUmVhZHk6IElzIHRoZSBET00gcmVhZHkgdG8gYmUgdXNlZD8gU2V0IHRvIHRydWUgb25jZSBpdCBvY2N1cnMuXG5cdCAgICAgICAgaXNSZWFkeSA9IEZBTFNFLFxuXHQgICAgXG5cdCAgICAgICAgLy8gQ2FsbGJhY2tzIHBlbmRpbmcgZXhlY3V0aW9uIHVudGlsIERPTSBpcyByZWFkeVxuXHQgICAgICAgIGNhbGxiYWNrcyA9IFtdO1xuXHQgICAgXG5cdCAgICAvLyBIYW5kbGUgd2hlbiB0aGUgRE9NIGlzIHJlYWR5XG5cdCAgICBmdW5jdGlvbiByZWFkeSggZm4gKSB7XG5cdCAgICAgICAgaWYgKCAhaXNSZWFkeSApIHtcblx0ICAgIFxuXHQgICAgICAgICAgICAvLyBNYWtlIHN1cmUgYm9keSBleGlzdHMsIGF0IGxlYXN0LCBpbiBjYXNlIElFIGdldHMgYSBsaXR0bGUgb3ZlcnplYWxvdXMgKHRpY2tldCAjNTQ0MykuXG5cdCAgICAgICAgICAgIGlmICggIWRvYy5ib2R5ICkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGRlZmVyKCByZWFkeSApO1xuXHQgICAgICAgICAgICB9XG5cdCAgICBcblx0ICAgICAgICAgICAgLy8gUmVtZW1iZXIgdGhhdCB0aGUgRE9NIGlzIHJlYWR5XG5cdCAgICAgICAgICAgIGlzUmVhZHkgPSB0cnVlO1xuXHQgICAgXG5cdCAgICAgICAgICAgIC8vIEV4ZWN1dGUgYWxsIGNhbGxiYWNrc1xuXHQgICAgICAgICAgICB3aGlsZSAoIGZuID0gY2FsbGJhY2tzLnNoaWZ0KCkgKSB7XG5cdCAgICAgICAgICAgICAgICBkZWZlciggZm4gKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH1cblx0ICAgIFxuXHQgICAgLy8gVGhlIHJlYWR5IGV2ZW50IGhhbmRsZXJcblx0ICAgIGZ1bmN0aW9uIGNvbXBsZXRlZCggZXZlbnQgKSB7XG5cdCAgICAgICAgLy8gcmVhZHlTdGF0ZSA9PT0gXCJjb21wbGV0ZVwiIGlzIGdvb2QgZW5vdWdoIGZvciB1cyB0byBjYWxsIHRoZSBkb20gcmVhZHkgaW4gb2xkSUVcblx0ICAgICAgICBpZiAoIHczYyB8fCBldmVudC50eXBlID09PSBMT0FEIHx8IGRvY1tSRUFEWVNUQVRFXSA9PT0gQ09NUExFVEUgKSB7XG5cdCAgICAgICAgICAgIGRldGFjaCgpO1xuXHQgICAgICAgICAgICByZWFkeSgpO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblx0ICAgIFxuXHQgICAgLy8gQ2xlYW4tdXAgbWV0aG9kIGZvciBkb20gcmVhZHkgZXZlbnRzXG5cdCAgICBmdW5jdGlvbiBkZXRhY2goKSB7XG5cdCAgICAgICAgaWYgKCB3M2MgKSB7XG5cdCAgICAgICAgICAgIGRvY1tSRU1PVkVFVkVOVExJU1RFTkVSXSggRE9NQ09OVEVOVExPQURFRCwgY29tcGxldGVkLCBGQUxTRSApO1xuXHQgICAgICAgICAgICB3aW5bUkVNT1ZFRVZFTlRMSVNURU5FUl0oIExPQUQsIGNvbXBsZXRlZCwgRkFMU0UgKTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICBkb2NbREVUQUNIRVZFTlRdKCBPTlJFQURZU1RBVEVDSEFOR0UsIGNvbXBsZXRlZCApO1xuXHQgICAgICAgICAgICB3aW5bREVUQUNIRVZFTlRdKCBPTkxPQUQsIGNvbXBsZXRlZCApO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblx0ICAgIFxuXHQgICAgLy8gRGVmZXJzIGEgZnVuY3Rpb24sIHNjaGVkdWxpbmcgaXQgdG8gcnVuIGFmdGVyIHRoZSBjdXJyZW50IGNhbGwgc3RhY2sgaGFzIGNsZWFyZWQuXG5cdCAgICBmdW5jdGlvbiBkZWZlciggZm4sIHdhaXQgKSB7XG5cdCAgICAgICAgLy8gQWxsb3cgMCB0byBiZSBwYXNzZWRcblx0ICAgICAgICBzZXRUaW1lb3V0KCBmbiwgK3dhaXQgPj0gMCA/IHdhaXQgOiAxICk7XG5cdCAgICB9XG5cdCAgICBcblx0ICAgIC8vIEF0dGFjaCB0aGUgbGlzdGVuZXJzOlxuXHQgICAgXG5cdCAgICAvLyBDYXRjaCBjYXNlcyB3aGVyZSBvbkRvbVJlYWR5IGlzIGNhbGxlZCBhZnRlciB0aGUgYnJvd3NlciBldmVudCBoYXMgYWxyZWFkeSBvY2N1cnJlZC5cblx0ICAgIC8vIHdlIG9uY2UgdHJpZWQgdG8gdXNlIHJlYWR5U3RhdGUgXCJpbnRlcmFjdGl2ZVwiIGhlcmUsIGJ1dCBpdCBjYXVzZWQgaXNzdWVzIGxpa2UgdGhlIG9uZVxuXHQgICAgLy8gZGlzY292ZXJlZCBieSBDaHJpc1MgaGVyZTogaHR0cDovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvMTIyODIjY29tbWVudDoxNVxuXHQgICAgaWYgKCBkb2NbUkVBRFlTVEFURV0gPT09IENPTVBMRVRFICkge1xuXHQgICAgICAgIC8vIEhhbmRsZSBpdCBhc3luY2hyb25vdXNseSB0byBhbGxvdyBzY3JpcHRzIHRoZSBvcHBvcnR1bml0eSB0byBkZWxheSByZWFkeVxuXHQgICAgICAgIGRlZmVyKCByZWFkeSApO1xuXHQgICAgXG5cdCAgICAvLyBTdGFuZGFyZHMtYmFzZWQgYnJvd3NlcnMgc3VwcG9ydCBET01Db250ZW50TG9hZGVkXG5cdCAgICB9IGVsc2UgaWYgKCB3M2MgKSB7XG5cdCAgICAgICAgLy8gVXNlIHRoZSBoYW5keSBldmVudCBjYWxsYmFja1xuXHQgICAgICAgIGRvY1tBRERFVkVOVExJU1RFTkVSXSggRE9NQ09OVEVOVExPQURFRCwgY29tcGxldGVkLCBGQUxTRSApO1xuXHQgICAgXG5cdCAgICAgICAgLy8gQSBmYWxsYmFjayB0byB3aW5kb3cub25sb2FkLCB0aGF0IHdpbGwgYWx3YXlzIHdvcmtcblx0ICAgICAgICB3aW5bQURERVZFTlRMSVNURU5FUl0oIExPQUQsIGNvbXBsZXRlZCwgRkFMU0UgKTtcblx0ICAgIFxuXHQgICAgLy8gSWYgSUUgZXZlbnQgbW9kZWwgaXMgdXNlZFxuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgICAvLyBFbnN1cmUgZmlyaW5nIGJlZm9yZSBvbmxvYWQsIG1heWJlIGxhdGUgYnV0IHNhZmUgYWxzbyBmb3IgaWZyYW1lc1xuXHQgICAgICAgIGRvY1tBVFRBQ0hFVkVOVF0oIE9OUkVBRFlTVEFURUNIQU5HRSwgY29tcGxldGVkICk7XG5cdCAgICBcblx0ICAgICAgICAvLyBBIGZhbGxiYWNrIHRvIHdpbmRvdy5vbmxvYWQsIHRoYXQgd2lsbCBhbHdheXMgd29ya1xuXHQgICAgICAgIHdpbltBVFRBQ0hFVkVOVF0oIE9OTE9BRCwgY29tcGxldGVkICk7XG5cdCAgICBcblx0ICAgICAgICAvLyBJZiBJRSBhbmQgbm90IGEgZnJhbWVcblx0ICAgICAgICAvLyBjb250aW51YWxseSBjaGVjayB0byBzZWUgaWYgdGhlIGRvY3VtZW50IGlzIHJlYWR5XG5cdCAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgX3RvcCA9IHdpbi5mcmFtZUVsZW1lbnQgPT0gbnVsbCAmJiBkb2NFbGVtO1xuXHQgICAgICAgIH0gY2F0Y2goZSkge31cblx0ICAgIFxuXHQgICAgICAgIGlmICggX3RvcCAmJiBfdG9wLmRvU2Nyb2xsICkge1xuXHQgICAgICAgICAgICAoZnVuY3Rpb24gZG9TY3JvbGxDaGVjaygpIHtcblx0ICAgICAgICAgICAgICAgIGlmICggIWlzUmVhZHkgKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gVXNlIHRoZSB0cmljayBieSBEaWVnbyBQZXJpbmlcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gaHR0cDovL2phdmFzY3JpcHQubndib3guY29tL0lFQ29udGVudExvYWRlZC9cblx0ICAgICAgICAgICAgICAgICAgICAgICAgX3RvcC5kb1Njcm9sbChcImxlZnRcIik7XG5cdCAgICAgICAgICAgICAgICAgICAgfSBjYXRjaChlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkZWZlciggZG9TY3JvbGxDaGVjaywgNTAgKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICBcblx0ICAgICAgICAgICAgICAgICAgICAvLyBkZXRhY2ggYWxsIGRvbSByZWFkeSBldmVudHNcblx0ICAgICAgICAgICAgICAgICAgICBkZXRhY2goKTtcblx0ICAgIFxuXHQgICAgICAgICAgICAgICAgICAgIC8vIGFuZCBleGVjdXRlIGFueSB3YWl0aW5nIGZ1bmN0aW9uc1xuXHQgICAgICAgICAgICAgICAgICAgIHJlYWR5KCk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0pKCk7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHQgICAgXG5cdCAgICBmdW5jdGlvbiBvbkRvbVJlYWR5KCBmbiApIHtcblx0ICAgICAgICAvLyBJZiBET00gaXMgcmVhZHksIGV4ZWN1dGUgdGhlIGZ1bmN0aW9uIChhc3luYyksIG90aGVyd2lzZSB3YWl0XG5cdCAgICAgICAgaXNSZWFkeSA/IGRlZmVyKCBmbiApIDogY2FsbGJhY2tzLnB1c2goIGZuICk7XG5cdCAgICB9XG5cdCAgICBcblx0ICAgIC8vIEFkZCB2ZXJzaW9uXG5cdCAgICBvbkRvbVJlYWR5LnZlcnNpb24gPSBcIjEuNC4wXCI7XG5cdCAgICAvLyBBZGQgbWV0aG9kIHRvIGNoZWNrIGlmIERPTSBpcyByZWFkeVxuXHQgICAgb25Eb21SZWFkeS5pc1JlYWR5ID0gZnVuY3Rpb24oKXtcblx0ICAgICAgICByZXR1cm4gaXNSZWFkeTtcblx0ICAgIH07XG5cblx0ICAgIHJldHVybiBvbkRvbVJlYWR5O1xuXHR9XG5cblx0bW9kdWxlLmV4cG9ydHMgPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIF9vbkRvbVJlYWR5KHdpbmRvdyk7XG5cbi8qKiovIH0pLFxuLyogMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdC8vTW9kaWZpZWQgdmVyc2lvbiBvZiBjb21wb25lbnQvcXVlcnlzdHJpbmdcblx0Ly9DaGFuZ2VzOiB1cGRhdGVkIGRlcGVuZGVuY2llcywgZG90IG5vdGF0aW9uIHBhcnNpbmcsIEpTSGludCBmaXhlc1xuXHQvL0ZvcmsgYXQgaHR0cHM6Ly9naXRodWIuY29tL2ltc2t5L3F1ZXJ5c3RyaW5nXG5cblx0LyoqXG5cdCAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG5cdCAqL1xuXG5cdHZhciBlbmNvZGUgPSBlbmNvZGVVUklDb21wb25lbnQ7XG5cdHZhciBkZWNvZGUgPSBkZWNvZGVVUklDb21wb25lbnQ7XG5cdHZhciB0cmltID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblx0dmFyIHR5cGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuXG5cdHZhciBhcnJheVJlZ2V4ID0gLyhcXHcrKVxcWyhcXGQrKVxcXS87XG5cdHZhciBvYmplY3RSZWdleCA9IC9cXHcrXFwuXFx3Ky87XG5cblx0LyoqXG5cdCAqIFBhcnNlIHRoZSBnaXZlbiBxdWVyeSBgc3RyYC5cblx0ICpcblx0ICogQHBhcmFtIHtTdHJpbmd9IHN0clxuXHQgKiBAcmV0dXJuIHtPYmplY3R9XG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXG5cdGV4cG9ydHMucGFyc2UgPSBmdW5jdGlvbihzdHIpe1xuXHQgIGlmICgnc3RyaW5nJyAhPT0gdHlwZW9mIHN0cikgcmV0dXJuIHt9O1xuXG5cdCAgc3RyID0gdHJpbShzdHIpO1xuXHQgIGlmICgnJyA9PT0gc3RyKSByZXR1cm4ge307XG5cdCAgaWYgKCc/JyA9PT0gc3RyLmNoYXJBdCgwKSkgc3RyID0gc3RyLnNsaWNlKDEpO1xuXG5cdCAgdmFyIG9iaiA9IHt9O1xuXHQgIHZhciBwYWlycyA9IHN0ci5zcGxpdCgnJicpO1xuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFpcnMubGVuZ3RoOyBpKyspIHtcblx0ICAgIHZhciBwYXJ0cyA9IHBhaXJzW2ldLnNwbGl0KCc9Jyk7XG5cdCAgICB2YXIga2V5ID0gZGVjb2RlKHBhcnRzWzBdKTtcblx0ICAgIHZhciBtLCBjdHgsIHByb3A7XG5cblx0ICAgIGlmIChtID0gYXJyYXlSZWdleC5leGVjKGtleSkpIHtcblx0ICAgICAgb2JqW21bMV1dID0gb2JqW21bMV1dIHx8IFtdO1xuXHQgICAgICBvYmpbbVsxXV1bbVsyXV0gPSBkZWNvZGUocGFydHNbMV0pO1xuXHQgICAgICBjb250aW51ZTtcblx0ICAgIH1cblxuXHQgICAgaWYgKG0gPSBvYmplY3RSZWdleC50ZXN0KGtleSkpIHtcblx0ICAgICAgbSA9IGtleS5zcGxpdCgnLicpO1xuXHQgICAgICBjdHggPSBvYmo7XG5cdCAgICAgIFxuXHQgICAgICB3aGlsZSAobS5sZW5ndGgpIHtcblx0ICAgICAgICBwcm9wID0gbS5zaGlmdCgpO1xuXG5cdCAgICAgICAgaWYgKCFwcm9wLmxlbmd0aCkgY29udGludWU7XG5cblx0ICAgICAgICBpZiAoIWN0eFtwcm9wXSkge1xuXHQgICAgICAgICAgY3R4W3Byb3BdID0ge307XG5cdCAgICAgICAgfSBlbHNlIGlmIChjdHhbcHJvcF0gJiYgdHlwZW9mIGN0eFtwcm9wXSAhPT0gJ29iamVjdCcpIHtcblx0ICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGlmICghbS5sZW5ndGgpIHtcblx0ICAgICAgICAgIGN0eFtwcm9wXSA9IGRlY29kZShwYXJ0c1sxXSk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgY3R4ID0gY3R4W3Byb3BdO1xuXHQgICAgICB9XG5cblx0ICAgICAgY29udGludWU7XG5cdCAgICB9XG5cblx0ICAgIG9ialtwYXJ0c1swXV0gPSBudWxsID09IHBhcnRzWzFdID8gJycgOiBkZWNvZGUocGFydHNbMV0pO1xuXHQgIH1cblxuXHQgIHJldHVybiBvYmo7XG5cdH07XG5cblx0LyoqXG5cdCAqIFN0cmluZ2lmeSB0aGUgZ2l2ZW4gYG9iamAuXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcblx0ICogQHJldHVybiB7U3RyaW5nfVxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblxuXHRleHBvcnRzLnN0cmluZ2lmeSA9IGZ1bmN0aW9uKG9iail7XG5cdCAgaWYgKCFvYmopIHJldHVybiAnJztcblx0ICB2YXIgcGFpcnMgPSBbXTtcblxuXHQgIGZvciAodmFyIGtleSBpbiBvYmopIHtcblx0ICAgIHZhciB2YWx1ZSA9IG9ialtrZXldO1xuXG5cdCAgICBpZiAoJ2FycmF5JyA9PSB0eXBlKHZhbHVlKSkge1xuXHQgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgKytpKSB7XG5cdCAgICAgICAgcGFpcnMucHVzaChlbmNvZGUoa2V5ICsgJ1snICsgaSArICddJykgKyAnPScgKyBlbmNvZGUodmFsdWVbaV0pKTtcblx0ICAgICAgfVxuXHQgICAgICBjb250aW51ZTtcblx0ICAgIH1cblxuXHQgICAgcGFpcnMucHVzaChlbmNvZGUoa2V5KSArICc9JyArIGVuY29kZShvYmpba2V5XSkpO1xuXHQgIH1cblxuXHQgIHJldHVybiBwYWlycy5qb2luKCcmJyk7XG5cdH07XG5cblxuLyoqKi8gfSksXG4vKiA0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0XG5cdGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHRyaW07XG5cblx0ZnVuY3Rpb24gdHJpbShzdHIpe1xuXHQgIHJldHVybiBzdHIucmVwbGFjZSgvXlxccyp8XFxzKiQvZywgJycpO1xuXHR9XG5cblx0ZXhwb3J0cy5sZWZ0ID0gZnVuY3Rpb24oc3RyKXtcblx0ICByZXR1cm4gc3RyLnJlcGxhY2UoL15cXHMqLywgJycpO1xuXHR9O1xuXG5cdGV4cG9ydHMucmlnaHQgPSBmdW5jdGlvbihzdHIpe1xuXHQgIHJldHVybiBzdHIucmVwbGFjZSgvXFxzKiQvLCAnJyk7XG5cdH07XG5cblxuLyoqKi8gfSksXG4vKiA1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0LyoqXG5cdCAqIHRvU3RyaW5nIHJlZi5cblx0ICovXG5cblx0dmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuXHQvKipcblx0ICogUmV0dXJuIHRoZSB0eXBlIG9mIGB2YWxgLlxuXHQgKlxuXHQgKiBAcGFyYW0ge01peGVkfSB2YWxcblx0ICogQHJldHVybiB7U3RyaW5nfVxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblxuXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHZhbCl7XG5cdCAgc3dpdGNoICh0b1N0cmluZy5jYWxsKHZhbCkpIHtcblx0ICAgIGNhc2UgJ1tvYmplY3QgRGF0ZV0nOiByZXR1cm4gJ2RhdGUnO1xuXHQgICAgY2FzZSAnW29iamVjdCBSZWdFeHBdJzogcmV0dXJuICdyZWdleHAnO1xuXHQgICAgY2FzZSAnW29iamVjdCBBcmd1bWVudHNdJzogcmV0dXJuICdhcmd1bWVudHMnO1xuXHQgICAgY2FzZSAnW29iamVjdCBBcnJheV0nOiByZXR1cm4gJ2FycmF5Jztcblx0ICAgIGNhc2UgJ1tvYmplY3QgRXJyb3JdJzogcmV0dXJuICdlcnJvcic7XG5cdCAgfVxuXG5cdCAgaWYgKHZhbCA9PT0gbnVsbCkgcmV0dXJuICdudWxsJztcblx0ICBpZiAodmFsID09PSB1bmRlZmluZWQpIHJldHVybiAndW5kZWZpbmVkJztcblx0ICBpZiAodmFsICE9PSB2YWwpIHJldHVybiAnbmFuJztcblx0ICBpZiAodmFsICYmIHZhbC5ub2RlVHlwZSA9PT0gMSkgcmV0dXJuICdlbGVtZW50JztcblxuXHQgIHZhbCA9IHZhbC52YWx1ZU9mXG5cdCAgICA/IHZhbC52YWx1ZU9mKClcblx0ICAgIDogT2JqZWN0LnByb3RvdHlwZS52YWx1ZU9mLmFwcGx5KHZhbClcblxuXHQgIHJldHVybiB0eXBlb2YgdmFsO1xuXHR9O1xuXG5cbi8qKiovIH0pLFxuLyogNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdHZhciBTY2VuZUdyYXBoID0gZnVuY3Rpb24oc2NlbmVQcm9wZXJ0aWVzKSB7XG5cdCAgICB2YXIgbm9kZUNvdW50ID0gMTtcblxuXHQgICAgLy90b2RvOiBtb3ZlIG1lcmdlIHRvIGhlbHBlcnMgc2VjdGlvblxuXHQgICAgZnVuY3Rpb24gbWVyZ2UocGFyZW50LCBjaGlsZCkge1xuXHQgICAgICAgIGZvciAodmFyIHByb3AgaW4gY2hpbGQpIHtcblx0ICAgICAgICAgICAgcGFyZW50W3Byb3BdID0gY2hpbGRbcHJvcF07XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBwYXJlbnQ7XG5cdCAgICB9XG5cblx0ICAgIHZhciBTY2VuZU5vZGUgPSBmdW5jdGlvbihuYW1lKSB7XG5cdCAgICAgICAgbm9kZUNvdW50Kys7XG5cdCAgICAgICAgdGhpcy5wYXJlbnQgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuY2hpbGRyZW4gPSB7fTtcblx0ICAgICAgICB0aGlzLmlkID0gbm9kZUNvdW50O1xuXHQgICAgICAgIHRoaXMubmFtZSA9ICduJyArIG5vZGVDb3VudDtcblx0ICAgICAgICBpZiAodHlwZW9mIG5hbWUgIT09ICd1bmRlZmluZWQnKSB7XG5cdCAgICAgICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHRoaXMueCA9IHRoaXMueSA9IHRoaXMueiA9IDA7XG5cdCAgICAgICAgdGhpcy53aWR0aCA9IHRoaXMuaGVpZ2h0ID0gMDtcblx0ICAgIH07XG5cblx0ICAgIFNjZW5lTm9kZS5wcm90b3R5cGUucmVzaXplID0gZnVuY3Rpb24od2lkdGgsIGhlaWdodCkge1xuXHQgICAgICAgIGlmICh3aWR0aCAhPSBudWxsKSB7XG5cdCAgICAgICAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKGhlaWdodCAhPSBudWxsKSB7XG5cdCAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cblx0ICAgIFNjZW5lTm9kZS5wcm90b3R5cGUubW92ZVRvID0gZnVuY3Rpb24oeCwgeSwgeikge1xuXHQgICAgICAgIHRoaXMueCA9IHggIT0gbnVsbCA/IHggOiB0aGlzLng7XG5cdCAgICAgICAgdGhpcy55ID0geSAhPSBudWxsID8geSA6IHRoaXMueTtcblx0ICAgICAgICB0aGlzLnogPSB6ICE9IG51bGwgPyB6IDogdGhpcy56O1xuXHQgICAgfTtcblxuXHQgICAgU2NlbmVOb2RlLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbihjaGlsZCkge1xuXHQgICAgICAgIHZhciBuYW1lID0gY2hpbGQubmFtZTtcblx0ICAgICAgICBpZiAodHlwZW9mIHRoaXMuY2hpbGRyZW5bbmFtZV0gPT09ICd1bmRlZmluZWQnKSB7XG5cdCAgICAgICAgICAgIHRoaXMuY2hpbGRyZW5bbmFtZV0gPSBjaGlsZDtcblx0ICAgICAgICAgICAgY2hpbGQucGFyZW50ID0gdGhpcztcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICB0aHJvdyAnU2NlbmVHcmFwaDogY2hpbGQgYWxyZWFkeSBleGlzdHM6ICcgKyBuYW1lO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cblx0ICAgIHZhciBSb290Tm9kZSA9IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgIFNjZW5lTm9kZS5jYWxsKHRoaXMsICdyb290Jyk7XG5cdCAgICAgICAgdGhpcy5wcm9wZXJ0aWVzID0gc2NlbmVQcm9wZXJ0aWVzO1xuXHQgICAgfTtcblxuXHQgICAgUm9vdE5vZGUucHJvdG90eXBlID0gbmV3IFNjZW5lTm9kZSgpO1xuXG5cdCAgICB2YXIgU2hhcGUgPSBmdW5jdGlvbihuYW1lLCBwcm9wcykge1xuXHQgICAgICAgIFNjZW5lTm9kZS5jYWxsKHRoaXMsIG5hbWUpO1xuXHQgICAgICAgIHRoaXMucHJvcGVydGllcyA9IHtcblx0ICAgICAgICAgICAgJ2ZpbGwnOiAnIzAwMDAwMCdcblx0ICAgICAgICB9O1xuXHQgICAgICAgIGlmICh0eXBlb2YgcHJvcHMgIT09ICd1bmRlZmluZWQnKSB7XG5cdCAgICAgICAgICAgIG1lcmdlKHRoaXMucHJvcGVydGllcywgcHJvcHMpO1xuXHQgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG5hbWUgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJykge1xuXHQgICAgICAgICAgICB0aHJvdyAnU2NlbmVHcmFwaDogaW52YWxpZCBub2RlIG5hbWUnO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cblx0ICAgIFNoYXBlLnByb3RvdHlwZSA9IG5ldyBTY2VuZU5vZGUoKTtcblxuXHQgICAgdmFyIEdyb3VwID0gZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgU2hhcGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0ICAgICAgICB0aGlzLnR5cGUgPSAnZ3JvdXAnO1xuXHQgICAgfTtcblxuXHQgICAgR3JvdXAucHJvdG90eXBlID0gbmV3IFNoYXBlKCk7XG5cblx0ICAgIHZhciBSZWN0ID0gZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgU2hhcGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0ICAgICAgICB0aGlzLnR5cGUgPSAncmVjdCc7XG5cdCAgICB9O1xuXG5cdCAgICBSZWN0LnByb3RvdHlwZSA9IG5ldyBTaGFwZSgpO1xuXG5cdCAgICB2YXIgVGV4dCA9IGZ1bmN0aW9uKHRleHQpIHtcblx0ICAgICAgICBTaGFwZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMudHlwZSA9ICd0ZXh0Jztcblx0ICAgICAgICB0aGlzLnByb3BlcnRpZXMudGV4dCA9IHRleHQ7XG5cdCAgICB9O1xuXG5cdCAgICBUZXh0LnByb3RvdHlwZSA9IG5ldyBTaGFwZSgpO1xuXG5cdCAgICB2YXIgcm9vdCA9IG5ldyBSb290Tm9kZSgpO1xuXG5cdCAgICB0aGlzLlNoYXBlID0ge1xuXHQgICAgICAgICdSZWN0JzogUmVjdCxcblx0ICAgICAgICAnVGV4dCc6IFRleHQsXG5cdCAgICAgICAgJ0dyb3VwJzogR3JvdXBcblx0ICAgIH07XG5cblx0ICAgIHRoaXMucm9vdCA9IHJvb3Q7XG5cdCAgICByZXR1cm4gdGhpcztcblx0fTtcblxuXHRtb2R1bGUuZXhwb3J0cyA9IFNjZW5lR3JhcGg7XG5cblxuLyoqKi8gfSksXG4vKiA3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0LyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovKGZ1bmN0aW9uKGdsb2JhbCkgey8qKlxuXHQgKiBTaGFsbG93IG9iamVjdCBjbG9uZSBhbmQgbWVyZ2Vcblx0ICpcblx0ICogQHBhcmFtIGEgT2JqZWN0IEFcblx0ICogQHBhcmFtIGIgT2JqZWN0IEJcblx0ICogQHJldHVybnMge09iamVjdH0gTmV3IG9iamVjdCB3aXRoIGFsbCBvZiBBJ3MgcHJvcGVydGllcywgYW5kIGFsbCBvZiBCJ3MgcHJvcGVydGllcywgb3ZlcndyaXRpbmcgQSdzIHByb3BlcnRpZXNcblx0ICovXG5cdGV4cG9ydHMuZXh0ZW5kID0gZnVuY3Rpb24oYSwgYikge1xuXHQgICAgdmFyIGMgPSB7fTtcblx0ICAgIGZvciAodmFyIHggaW4gYSkge1xuXHQgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYSx4KSkge1xuXHQgICAgICAgICAgICBjW3hdID0gYVt4XTtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cdCAgICBpZiAoYiAhPSBudWxsKSB7XG5cdCAgICAgICAgZm9yICh2YXIgeSBpbiBiKSB7XG5cdCAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgeSkpIHtcblx0ICAgICAgICAgICAgICAgIGNbeV0gPSBiW3ldO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHQgICAgcmV0dXJuIGM7XG5cdH07XG5cblx0LyoqXG5cdCAqIFRha2VzIGEgay92IGxpc3Qgb2YgQ1NTIHByb3BlcnRpZXMgYW5kIHJldHVybnMgYSBydWxlXG5cdCAqXG5cdCAqIEBwYXJhbSBwcm9wcyBDU1MgcHJvcGVydGllcyBvYmplY3Rcblx0ICovXG5cdGV4cG9ydHMuY3NzUHJvcHMgPSBmdW5jdGlvbihwcm9wcykge1xuXHQgICAgdmFyIHJldCA9IFtdO1xuXHQgICAgZm9yICh2YXIgcCBpbiBwcm9wcykge1xuXHQgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocHJvcHMsIHApKSB7XG5cdCAgICAgICAgICAgIHJldC5wdXNoKHAgKyAnOicgKyBwcm9wc1twXSk7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHQgICAgcmV0dXJuIHJldC5qb2luKCc7Jyk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEVuY29kZXMgSFRNTCBlbnRpdGllcyBpbiBhIHN0cmluZ1xuXHQgKlxuXHQgKiBAcGFyYW0gc3RyIElucHV0IHN0cmluZ1xuXHQgKi9cblx0ZXhwb3J0cy5lbmNvZGVIdG1sRW50aXR5ID0gZnVuY3Rpb24oc3RyKSB7XG5cdCAgICB2YXIgYnVmID0gW107XG5cdCAgICB2YXIgY2hhckNvZGUgPSAwO1xuXHQgICAgZm9yICh2YXIgaSA9IHN0ci5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHQgICAgICAgIGNoYXJDb2RlID0gc3RyLmNoYXJDb2RlQXQoaSk7XG5cdCAgICAgICAgaWYgKGNoYXJDb2RlID4gMTI4KSB7XG5cdCAgICAgICAgICAgIGJ1Zi51bnNoaWZ0KFsnJiMnLCBjaGFyQ29kZSwgJzsnXS5qb2luKCcnKSk7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgYnVmLnVuc2hpZnQoc3RyW2ldKTtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cdCAgICByZXR1cm4gYnVmLmpvaW4oJycpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBDaGVja3MgaWYgYW4gaW1hZ2UgZXhpc3RzXG5cdCAqXG5cdCAqIEBwYXJhbSBzcmMgVVJMIG9mIGltYWdlXG5cdCAqIEBwYXJhbSBjYWxsYmFjayBDYWxsYmFjayB0byBjYWxsIG9uY2UgaW1hZ2Ugc3RhdHVzIGhhcyBiZWVuIGZvdW5kXG5cdCAqL1xuXHRleHBvcnRzLmltYWdlRXhpc3RzID0gZnVuY3Rpb24oc3JjLCBjYWxsYmFjaykge1xuXHQgICAgdmFyIGltYWdlID0gbmV3IEltYWdlKCk7XG5cdCAgICBpbWFnZS5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgY2FsbGJhY2suY2FsbCh0aGlzLCBmYWxzZSk7XG5cdCAgICB9O1xuXHQgICAgaW1hZ2Uub25sb2FkID0gZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgY2FsbGJhY2suY2FsbCh0aGlzLCB0cnVlKTtcblx0ICAgIH07XG5cdCAgICBpbWFnZS5zcmMgPSBzcmM7XG5cdH07XG5cblx0LyoqXG5cdCAqIERlY29kZXMgSFRNTCBlbnRpdGllcyBpbiBhIHN0cmluZ1xuXHQgKlxuXHQgKiBAcGFyYW0gc3RyIElucHV0IHN0cmluZ1xuXHQgKi9cblx0ZXhwb3J0cy5kZWNvZGVIdG1sRW50aXR5ID0gZnVuY3Rpb24oc3RyKSB7XG5cdCAgICByZXR1cm4gc3RyLnJlcGxhY2UoLyYjKFxcZCspOy9nLCBmdW5jdGlvbihtYXRjaCwgZGVjKSB7XG5cdCAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoZGVjKTtcblx0ICAgIH0pO1xuXHR9O1xuXG5cblx0LyoqXG5cdCAqIFJldHVybnMgYW4gZWxlbWVudCdzIGRpbWVuc2lvbnMgaWYgaXQncyB2aXNpYmxlLCBgZmFsc2VgIG90aGVyd2lzZS5cblx0ICpcblx0ICogQHBhcmFtIGVsIERPTSBlbGVtZW50XG5cdCAqL1xuXHRleHBvcnRzLmRpbWVuc2lvbkNoZWNrID0gZnVuY3Rpb24oZWwpIHtcblx0ICAgIHZhciBkaW1lbnNpb25zID0ge1xuXHQgICAgICAgIGhlaWdodDogZWwuY2xpZW50SGVpZ2h0LFxuXHQgICAgICAgIHdpZHRoOiBlbC5jbGllbnRXaWR0aFxuXHQgICAgfTtcblxuXHQgICAgaWYgKGRpbWVuc2lvbnMuaGVpZ2h0ICYmIGRpbWVuc2lvbnMud2lkdGgpIHtcblx0ICAgICAgICByZXR1cm4gZGltZW5zaW9ucztcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgfVxuXHR9O1xuXG5cblx0LyoqXG5cdCAqIFJldHVybnMgdHJ1ZSBpZiB2YWx1ZSBpcyB0cnV0aHkgb3IgaWYgaXQgaXMgXCJzZW1hbnRpY2FsbHkgdHJ1dGh5XCJcblx0ICogQHBhcmFtIHZhbFxuXHQgKi9cblx0ZXhwb3J0cy50cnV0aHkgPSBmdW5jdGlvbih2YWwpIHtcblx0ICAgIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuXHQgICAgICAgIHJldHVybiB2YWwgPT09ICd0cnVlJyB8fCB2YWwgPT09ICd5ZXMnIHx8IHZhbCA9PT0gJzEnIHx8IHZhbCA9PT0gJ29uJyB8fCB2YWwgPT09ICfinJMnO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuICEhdmFsO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBQYXJzZXMgaW5wdXQgaW50byBhIHdlbGwtZm9ybWVkIENTUyBjb2xvclxuXHQgKiBAcGFyYW0gdmFsXG5cdCAqL1xuXHRleHBvcnRzLnBhcnNlQ29sb3IgPSBmdW5jdGlvbih2YWwpIHtcblx0ICAgIHZhciBoZXhyZSA9IC8oXig/OiM/KVswLTlhLWZdezZ9JCl8KF4oPzojPylbMC05YS1mXXszfSQpL2k7XG5cdCAgICB2YXIgcmdicmUgPSAvXnJnYlxcKChcXGR7MSwzfSlcXHMqLFxccyooXFxkezEsM30pXFxzKixcXHMqKFxcZHsxLDN9KVxccypcXCkkLztcblx0ICAgIHZhciByZ2JhcmUgPSAvXnJnYmFcXCgoXFxkezEsM30pXFxzKixcXHMqKFxcZHsxLDN9KVxccyosXFxzKihcXGR7MSwzfSlcXHMqLFxccyooMCpcXC5cXGR7MSx9fDEpXFwpJC87XG5cblx0ICAgIHZhciBtYXRjaCA9IHZhbC5tYXRjaChoZXhyZSk7XG5cdCAgICB2YXIgcmV0dmFsO1xuXG5cdCAgICBpZiAobWF0Y2ggIT09IG51bGwpIHtcblx0ICAgICAgICByZXR2YWwgPSBtYXRjaFsxXSB8fCBtYXRjaFsyXTtcblx0ICAgICAgICBpZiAocmV0dmFsWzBdICE9PSAnIycpIHtcblx0ICAgICAgICAgICAgcmV0dXJuICcjJyArIHJldHZhbDtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICByZXR1cm4gcmV0dmFsO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgbWF0Y2ggPSB2YWwubWF0Y2gocmdicmUpO1xuXG5cdCAgICBpZiAobWF0Y2ggIT09IG51bGwpIHtcblx0ICAgICAgICByZXR2YWwgPSAncmdiKCcgKyBtYXRjaC5zbGljZSgxKS5qb2luKCcsJykgKyAnKSc7XG5cdCAgICAgICAgcmV0dXJuIHJldHZhbDtcblx0ICAgIH1cblxuXHQgICAgbWF0Y2ggPSB2YWwubWF0Y2gocmdiYXJlKTtcblxuXHQgICAgaWYgKG1hdGNoICE9PSBudWxsKSB7XG5cdCAgICAgICAgdmFyIG5vcm1hbGl6ZUFscGhhID0gZnVuY3Rpb24gKGEpIHsgcmV0dXJuICcwLicgKyBhLnNwbGl0KCcuJylbMV07IH07XG5cdCAgICAgICAgdmFyIGZpeGVkTWF0Y2ggPSBtYXRjaC5zbGljZSgxKS5tYXAoZnVuY3Rpb24gKGUsIGkpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIChpID09PSAzKSA/IG5vcm1hbGl6ZUFscGhhKGUpIDogZTtcblx0ICAgICAgICB9KTtcblx0ICAgICAgICByZXR2YWwgPSAncmdiYSgnICsgZml4ZWRNYXRjaC5qb2luKCcsJykgKyAnKSc7XG5cdCAgICAgICAgcmV0dXJuIHJldHZhbDtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIG51bGw7XG5cdH07XG5cblx0LyoqXG5cdCAqIFByb3ZpZGVzIHRoZSBjb3JyZWN0IHNjYWxpbmcgcmF0aW8gZm9yIGNhbnZhcyBkcmF3aW5nIG9wZXJhdGlvbnMgb24gSGlEUEkgc2NyZWVucyAoZS5nLiBSZXRpbmEgZGlzcGxheXMpXG5cdCAqL1xuXHRleHBvcnRzLmNhbnZhc1JhdGlvID0gZnVuY3Rpb24gKCkge1xuXHQgICAgdmFyIGRldmljZVBpeGVsUmF0aW8gPSAxO1xuXHQgICAgdmFyIGJhY2tpbmdTdG9yZVJhdGlvID0gMTtcblxuXHQgICAgaWYgKGdsb2JhbC5kb2N1bWVudCkge1xuXHQgICAgICAgIHZhciBjYW52YXMgPSBnbG9iYWwuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG5cdCAgICAgICAgaWYgKGNhbnZhcy5nZXRDb250ZXh0KSB7XG5cdCAgICAgICAgICAgIHZhciBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcblx0ICAgICAgICAgICAgZGV2aWNlUGl4ZWxSYXRpbyA9IGdsb2JhbC5kZXZpY2VQaXhlbFJhdGlvIHx8IDE7XG5cdCAgICAgICAgICAgIGJhY2tpbmdTdG9yZVJhdGlvID0gY3R4LndlYmtpdEJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgY3R4Lm1vekJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgY3R4Lm1zQmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fCBjdHgub0JhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgY3R4LmJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgMTtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBkZXZpY2VQaXhlbFJhdGlvIC8gYmFja2luZ1N0b3JlUmF0aW87XG5cdH07XG5cblx0LyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovfS5jYWxsKGV4cG9ydHMsIChmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0oKSkpKVxuXG4vKioqLyB9KSxcbi8qIDggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQvKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi8oZnVuY3Rpb24oZ2xvYmFsKSB7dmFyIERPTSA9IF9fd2VicGFja19yZXF1aXJlX18oOSk7XG5cblx0dmFyIFNWR19OUyA9ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Zyc7XG5cdHZhciBOT0RFX1RZUEVfQ09NTUVOVCA9IDg7XG5cblx0LyoqXG5cdCAqIEdlbmVyaWMgU1ZHIGVsZW1lbnQgY3JlYXRpb24gZnVuY3Rpb25cblx0ICpcblx0ICogQHBhcmFtIHN2ZyBTVkcgY29udGV4dCwgc2V0IHRvIG51bGwgaWYgbmV3XG5cdCAqIEBwYXJhbSB3aWR0aCBEb2N1bWVudCB3aWR0aFxuXHQgKiBAcGFyYW0gaGVpZ2h0IERvY3VtZW50IGhlaWdodFxuXHQgKi9cblx0ZXhwb3J0cy5pbml0U1ZHID0gZnVuY3Rpb24oc3ZnLCB3aWR0aCwgaGVpZ2h0KSB7XG5cdCAgICB2YXIgZGVmcywgc3R5bGUsIGluaXRpYWxpemUgPSBmYWxzZTtcblxuXHQgICAgaWYgKHN2ZyAmJiBzdmcucXVlcnlTZWxlY3Rvcikge1xuXHQgICAgICAgIHN0eWxlID0gc3ZnLnF1ZXJ5U2VsZWN0b3IoJ3N0eWxlJyk7XG5cdCAgICAgICAgaWYgKHN0eWxlID09PSBudWxsKSB7XG5cdCAgICAgICAgICAgIGluaXRpYWxpemUgPSB0cnVlO1xuXHQgICAgICAgIH1cblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgICAgc3ZnID0gRE9NLm5ld0VsKCdzdmcnLCBTVkdfTlMpO1xuXHQgICAgICAgIGluaXRpYWxpemUgPSB0cnVlO1xuXHQgICAgfVxuXG5cdCAgICBpZiAoaW5pdGlhbGl6ZSkge1xuXHQgICAgICAgIGRlZnMgPSBET00ubmV3RWwoJ2RlZnMnLCBTVkdfTlMpO1xuXHQgICAgICAgIHN0eWxlID0gRE9NLm5ld0VsKCdzdHlsZScsIFNWR19OUyk7XG5cdCAgICAgICAgRE9NLnNldEF0dHIoc3R5bGUsIHtcblx0ICAgICAgICAgICAgJ3R5cGUnOiAndGV4dC9jc3MnXG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgZGVmcy5hcHBlbmRDaGlsZChzdHlsZSk7XG5cdCAgICAgICAgc3ZnLmFwcGVuZENoaWxkKGRlZnMpO1xuXHQgICAgfVxuXG5cdCAgICAvL0lFIHRocm93cyBhbiBleGNlcHRpb24gaWYgdGhpcyBpcyBzZXQgYW5kIENocm9tZSByZXF1aXJlcyBpdCB0byBiZSBzZXRcblx0ICAgIGlmIChzdmcud2Via2l0TWF0Y2hlc1NlbGVjdG9yKSB7XG5cdCAgICAgICAgc3ZnLnNldEF0dHJpYnV0ZSgneG1sbnMnLCBTVkdfTlMpO1xuXHQgICAgfVxuXG5cdCAgICAvL1JlbW92ZSBjb21tZW50IG5vZGVzXG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN2Zy5jaGlsZE5vZGVzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgaWYgKHN2Zy5jaGlsZE5vZGVzW2ldLm5vZGVUeXBlID09PSBOT0RFX1RZUEVfQ09NTUVOVCkge1xuXHQgICAgICAgICAgICBzdmcucmVtb3ZlQ2hpbGQoc3ZnLmNoaWxkTm9kZXNbaV0pO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgLy9SZW1vdmUgQ1NTXG5cdCAgICB3aGlsZSAoc3R5bGUuY2hpbGROb2Rlcy5sZW5ndGgpIHtcblx0ICAgICAgICBzdHlsZS5yZW1vdmVDaGlsZChzdHlsZS5jaGlsZE5vZGVzWzBdKTtcblx0ICAgIH1cblxuXHQgICAgRE9NLnNldEF0dHIoc3ZnLCB7XG5cdCAgICAgICAgJ3dpZHRoJzogd2lkdGgsXG5cdCAgICAgICAgJ2hlaWdodCc6IGhlaWdodCxcblx0ICAgICAgICAndmlld0JveCc6ICcwIDAgJyArIHdpZHRoICsgJyAnICsgaGVpZ2h0LFxuXHQgICAgICAgICdwcmVzZXJ2ZUFzcGVjdFJhdGlvJzogJ25vbmUnXG5cdCAgICB9KTtcblxuXHQgICAgcmV0dXJuIHN2Zztcblx0fTtcblxuXHQvKipcblx0ICogQ29udmVydHMgc2VyaWFsaXplZCBTVkcgdG8gYSBzdHJpbmcgc3VpdGFibGUgZm9yIGRhdGEgVVJJIHVzZVxuXHQgKiBAcGFyYW0gc3ZnU3RyaW5nIFNlcmlhbGl6ZWQgU1ZHIHN0cmluZ1xuXHQgKiBAcGFyYW0gW2Jhc2U2NF0gVXNlIGJhc2U2NCBlbmNvZGluZyBmb3IgZGF0YSBVUklcblx0ICovXG5cdGV4cG9ydHMuc3ZnU3RyaW5nVG9EYXRhVVJJID0gZnVuY3Rpb24oKSB7XG5cdCAgICB2YXIgcmF3UHJlZml4ID0gJ2RhdGE6aW1hZ2Uvc3ZnK3htbDtjaGFyc2V0PVVURi04LCc7XG5cdCAgICB2YXIgYmFzZTY0UHJlZml4ID0gJ2RhdGE6aW1hZ2Uvc3ZnK3htbDtjaGFyc2V0PVVURi04O2Jhc2U2NCwnO1xuXG5cdCAgICByZXR1cm4gZnVuY3Rpb24oc3ZnU3RyaW5nLCBiYXNlNjQpIHtcblx0ICAgICAgICBpZiAoYmFzZTY0KSB7XG5cdCAgICAgICAgICAgIHJldHVybiBiYXNlNjRQcmVmaXggKyBidG9hKGdsb2JhbC51bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoc3ZnU3RyaW5nKSkpO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIHJldHVybiByYXdQcmVmaXggKyBlbmNvZGVVUklDb21wb25lbnQoc3ZnU3RyaW5nKTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHR9KCk7XG5cblx0LyoqXG5cdCAqIFJldHVybnMgc2VyaWFsaXplZCBTVkcgd2l0aCBYTUwgcHJvY2Vzc2luZyBpbnN0cnVjdGlvbnNcblx0ICpcblx0ICogQHBhcmFtIHN2ZyBTVkcgY29udGV4dFxuXHQgKiBAcGFyYW0gc3R5bGVzaGVldHMgQ1NTIHN0eWxlc2hlZXRzIHRvIGluY2x1ZGVcblx0ICovXG5cdGV4cG9ydHMuc2VyaWFsaXplU1ZHID0gZnVuY3Rpb24oc3ZnLCBlbmdpbmVTZXR0aW5ncykge1xuXHQgICAgaWYgKCFnbG9iYWwuWE1MU2VyaWFsaXplcikgcmV0dXJuO1xuXHQgICAgdmFyIHNlcmlhbGl6ZXIgPSBuZXcgWE1MU2VyaWFsaXplcigpO1xuXHQgICAgdmFyIHN2Z0NTUyA9ICcnO1xuXHQgICAgdmFyIHN0eWxlc2hlZXRzID0gZW5naW5lU2V0dGluZ3Muc3R5bGVzaGVldHM7XG5cblx0ICAgIC8vRXh0ZXJuYWwgc3R5bGVzaGVldHM6IFByb2Nlc3NpbmcgSW5zdHJ1Y3Rpb24gbWV0aG9kXG5cdCAgICBpZiAoZW5naW5lU2V0dGluZ3Muc3ZnWE1MU3R5bGVzaGVldCkge1xuXHQgICAgICAgIHZhciB4bWwgPSBET00uY3JlYXRlWE1MKCk7XG5cdCAgICAgICAgLy9BZGQgPD94bWwtc3R5bGVzaGVldCA/PiBkaXJlY3RpdmVzXG5cdCAgICAgICAgZm9yICh2YXIgaSA9IHN0eWxlc2hlZXRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdCAgICAgICAgICAgIHZhciBjc3NwaSA9IHhtbC5jcmVhdGVQcm9jZXNzaW5nSW5zdHJ1Y3Rpb24oJ3htbC1zdHlsZXNoZWV0JywgJ2hyZWY9XCInICsgc3R5bGVzaGVldHNbaV0gKyAnXCIgcmVsPVwic3R5bGVzaGVldFwiJyk7XG5cdCAgICAgICAgICAgIHhtbC5pbnNlcnRCZWZvcmUoY3NzcGksIHhtbC5maXJzdENoaWxkKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICB4bWwucmVtb3ZlQ2hpbGQoeG1sLmRvY3VtZW50RWxlbWVudCk7XG5cdCAgICAgICAgc3ZnQ1NTID0gc2VyaWFsaXplci5zZXJpYWxpemVUb1N0cmluZyh4bWwpO1xuXHQgICAgfVxuXG5cdCAgICB2YXIgc3ZnVGV4dCA9IHNlcmlhbGl6ZXIuc2VyaWFsaXplVG9TdHJpbmcoc3ZnKTtcblx0ICAgIHN2Z1RleHQgPSBzdmdUZXh0LnJlcGxhY2UoLyZhbXA7KCNbMC05XXsyLH07KS9nLCAnJiQxJyk7XG5cdCAgICByZXR1cm4gc3ZnQ1NTICsgc3ZnVGV4dDtcblx0fTtcblxuXHQvKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwoZXhwb3J0cywgKGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSgpKSkpXG5cbi8qKiovIH0pLFxuLyogOSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdC8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihnbG9iYWwpIHsvKipcblx0ICogR2VuZXJpYyBuZXcgRE9NIGVsZW1lbnQgZnVuY3Rpb25cblx0ICpcblx0ICogQHBhcmFtIHRhZyBUYWcgdG8gY3JlYXRlXG5cdCAqIEBwYXJhbSBuYW1lc3BhY2UgT3B0aW9uYWwgbmFtZXNwYWNlIHZhbHVlXG5cdCAqL1xuXHRleHBvcnRzLm5ld0VsID0gZnVuY3Rpb24odGFnLCBuYW1lc3BhY2UpIHtcblx0ICAgIGlmICghZ2xvYmFsLmRvY3VtZW50KSByZXR1cm47XG5cblx0ICAgIGlmIChuYW1lc3BhY2UgPT0gbnVsbCkge1xuXHQgICAgICAgIHJldHVybiBnbG9iYWwuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgICByZXR1cm4gZ2xvYmFsLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhuYW1lc3BhY2UsIHRhZyk7XG5cdCAgICB9XG5cdH07XG5cblx0LyoqXG5cdCAqIEdlbmVyaWMgc2V0QXR0cmlidXRlIGZ1bmN0aW9uXG5cdCAqXG5cdCAqIEBwYXJhbSBlbCBSZWZlcmVuY2UgdG8gRE9NIGVsZW1lbnRcblx0ICogQHBhcmFtIGF0dHJzIE9iamVjdCB3aXRoIGF0dHJpYnV0ZSBrZXlzIGFuZCB2YWx1ZXNcblx0ICovXG5cdGV4cG9ydHMuc2V0QXR0ciA9IGZ1bmN0aW9uIChlbCwgYXR0cnMpIHtcblx0ICAgIGZvciAodmFyIGEgaW4gYXR0cnMpIHtcblx0ICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoYSwgYXR0cnNbYV0pO1xuXHQgICAgfVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGEgWE1MIGRvY3VtZW50XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRleHBvcnRzLmNyZWF0ZVhNTCA9IGZ1bmN0aW9uKCkge1xuXHQgICAgaWYgKCFnbG9iYWwuRE9NUGFyc2VyKSByZXR1cm47XG5cdCAgICByZXR1cm4gbmV3IERPTVBhcnNlcigpLnBhcnNlRnJvbVN0cmluZygnPHhtbCAvPicsICdhcHBsaWNhdGlvbi94bWwnKTtcblx0fTtcblxuXHQvKipcblx0ICogQ29udmVydHMgYSB2YWx1ZSBpbnRvIGFuIGFycmF5IG9mIERPTSBub2Rlc1xuXHQgKlxuXHQgKiBAcGFyYW0gdmFsIEEgc3RyaW5nLCBhIE5vZGVMaXN0LCBhIE5vZGUsIG9yIGFuIEhUTUxDb2xsZWN0aW9uXG5cdCAqL1xuXHRleHBvcnRzLmdldE5vZGVBcnJheSA9IGZ1bmN0aW9uKHZhbCkge1xuXHQgICAgdmFyIHJldHZhbCA9IG51bGw7XG5cdCAgICBpZiAodHlwZW9mKHZhbCkgPT0gJ3N0cmluZycpIHtcblx0ICAgICAgICByZXR2YWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHZhbCk7XG5cdCAgICB9IGVsc2UgaWYgKGdsb2JhbC5Ob2RlTGlzdCAmJiB2YWwgaW5zdGFuY2VvZiBnbG9iYWwuTm9kZUxpc3QpIHtcblx0ICAgICAgICByZXR2YWwgPSB2YWw7XG5cdCAgICB9IGVsc2UgaWYgKGdsb2JhbC5Ob2RlICYmIHZhbCBpbnN0YW5jZW9mIGdsb2JhbC5Ob2RlKSB7XG5cdCAgICAgICAgcmV0dmFsID0gW3ZhbF07XG5cdCAgICB9IGVsc2UgaWYgKGdsb2JhbC5IVE1MQ29sbGVjdGlvbiAmJiB2YWwgaW5zdGFuY2VvZiBnbG9iYWwuSFRNTENvbGxlY3Rpb24pIHtcblx0ICAgICAgICByZXR2YWwgPSB2YWw7XG5cdCAgICB9IGVsc2UgaWYgKHZhbCBpbnN0YW5jZW9mIEFycmF5KSB7XG5cdCAgICAgICAgcmV0dmFsID0gdmFsO1xuXHQgICAgfSBlbHNlIGlmICh2YWwgPT09IG51bGwpIHtcblx0ICAgICAgICByZXR2YWwgPSBbXTtcblx0ICAgIH1cblxuXHQgICAgcmV0dmFsID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwocmV0dmFsKTtcblxuXHQgICAgcmV0dXJuIHJldHZhbDtcblx0fTtcblxuXHQvKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwoZXhwb3J0cywgKGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSgpKSkpXG5cbi8qKiovIH0pLFxuLyogMTAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHR2YXIgQ29sb3IgPSBmdW5jdGlvbihjb2xvciwgb3B0aW9ucykge1xuXHQgICAgLy90b2RvOiBzdXBwb3J0IHJnYmEsIGhzbGEsIGFuZCBycmdnYmJhYSBub3RhdGlvblxuXHQgICAgLy90b2RvOiB1c2UgQ0lFTEFCIGludGVybmFsbHlcblx0ICAgIC8vdG9kbzogYWRkIGNsYW1wIGZ1bmN0aW9uICh3aXRoIHNpZ24pXG5cdCAgICBpZiAodHlwZW9mIGNvbG9yICE9PSAnc3RyaW5nJykgcmV0dXJuO1xuXG5cdCAgICB0aGlzLm9yaWdpbmFsID0gY29sb3I7XG5cblx0ICAgIGlmIChjb2xvci5jaGFyQXQoMCkgPT09ICcjJykge1xuXHQgICAgICAgIGNvbG9yID0gY29sb3Iuc2xpY2UoMSk7XG5cdCAgICB9XG5cblx0ICAgIGlmICgvW15hLWYwLTldKy9pLnRlc3QoY29sb3IpKSByZXR1cm47XG5cblx0ICAgIGlmIChjb2xvci5sZW5ndGggPT09IDMpIHtcblx0ICAgICAgICBjb2xvciA9IGNvbG9yLnJlcGxhY2UoLy4vZywgJyQmJCYnKTtcblx0ICAgIH1cblxuXHQgICAgaWYgKGNvbG9yLmxlbmd0aCAhPT0gNikgcmV0dXJuO1xuXG5cdCAgICB0aGlzLmFscGhhID0gMTtcblxuXHQgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5hbHBoYSkge1xuXHQgICAgICAgIHRoaXMuYWxwaGEgPSBvcHRpb25zLmFscGhhO1xuXHQgICAgfVxuXG5cdCAgICB0aGlzLnNldChwYXJzZUludChjb2xvciwgMTYpKTtcblx0fTtcblxuXHQvL3RvZG86IGpzZG9jc1xuXHRDb2xvci5yZ2IyaGV4ID0gZnVuY3Rpb24ociwgZywgYikge1xuXHQgICAgZnVuY3Rpb24gZm9ybWF0IChkZWNpbWFsKSB7XG5cdCAgICAgICAgdmFyIGhleCA9IChkZWNpbWFsIHwgMCkudG9TdHJpbmcoMTYpO1xuXHQgICAgICAgIGlmIChkZWNpbWFsIDwgMTYpIHtcblx0ICAgICAgICAgICAgaGV4ID0gJzAnICsgaGV4O1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gaGV4O1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gW3IsIGcsIGJdLm1hcChmb3JtYXQpLmpvaW4oJycpO1xuXHR9O1xuXG5cdC8vdG9kbzoganNkb2NzXG5cdENvbG9yLmhzbDJyZ2IgPSBmdW5jdGlvbiAoaCwgcywgbCkge1xuXHQgICAgdmFyIEggPSBoIC8gNjA7XG5cdCAgICB2YXIgQyA9ICgxIC0gTWF0aC5hYnMoMiAqIGwgLSAxKSkgKiBzO1xuXHQgICAgdmFyIFggPSBDICogKDEgLSBNYXRoLmFicyhwYXJzZUludChIKSAlIDIgLSAxKSk7XG5cdCAgICB2YXIgbSA9IGwgLSAoQyAvIDIpO1xuXG5cdCAgICB2YXIgciA9IDAsIGcgPSAwLCBiID0gMDtcblxuXHQgICAgaWYgKEggPj0gMCAmJiBIIDwgMSkge1xuXHQgICAgICAgIHIgPSBDO1xuXHQgICAgICAgIGcgPSBYO1xuXHQgICAgfSBlbHNlIGlmIChIID49IDEgJiYgSCA8IDIpIHtcblx0ICAgICAgICByID0gWDtcblx0ICAgICAgICBnID0gQztcblx0ICAgIH0gZWxzZSBpZiAoSCA+PSAyICYmIEggPCAzKSB7XG5cdCAgICAgICAgZyA9IEM7XG5cdCAgICAgICAgYiA9IFg7XG5cdCAgICB9IGVsc2UgaWYgKEggPj0gMyAmJiBIIDwgNCkge1xuXHQgICAgICAgIGcgPSBYO1xuXHQgICAgICAgIGIgPSBDO1xuXHQgICAgfSBlbHNlIGlmIChIID49IDQgJiYgSCA8IDUpIHtcblx0ICAgICAgICByID0gWDtcblx0ICAgICAgICBiID0gQztcblx0ICAgIH0gZWxzZSBpZiAoSCA+PSA1ICYmIEggPCA2KSB7XG5cdCAgICAgICAgciA9IEM7XG5cdCAgICAgICAgYiA9IFg7XG5cdCAgICB9XG5cblx0ICAgIHIgKz0gbTtcblx0ICAgIGcgKz0gbTtcblx0ICAgIGIgKz0gbTtcblxuXHQgICAgciA9IHBhcnNlSW50KHIgKiAyNTUpO1xuXHQgICAgZyA9IHBhcnNlSW50KGcgKiAyNTUpO1xuXHQgICAgYiA9IHBhcnNlSW50KGIgKiAyNTUpO1xuXG5cdCAgICByZXR1cm4gW3IsIGcsIGJdO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBjb2xvciBmcm9tIGEgcmF3IFJHQjg4OCBpbnRlZ2VyXG5cdCAqIEBwYXJhbSByYXcgUkdCODg4IHJlcHJlc2VudGF0aW9uIG9mIGNvbG9yXG5cdCAqL1xuXHQvL3RvZG86IHJlZmFjdG9yIGludG8gYSBzdGF0aWMgbWV0aG9kXG5cdC8vdG9kbzogZmFjdG9yIG91dCBpbmRpdmlkdWFsIGNvbG9yIHNwYWNlc1xuXHQvL3RvZG86IGFkZCBIU0wsIENJRUxBQiwgYW5kIENJRUxVVlxuXHRDb2xvci5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKHZhbCkge1xuXHQgICAgdGhpcy5yYXcgPSB2YWw7XG5cblx0ICAgIHZhciByID0gKHRoaXMucmF3ICYgMHhGRjAwMDApID4+IDE2O1xuXHQgICAgdmFyIGcgPSAodGhpcy5yYXcgJiAweDAwRkYwMCkgPj4gODtcblx0ICAgIHZhciBiID0gKHRoaXMucmF3ICYgMHgwMDAwRkYpO1xuXG5cdCAgICAvLyBCVC43MDlcblx0ICAgIHZhciB5ID0gMC4yMTI2ICogciArIDAuNzE1MiAqIGcgKyAwLjA3MjIgKiBiO1xuXHQgICAgdmFyIHUgPSAtMC4wOTk5MSAqIHIgLSAwLjMzNjA5ICogZyArIDAuNDM2ICogYjtcblx0ICAgIHZhciB2ID0gMC42MTUgKiByIC0gMC41NTg2MSAqIGcgLSAwLjA1NjM5ICogYjtcblxuXHQgICAgdGhpcy5yZ2IgPSB7XG5cdCAgICAgICAgcjogcixcblx0ICAgICAgICBnOiBnLFxuXHQgICAgICAgIGI6IGJcblx0ICAgIH07XG5cblx0ICAgIHRoaXMueXV2ID0ge1xuXHQgICAgICAgIHk6IHksXG5cdCAgICAgICAgdTogdSxcblx0ICAgICAgICB2OiB2XG5cdCAgICB9O1xuXG5cdCAgICByZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogTGlnaHRlbiBvciBkYXJrZW4gYSBjb2xvclxuXHQgKiBAcGFyYW0gbXVsdGlwbGllciBBbW91bnQgdG8gbGlnaHRlbiBvciBkYXJrZW4gKC0xIHRvIDEpXG5cdCAqL1xuXHRDb2xvci5wcm90b3R5cGUubGlnaHRlbiA9IGZ1bmN0aW9uKG11bHRpcGxpZXIpIHtcblx0ICAgIHZhciBjbSA9IE1hdGgubWluKDEsIE1hdGgubWF4KDAsIE1hdGguYWJzKG11bHRpcGxpZXIpKSkgKiAobXVsdGlwbGllciA8IDAgPyAtMSA6IDEpO1xuXHQgICAgdmFyIGJtID0gKDI1NSAqIGNtKSB8IDA7XG5cdCAgICB2YXIgY3IgPSBNYXRoLm1pbigyNTUsIE1hdGgubWF4KDAsIHRoaXMucmdiLnIgKyBibSkpO1xuXHQgICAgdmFyIGNnID0gTWF0aC5taW4oMjU1LCBNYXRoLm1heCgwLCB0aGlzLnJnYi5nICsgYm0pKTtcblx0ICAgIHZhciBjYiA9IE1hdGgubWluKDI1NSwgTWF0aC5tYXgoMCwgdGhpcy5yZ2IuYiArIGJtKSk7XG5cdCAgICB2YXIgaGV4ID0gQ29sb3IucmdiMmhleChjciwgY2csIGNiKTtcblx0ICAgIHJldHVybiBuZXcgQ29sb3IoaGV4KTtcblx0fTtcblxuXHQvKipcblx0ICogT3V0cHV0IGNvbG9yIGluIGhleCBmb3JtYXRcblx0ICogQHBhcmFtIGFkZEhhc2ggQWRkIGEgaGFzaCBjaGFyYWN0ZXIgdG8gdGhlIGJlZ2lubmluZyBvZiB0aGUgb3V0cHV0XG5cdCAqL1xuXHRDb2xvci5wcm90b3R5cGUudG9IZXggPSBmdW5jdGlvbihhZGRIYXNoKSB7XG5cdCAgICByZXR1cm4gKGFkZEhhc2ggPyAnIycgOiAnJykgKyB0aGlzLnJhdy50b1N0cmluZygxNik7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJldHVybnMgd2hldGhlciBvciBub3QgY3VycmVudCBjb2xvciBpcyBsaWdodGVyIHRoYW4gYW5vdGhlciBjb2xvclxuXHQgKiBAcGFyYW0gY29sb3IgQ29sb3IgdG8gY29tcGFyZSBhZ2FpbnN0XG5cdCAqL1xuXHRDb2xvci5wcm90b3R5cGUubGlnaHRlclRoYW4gPSBmdW5jdGlvbihjb2xvcikge1xuXHQgICAgaWYgKCEoY29sb3IgaW5zdGFuY2VvZiBDb2xvcikpIHtcblx0ICAgICAgICBjb2xvciA9IG5ldyBDb2xvcihjb2xvcik7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiB0aGlzLnl1di55ID4gY29sb3IueXV2Lnk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIHJlc3VsdCBvZiBtaXhpbmcgY3VycmVudCBjb2xvciB3aXRoIGFub3RoZXIgY29sb3Jcblx0ICogQHBhcmFtIGNvbG9yIENvbG9yIHRvIG1peCB3aXRoXG5cdCAqIEBwYXJhbSBtdWx0aXBsaWVyIEhvdyBtdWNoIHRvIG1peCB3aXRoIHRoZSBvdGhlciBjb2xvclxuXHQgKi9cblx0Lypcblx0Q29sb3IucHJvdG90eXBlLm1peCA9IGZ1bmN0aW9uIChjb2xvciwgbXVsdGlwbGllcikge1xuXHQgICAgaWYgKCEoY29sb3IgaW5zdGFuY2VvZiBDb2xvcikpIHtcblx0ICAgICAgICBjb2xvciA9IG5ldyBDb2xvcihjb2xvcik7XG5cdCAgICB9XG5cblx0ICAgIHZhciByID0gdGhpcy5yZ2Iucjtcblx0ICAgIHZhciBnID0gdGhpcy5yZ2IuZztcblx0ICAgIHZhciBiID0gdGhpcy5yZ2IuYjtcblx0ICAgIHZhciBhID0gdGhpcy5hbHBoYTtcblxuXHQgICAgdmFyIG0gPSB0eXBlb2YgbXVsdGlwbGllciAhPT0gJ3VuZGVmaW5lZCcgPyBtdWx0aXBsaWVyIDogMC41O1xuXG5cdCAgICAvL3RvZG86IHdyaXRlIGEgbGVycCBmdW5jdGlvblxuXHQgICAgciA9IHIgKyBtICogKGNvbG9yLnJnYi5yIC0gcik7XG5cdCAgICBnID0gZyArIG0gKiAoY29sb3IucmdiLmcgLSBnKTtcblx0ICAgIGIgPSBiICsgbSAqIChjb2xvci5yZ2IuYiAtIGIpO1xuXHQgICAgYSA9IGEgKyBtICogKGNvbG9yLmFscGhhIC0gYSk7XG5cblx0ICAgIHJldHVybiBuZXcgQ29sb3IoQ29sb3IucmdiVG9IZXgociwgZywgYiksIHtcblx0ICAgICAgICAnYWxwaGEnOiBhXG5cdCAgICB9KTtcblx0fTtcblx0Ki9cblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgcmVzdWx0IG9mIGJsZW5kaW5nIGFub3RoZXIgY29sb3Igb24gdG9wIG9mIGN1cnJlbnQgY29sb3Igd2l0aCBhbHBoYVxuXHQgKiBAcGFyYW0gY29sb3IgQ29sb3IgdG8gYmxlbmQgb24gdG9wIG9mIGN1cnJlbnQgY29sb3IsIGkuZS4gXCJDYVwiXG5cdCAqL1xuXHQvL3RvZG86IHNlZSBpZiAuYmxlbmRBbHBoYSBjYW4gYmUgbWVyZ2VkIGludG8gLm1peFxuXHRDb2xvci5wcm90b3R5cGUuYmxlbmRBbHBoYSA9IGZ1bmN0aW9uKGNvbG9yKSB7XG5cdCAgICBpZiAoIShjb2xvciBpbnN0YW5jZW9mIENvbG9yKSkge1xuXHQgICAgICAgIGNvbG9yID0gbmV3IENvbG9yKGNvbG9yKTtcblx0ICAgIH1cblxuXHQgICAgdmFyIENhID0gY29sb3I7XG5cdCAgICB2YXIgQ2IgPSB0aGlzO1xuXG5cdCAgICAvL3RvZG86IHdyaXRlIGFscGhhIGJsZW5kaW5nIGZ1bmN0aW9uXG5cdCAgICB2YXIgciA9IENhLmFscGhhICogQ2EucmdiLnIgKyAoMSAtIENhLmFscGhhKSAqIENiLnJnYi5yO1xuXHQgICAgdmFyIGcgPSBDYS5hbHBoYSAqIENhLnJnYi5nICsgKDEgLSBDYS5hbHBoYSkgKiBDYi5yZ2IuZztcblx0ICAgIHZhciBiID0gQ2EuYWxwaGEgKiBDYS5yZ2IuYiArICgxIC0gQ2EuYWxwaGEpICogQ2IucmdiLmI7XG5cblx0ICAgIHJldHVybiBuZXcgQ29sb3IoQ29sb3IucmdiMmhleChyLCBnLCBiKSk7XG5cdH07XG5cblx0bW9kdWxlLmV4cG9ydHMgPSBDb2xvcjtcblxuXG4vKioqLyB9KSxcbi8qIDExICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0bW9kdWxlLmV4cG9ydHMgPSB7XG5cdCAgJ3ZlcnNpb24nOiAnMi45LjknLFxuXHQgICdzdmdfbnMnOiAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnXG5cdH07XG5cbi8qKiovIH0pLFxuLyogMTIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHR2YXIgc2hhdmVuID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMykuZGVmYXVsdDtcblxuXHR2YXIgU1ZHID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KTtcblx0dmFyIGNvbnN0YW50cyA9IF9fd2VicGFja19yZXF1aXJlX18oMTEpO1xuXHR2YXIgdXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpO1xuXG5cdHZhciBTVkdfTlMgPSBjb25zdGFudHMuc3ZnX25zO1xuXG5cdHZhciB0ZW1wbGF0ZXMgPSB7XG5cdCAgJ2VsZW1lbnQnOiBmdW5jdGlvbiAob3B0aW9ucykge1xuXHQgICAgdmFyIHRhZyA9IG9wdGlvbnMudGFnO1xuXHQgICAgdmFyIGNvbnRlbnQgPSBvcHRpb25zLmNvbnRlbnQgfHwgJyc7XG5cdCAgICBkZWxldGUgb3B0aW9ucy50YWc7XG5cdCAgICBkZWxldGUgb3B0aW9ucy5jb250ZW50O1xuXHQgICAgcmV0dXJuICBbdGFnLCBjb250ZW50LCBvcHRpb25zXTtcblx0ICB9XG5cdH07XG5cblx0Ly90b2RvOiBkZXByZWNhdGUgdGFnIGFyZywgaW5mZXIgdGFnIGZyb20gc2hhcGUgb2JqZWN0XG5cdGZ1bmN0aW9uIGNvbnZlcnRTaGFwZSAoc2hhcGUsIHRhZykge1xuXHQgIHJldHVybiB0ZW1wbGF0ZXMuZWxlbWVudCh7XG5cdCAgICAndGFnJzogdGFnLFxuXHQgICAgJ3dpZHRoJzogc2hhcGUud2lkdGgsXG5cdCAgICAnaGVpZ2h0Jzogc2hhcGUuaGVpZ2h0LFxuXHQgICAgJ2ZpbGwnOiBzaGFwZS5wcm9wZXJ0aWVzLmZpbGxcblx0ICB9KTtcblx0fVxuXG5cdGZ1bmN0aW9uIHRleHRDc3MgKHByb3BlcnRpZXMpIHtcblx0ICByZXR1cm4gdXRpbHMuY3NzUHJvcHMoe1xuXHQgICAgJ2ZpbGwnOiBwcm9wZXJ0aWVzLmZpbGwsXG5cdCAgICAnZm9udC13ZWlnaHQnOiBwcm9wZXJ0aWVzLmZvbnQud2VpZ2h0LFxuXHQgICAgJ2ZvbnQtZmFtaWx5JzogcHJvcGVydGllcy5mb250LmZhbWlseSArICcsIG1vbm9zcGFjZScsXG5cdCAgICAnZm9udC1zaXplJzogcHJvcGVydGllcy5mb250LnNpemUgKyBwcm9wZXJ0aWVzLmZvbnQudW5pdHNcblx0ICB9KTtcblx0fVxuXG5cdGZ1bmN0aW9uIG91dGxpbmVQYXRoIChiZ1dpZHRoLCBiZ0hlaWdodCwgb3V0bGluZVdpZHRoKSB7XG5cdCAgdmFyIG91dGxpbmVPZmZzZXRXaWR0aCA9IG91dGxpbmVXaWR0aCAvIDI7XG5cblx0ICByZXR1cm4gW1xuXHQgICAgJ00nLCBvdXRsaW5lT2Zmc2V0V2lkdGgsIG91dGxpbmVPZmZzZXRXaWR0aCxcblx0ICAgICdIJywgYmdXaWR0aCAtIG91dGxpbmVPZmZzZXRXaWR0aCxcblx0ICAgICdWJywgYmdIZWlnaHQgLSBvdXRsaW5lT2Zmc2V0V2lkdGgsXG5cdCAgICAnSCcsIG91dGxpbmVPZmZzZXRXaWR0aCxcblx0ICAgICdWJywgMCxcblx0ICAgICdNJywgMCwgb3V0bGluZU9mZnNldFdpZHRoLFxuXHQgICAgJ0wnLCBiZ1dpZHRoLCBiZ0hlaWdodCAtIG91dGxpbmVPZmZzZXRXaWR0aCxcblx0ICAgICdNJywgMCwgYmdIZWlnaHQgLSBvdXRsaW5lT2Zmc2V0V2lkdGgsXG5cdCAgICAnTCcsIGJnV2lkdGgsIG91dGxpbmVPZmZzZXRXaWR0aFxuXHQgIF0uam9pbignICcpO1xuXHR9XG5cblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc2NlbmVHcmFwaCwgcmVuZGVyU2V0dGluZ3MpIHtcblx0ICB2YXIgZW5naW5lU2V0dGluZ3MgPSByZW5kZXJTZXR0aW5ncy5lbmdpbmVTZXR0aW5ncztcblx0ICB2YXIgc3R5bGVzaGVldHMgPSBlbmdpbmVTZXR0aW5ncy5zdHlsZXNoZWV0cztcblx0ICB2YXIgc3R5bGVzaGVldFhtbCA9IHN0eWxlc2hlZXRzLm1hcChmdW5jdGlvbiAoc3R5bGVzaGVldCkge1xuXHQgICAgcmV0dXJuICc8P3htbC1zdHlsZXNoZWV0IHJlbD1cInN0eWxlc2hlZXRcIiBocmVmPVwiJyArIHN0eWxlc2hlZXQgKyAnXCI/Pic7XG5cdCAgfSkuam9pbignXFxuJyk7XG5cblx0ICB2YXIgaG9sZGVySWQgPSAnaG9sZGVyXycgKyBOdW1iZXIobmV3IERhdGUoKSkudG9TdHJpbmcoMTYpO1xuXG5cdCAgdmFyIHJvb3QgPSBzY2VuZUdyYXBoLnJvb3Q7XG5cdCAgdmFyIHRleHRHcm91cCA9IHJvb3QuY2hpbGRyZW4uaG9sZGVyVGV4dEdyb3VwO1xuXG5cdCAgdmFyIGNzcyA9ICcjJyArIGhvbGRlcklkICsgJyB0ZXh0IHsgJyArIHRleHRDc3ModGV4dEdyb3VwLnByb3BlcnRpZXMpICsgJyB9ICc7XG5cblx0ICAvLyBwdXNoIHRleHQgZG93biB0byBiZSBlcXVhbGx5IHZlcnRpY2FsbHkgYWxpZ25lZCB3aXRoIGNhbnZhcyByZW5kZXJlclxuXHQgIHRleHRHcm91cC55ICs9IHRleHRHcm91cC50ZXh0UG9zaXRpb25EYXRhLmJvdW5kaW5nQm94LmhlaWdodCAqIDAuODtcblxuXHQgIHZhciB3b3JkVGFncyA9IFtdO1xuXG5cdCAgT2JqZWN0LmtleXModGV4dEdyb3VwLmNoaWxkcmVuKS5mb3JFYWNoKGZ1bmN0aW9uIChsaW5lS2V5KSB7XG5cdCAgICB2YXIgbGluZSA9IHRleHRHcm91cC5jaGlsZHJlbltsaW5lS2V5XTtcblxuXHQgICAgT2JqZWN0LmtleXMobGluZS5jaGlsZHJlbikuZm9yRWFjaChmdW5jdGlvbiAod29yZEtleSkge1xuXHQgICAgICB2YXIgd29yZCA9IGxpbmUuY2hpbGRyZW5bd29yZEtleV07XG5cdCAgICAgIHZhciB4ID0gdGV4dEdyb3VwLnggKyBsaW5lLnggKyB3b3JkLng7XG5cdCAgICAgIHZhciB5ID0gdGV4dEdyb3VwLnkgKyBsaW5lLnkgKyB3b3JkLnk7XG5cdCAgICAgIHZhciB3b3JkVGFnID0gdGVtcGxhdGVzLmVsZW1lbnQoe1xuXHQgICAgICAgICd0YWcnOiAndGV4dCcsXG5cdCAgICAgICAgJ2NvbnRlbnQnOiB3b3JkLnByb3BlcnRpZXMudGV4dCxcblx0ICAgICAgICAneCc6IHgsXG5cdCAgICAgICAgJ3knOiB5XG5cdCAgICAgIH0pO1xuXG5cdCAgICAgIHdvcmRUYWdzLnB1c2god29yZFRhZyk7XG5cdCAgICB9KTtcblx0ICB9KTtcblxuXHQgIHZhciB0ZXh0ID0gdGVtcGxhdGVzLmVsZW1lbnQoe1xuXHQgICAgJ3RhZyc6ICdnJyxcblx0ICAgICdjb250ZW50Jzogd29yZFRhZ3Ncblx0ICB9KTtcblxuXHQgIHZhciBvdXRsaW5lID0gbnVsbDtcblxuXHQgIGlmIChyb290LmNoaWxkcmVuLmhvbGRlckJnLnByb3BlcnRpZXMub3V0bGluZSkge1xuXHQgICAgdmFyIG91dGxpbmVQcm9wZXJ0aWVzID0gcm9vdC5jaGlsZHJlbi5ob2xkZXJCZy5wcm9wZXJ0aWVzLm91dGxpbmU7XG5cdCAgICBvdXRsaW5lID0gdGVtcGxhdGVzLmVsZW1lbnQoe1xuXHQgICAgICAndGFnJzogJ3BhdGgnLFxuXHQgICAgICAnZCc6IG91dGxpbmVQYXRoKHJvb3QuY2hpbGRyZW4uaG9sZGVyQmcud2lkdGgsIHJvb3QuY2hpbGRyZW4uaG9sZGVyQmcuaGVpZ2h0LCBvdXRsaW5lUHJvcGVydGllcy53aWR0aCksXG5cdCAgICAgICdzdHJva2Utd2lkdGgnOiBvdXRsaW5lUHJvcGVydGllcy53aWR0aCxcblx0ICAgICAgJ3N0cm9rZSc6IG91dGxpbmVQcm9wZXJ0aWVzLmZpbGwsXG5cdCAgICAgICdmaWxsJzogJ25vbmUnXG5cdCAgICB9KTtcblx0ICB9XG5cblx0ICB2YXIgYmcgPSBjb252ZXJ0U2hhcGUocm9vdC5jaGlsZHJlbi5ob2xkZXJCZywgJ3JlY3QnKTtcblxuXHQgIHZhciBzY2VuZUNvbnRlbnQgPSBbXTtcblxuXHQgIHNjZW5lQ29udGVudC5wdXNoKGJnKTtcblx0ICBpZiAob3V0bGluZVByb3BlcnRpZXMpIHtcblx0ICAgIHNjZW5lQ29udGVudC5wdXNoKG91dGxpbmUpO1xuXHQgIH1cblx0ICBzY2VuZUNvbnRlbnQucHVzaCh0ZXh0KTtcblxuXHQgIHZhciBzY2VuZSA9IHRlbXBsYXRlcy5lbGVtZW50KHtcblx0ICAgICd0YWcnOiAnZycsXG5cdCAgICAnaWQnOiBob2xkZXJJZCxcblx0ICAgICdjb250ZW50Jzogc2NlbmVDb250ZW50XG5cdCAgfSk7XG5cblx0ICB2YXIgc3R5bGUgPSB0ZW1wbGF0ZXMuZWxlbWVudCh7XG5cdCAgICAndGFnJzogJ3N0eWxlJyxcblx0ICAgIC8vdG9kbzogZmlndXJlIG91dCBob3cgdG8gYWRkIENEQVRBIGRpcmVjdGl2ZVxuXHQgICAgJ2NvbnRlbnQnOiBjc3MsXG5cdCAgICAndHlwZSc6ICd0ZXh0L2Nzcydcblx0ICB9KTtcblxuXHQgIHZhciBkZWZzID0gdGVtcGxhdGVzLmVsZW1lbnQoe1xuXHQgICAgJ3RhZyc6ICdkZWZzJyxcblx0ICAgICdjb250ZW50Jzogc3R5bGVcblx0ICB9KTtcblxuXHQgIHZhciBzdmcgPSB0ZW1wbGF0ZXMuZWxlbWVudCh7XG5cdCAgICAndGFnJzogJ3N2ZycsXG5cdCAgICAnY29udGVudCc6IFtkZWZzLCBzY2VuZV0sXG5cdCAgICAnd2lkdGgnOiByb290LnByb3BlcnRpZXMud2lkdGgsXG5cdCAgICAnaGVpZ2h0Jzogcm9vdC5wcm9wZXJ0aWVzLmhlaWdodCxcblx0ICAgICd4bWxucyc6IFNWR19OUyxcblx0ICAgICd2aWV3Qm94JzogWzAsIDAsIHJvb3QucHJvcGVydGllcy53aWR0aCwgcm9vdC5wcm9wZXJ0aWVzLmhlaWdodF0uam9pbignICcpLFxuXHQgICAgJ3ByZXNlcnZlQXNwZWN0UmF0aW8nOiAnbm9uZSdcblx0ICB9KTtcblxuXHQgIHZhciBvdXRwdXQgPSBTdHJpbmcoc2hhdmVuKHN2ZykpO1xuXG5cdCAgaWYgKC8mYW1wOyh4KT8jWzAtOUEtRmEtZl0vLnRlc3Qob3V0cHV0WzBdKSkge1xuXHQgICAgb3V0cHV0ID0gb3V0cHV0LnJlcGxhY2UoLyZhbXA7Iy9nbSwgJyYjJyk7XG5cdCAgfVxuXG5cdCAgb3V0cHV0ID0gc3R5bGVzaGVldFhtbCArIG91dHB1dDtcblxuXHQgIHZhciBzdmdTdHJpbmcgPSBTVkcuc3ZnU3RyaW5nVG9EYXRhVVJJKG91dHB1dCwgcmVuZGVyU2V0dGluZ3MubW9kZSA9PT0gJ2JhY2tncm91bmQnKTtcblxuXHQgIHJldHVybiBzdmdTdHJpbmc7XG5cdH07XG5cblxuLyoqKi8gfSksXG4vKiAxMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdC8vIHZlbmRvcmVkIHNoYXZlbiAxLjMuMCBkdWUgdG8gcHVibGlzaGVkIHBhY2thZ2UuanNvbiBpbmNsdWRpbmcgYW4gb3V0ZGF0ZWQgbm9kZSBlbmdpbmVcblx0bW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0KTtcblxuXG4vKioqLyB9KSxcbi8qIDE0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHQgIHZhbHVlOiB0cnVlXG5cdH0pO1xuXG5cdHZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxuXHRleHBvcnRzLmRlZmF1bHQgPSBzaGF2ZW47XG5cblx0dmFyIF9wYXJzZVN1Z2FyU3RyaW5nID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNSk7XG5cblx0dmFyIF9wYXJzZVN1Z2FyU3RyaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3BhcnNlU3VnYXJTdHJpbmcpO1xuXG5cdHZhciBfZXNjYXBlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNik7XG5cblx0dmFyIGVzY2FwZSA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9lc2NhcGUpO1xuXG5cdHZhciBfZGVmYXVsdHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE3KTtcblxuXHR2YXIgX2RlZmF1bHRzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2RlZmF1bHRzKTtcblxuXHR2YXIgX21hcEF0dHJpYnV0ZVZhbHVlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOCk7XG5cblx0dmFyIF9tYXBBdHRyaWJ1dGVWYWx1ZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9tYXBBdHRyaWJ1dGVWYWx1ZSk7XG5cblx0dmFyIF9hc3NlcnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIxKTtcblxuXHR2YXIgX2Fzc2VydDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9hc3NlcnQpO1xuXG5cdGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gZWxzZSB7IHZhciBuZXdPYmogPSB7fTsgaWYgKG9iaiAhPSBudWxsKSB7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSBuZXdPYmouZGVmYXVsdCA9IG9iajsgcmV0dXJuIG5ld09iajsgfSB9XG5cblx0ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuXHRmdW5jdGlvbiBzaGF2ZW4oYXJyYXlPck9iamVjdCkge1xuXHQgIHZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheShhcnJheU9yT2JqZWN0KTtcblx0ICB2YXIgb2JqVHlwZSA9IHR5cGVvZiBhcnJheU9yT2JqZWN0ID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihhcnJheU9yT2JqZWN0KTtcblxuXHQgIGlmICghaXNBcnJheSAmJiBvYmpUeXBlICE9PSAnb2JqZWN0Jykge1xuXHQgICAgdGhyb3cgbmV3IEVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGVpdGhlciBhbiBhcnJheSBvciBhbiBvYmplY3QgJyArICdhbmQgbm90ICcgKyBKU09OLnN0cmluZ2lmeShhcnJheU9yT2JqZWN0KSk7XG5cdCAgfVxuXG5cdCAgaWYgKGlzQXJyYXkgJiYgYXJyYXlPck9iamVjdC5sZW5ndGggPT09IDApIHtcblx0ICAgIC8vIElnbm9yZSBlbXB0eSBhcnJheXNcblx0ICAgIHJldHVybiB7fTtcblx0ICB9XG5cblx0ICB2YXIgY29uZmlnID0ge307XG5cdCAgdmFyIGVsZW1lbnRBcnJheSA9IFtdO1xuXG5cdCAgaWYgKEFycmF5LmlzQXJyYXkoYXJyYXlPck9iamVjdCkpIHtcblx0ICAgIGVsZW1lbnRBcnJheSA9IGFycmF5T3JPYmplY3Quc2xpY2UoMCk7XG5cdCAgfSBlbHNlIHtcblx0ICAgIGVsZW1lbnRBcnJheSA9IGFycmF5T3JPYmplY3QuZWxlbWVudEFycmF5LnNsaWNlKDApO1xuXHQgICAgY29uZmlnID0gT2JqZWN0LmFzc2lnbihjb25maWcsIGFycmF5T3JPYmplY3QpO1xuXHQgICAgZGVsZXRlIGNvbmZpZy5lbGVtZW50QXJyYXk7XG5cdCAgfVxuXG5cdCAgY29uZmlnID0gT2JqZWN0LmFzc2lnbih7fSwgX2RlZmF1bHRzMi5kZWZhdWx0LCBjb25maWcsIHtcblx0ICAgIHJldHVybk9iamVjdDogeyAvLyBTaGF2ZW4gb2JqZWN0IHRvIHJldHVybiBhdCBsYXN0XG5cdCAgICAgIGlkczoge30sXG5cdCAgICAgIHJlZmVyZW5jZXM6IHt9XG5cdCAgICB9XG5cdCAgfSk7XG5cblx0ICBmdW5jdGlvbiBjcmVhdGVFbGVtZW50KHN1Z2FyU3RyaW5nKSB7XG5cdCAgICB2YXIgcHJvcGVydGllcyA9ICgwLCBfcGFyc2VTdWdhclN0cmluZzIuZGVmYXVsdCkoc3VnYXJTdHJpbmcpO1xuXHQgICAgdmFyIGVsZW1lbnQgPSB7XG5cdCAgICAgIHRhZzogcHJvcGVydGllcy50YWcsXG5cdCAgICAgIGF0dHI6IHt9LFxuXHQgICAgICBjaGlsZHJlbjogW11cblx0ICAgIH07XG5cblx0ICAgIGlmIChwcm9wZXJ0aWVzLmlkKSB7XG5cdCAgICAgIGVsZW1lbnQuYXR0ci5pZCA9IHByb3BlcnRpZXMuaWQ7XG5cdCAgICAgICgwLCBfYXNzZXJ0Mi5kZWZhdWx0KSghY29uZmlnLnJldHVybk9iamVjdC5pZHMuaGFzT3duUHJvcGVydHkocHJvcGVydGllcy5pZCksICdJZHMgbXVzdCBiZSB1bmlxdWUgYW5kIFwiJyArIHByb3BlcnRpZXMuaWQgKyAnXCIgaXMgYWxyZWFkeSBhc3NpZ25lZCcpO1xuXHQgICAgICBjb25maWcucmV0dXJuT2JqZWN0Lmlkc1twcm9wZXJ0aWVzLmlkXSA9IGVsZW1lbnQ7XG5cdCAgICB9XG5cdCAgICBpZiAocHJvcGVydGllcy5jbGFzcykge1xuXHQgICAgICBlbGVtZW50LmF0dHIuY2xhc3MgPSBwcm9wZXJ0aWVzLmNsYXNzO1xuXHQgICAgfVxuXHQgICAgaWYgKHByb3BlcnRpZXMucmVmZXJlbmNlKSB7XG5cdCAgICAgICgwLCBfYXNzZXJ0Mi5kZWZhdWx0KSghY29uZmlnLnJldHVybk9iamVjdC5pZHMuaGFzT3duUHJvcGVydHkocHJvcGVydGllcy5yZWZlcmVuY2UpLCAnUmVmZXJlbmNlcyBtdXN0IGJlIHVuaXF1ZSBhbmQgXCInICsgcHJvcGVydGllcy5pZCArICdcIiBpcyBhbHJlYWR5IGFzc2lnbmVkJyk7XG5cdCAgICAgIGNvbmZpZy5yZXR1cm5PYmplY3QucmVmZXJlbmNlc1twcm9wZXJ0aWVzLnJlZmVyZW5jZV0gPSBlbGVtZW50O1xuXHQgICAgfVxuXG5cdCAgICBjb25maWcuZXNjYXBlSFRNTCA9IHByb3BlcnRpZXMuZXNjYXBlSFRNTCAhPSBudWxsID8gcHJvcGVydGllcy5lc2NhcGVIVE1MIDogY29uZmlnLmVzY2FwZUhUTUw7XG5cblx0ICAgIHJldHVybiBlbGVtZW50O1xuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIGJ1aWxkRG9tKGVsZW1BcnJheSkge1xuXHQgICAgaWYgKEFycmF5LmlzQXJyYXkoZWxlbUFycmF5KSAmJiBlbGVtQXJyYXkubGVuZ3RoID09PSAwKSB7XG5cdCAgICAgIC8vIElnbm9yZSBlbXB0eSBhcnJheXNcblx0ICAgICAgcmV0dXJuIHt9O1xuXHQgICAgfVxuXG5cdCAgICB2YXIgaW5kZXggPSAxO1xuXHQgICAgdmFyIGNyZWF0ZWRDYWxsYmFjayA9IHZvaWQgMDtcblx0ICAgIHZhciBzZWxmQ2xvc2luZ0hUTUxUYWdzID0gWydhcmVhJywgJ2Jhc2UnLCAnYnInLCAnY29sJywgJ2NvbW1hbmQnLCAnZW1iZWQnLCAnaHInLCAnaW1nJywgJ2lucHV0JywgJ2tleWdlbicsICdsaW5rJywgJ21lbnVpdGVtJywgJ21ldGEnLCAncGFyYW0nLCAnc291cmNlJywgJ3RyYWNrJywgJ3diciddO1xuXHQgICAgLy8gQ2xvbmUgdG8gYXZvaWQgbXV0YXRpb24gcHJvYmxlbXNcblx0ICAgIHZhciBhcnJheSA9IGVsZW1BcnJheS5zbGljZSgwKTtcblxuXHQgICAgaWYgKHR5cGVvZiBhcnJheVswXSA9PT0gJ3N0cmluZycpIHtcblx0ICAgICAgYXJyYXlbMF0gPSBjcmVhdGVFbGVtZW50KGFycmF5WzBdKTtcblx0ICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShhcnJheVswXSkpIHtcblx0ICAgICAgaW5kZXggPSAwO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgdGhyb3cgbmV3IEVycm9yKCdGaXJzdCBlbGVtZW50IG9mIGFycmF5IG11c3QgYmUgYSBzdHJpbmcsICcgKyAnb3IgYW4gYXJyYXkgYW5kIG5vdCAnICsgSlNPTi5zdHJpbmdpZnkoYXJyYXlbMF0pKTtcblx0ICAgIH1cblxuXHQgICAgZm9yICg7IGluZGV4IDwgYXJyYXkubGVuZ3RoOyBpbmRleCsrKSB7XG5cblx0ICAgICAgLy8gRG9uJ3QgcmVuZGVyIGVsZW1lbnQgaWYgdmFsdWUgaXMgZmFsc2Ugb3IgbnVsbFxuXHQgICAgICBpZiAoYXJyYXlbaW5kZXhdID09PSBmYWxzZSB8fCBhcnJheVtpbmRleF0gPT09IG51bGwpIHtcblx0ICAgICAgICBhcnJheVswXSA9IGZhbHNlO1xuXHQgICAgICAgIGJyZWFrO1xuXHQgICAgICB9XG5cblx0ICAgICAgLy8gQ29udGludWUgd2l0aCBuZXh0IGFycmF5IHZhbHVlIGlmIGN1cnJlbnQgdmFsdWUgaXMgdW5kZWZpbmVkIG9yIHRydWVcblx0ICAgICAgZWxzZSBpZiAoYXJyYXlbaW5kZXhdID09PSB1bmRlZmluZWQgfHwgYXJyYXlbaW5kZXhdID09PSB0cnVlKSB7XG5cdCAgICAgICAgICBjb250aW51ZTtcblx0ICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBhcnJheVtpbmRleF0gPT09ICdzdHJpbmcnKSB7XG5cdCAgICAgICAgICBpZiAoY29uZmlnLmVzY2FwZUhUTUwpIHtcblx0ICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5ldy1jYXBcblx0ICAgICAgICAgICAgYXJyYXlbaW5kZXhdID0gZXNjYXBlLkhUTUwoYXJyYXlbaW5kZXhdKTtcblx0ICAgICAgICAgIH1cblxuXHQgICAgICAgICAgYXJyYXlbMF0uY2hpbGRyZW4ucHVzaChhcnJheVtpbmRleF0pO1xuXHQgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGFycmF5W2luZGV4XSA9PT0gJ251bWJlcicpIHtcblxuXHQgICAgICAgICAgYXJyYXlbMF0uY2hpbGRyZW4ucHVzaChhcnJheVtpbmRleF0pO1xuXHQgICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShhcnJheVtpbmRleF0pKSB7XG5cblx0ICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGFycmF5W2luZGV4XVswXSkpIHtcblx0ICAgICAgICAgICAgYXJyYXlbaW5kZXhdLnJldmVyc2UoKS5mb3JFYWNoKGZ1bmN0aW9uIChzdWJBcnJheSkge1xuXHQgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbG9vcC1mdW5jXG5cdCAgICAgICAgICAgICAgYXJyYXkuc3BsaWNlKGluZGV4ICsgMSwgMCwgc3ViQXJyYXkpO1xuXHQgICAgICAgICAgICB9KTtcblxuXHQgICAgICAgICAgICBpZiAoaW5kZXggIT09IDApIGNvbnRpbnVlO1xuXHQgICAgICAgICAgICBpbmRleCsrO1xuXHQgICAgICAgICAgfVxuXG5cdCAgICAgICAgICBhcnJheVtpbmRleF0gPSBidWlsZERvbShhcnJheVtpbmRleF0pO1xuXG5cdCAgICAgICAgICBpZiAoYXJyYXlbaW5kZXhdWzBdKSB7XG5cdCAgICAgICAgICAgIGFycmF5WzBdLmNoaWxkcmVuLnB1c2goYXJyYXlbaW5kZXhdWzBdKTtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBhcnJheVtpbmRleF0gPT09ICdmdW5jdGlvbicpIHtcblx0ICAgICAgICAgIGNyZWF0ZWRDYWxsYmFjayA9IGFycmF5W2luZGV4XTtcblx0ICAgICAgICB9IGVsc2UgaWYgKF90eXBlb2YoYXJyYXlbaW5kZXhdKSA9PT0gJ29iamVjdCcpIHtcblx0ICAgICAgICAgIGZvciAodmFyIGF0dHJpYnV0ZUtleSBpbiBhcnJheVtpbmRleF0pIHtcblx0ICAgICAgICAgICAgaWYgKCFhcnJheVtpbmRleF0uaGFzT3duUHJvcGVydHkoYXR0cmlidXRlS2V5KSkgY29udGludWU7XG5cblx0ICAgICAgICAgICAgdmFyIGF0dHJpYnV0ZVZhbHVlID0gYXJyYXlbaW5kZXhdW2F0dHJpYnV0ZUtleV07XG5cblx0ICAgICAgICAgICAgaWYgKGFycmF5W2luZGV4XS5oYXNPd25Qcm9wZXJ0eShhdHRyaWJ1dGVLZXkpICYmIGF0dHJpYnV0ZVZhbHVlICE9PSBudWxsICYmIGF0dHJpYnV0ZVZhbHVlICE9PSBmYWxzZSkge1xuXHQgICAgICAgICAgICAgIGFycmF5WzBdLmF0dHJbYXR0cmlidXRlS2V5XSA9ICgwLCBfbWFwQXR0cmlidXRlVmFsdWUyLmRlZmF1bHQpKGF0dHJpYnV0ZUtleSwgYXR0cmlidXRlVmFsdWUpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiJyArIGFycmF5W2luZGV4XSArICdcIiBpcyBub3QgYWxsb3dlZCBhcyBhIHZhbHVlJyk7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICBpZiAoYXJyYXlbMF0gIT09IGZhbHNlKSB7XG5cdCAgICAgIHZhciBIVE1MU3RyaW5nID0gJzwnICsgYXJyYXlbMF0udGFnO1xuXG5cdCAgICAgIGZvciAodmFyIGtleSBpbiBhcnJheVswXS5hdHRyKSB7XG5cdCAgICAgICAgaWYgKGFycmF5WzBdLmF0dHIuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuXHQgICAgICAgICAgdmFyIF9hdHRyaWJ1dGVWYWx1ZSA9IGVzY2FwZS5hdHRyaWJ1dGUoYXJyYXlbMF0uYXR0cltrZXldKTtcblx0ICAgICAgICAgIHZhciB2YWx1ZSA9IF9hdHRyaWJ1dGVWYWx1ZTtcblxuXHQgICAgICAgICAgaWYgKGNvbmZpZy5xdW90ZUF0dHJpYnV0ZXMgfHwgL1sgXCInPTw+XS8udGVzdChfYXR0cmlidXRlVmFsdWUpKSB7XG5cdCAgICAgICAgICAgIHZhbHVlID0gY29uZmlnLnF1b3RhdGlvbk1hcmsgKyBfYXR0cmlidXRlVmFsdWUgKyBjb25maWcucXVvdGF0aW9uTWFyaztcblx0ICAgICAgICAgIH1cblxuXHQgICAgICAgICAgSFRNTFN0cmluZyArPSAnICcgKyBrZXkgKyAnPScgKyB2YWx1ZTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblxuXHQgICAgICBIVE1MU3RyaW5nICs9ICc+JztcblxuXHQgICAgICBpZiAoIShzZWxmQ2xvc2luZ0hUTUxUYWdzLmluZGV4T2YoYXJyYXlbMF0udGFnKSAhPT0gLTEpKSB7XG5cdCAgICAgICAgYXJyYXlbMF0uY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcblx0ICAgICAgICAgIHJldHVybiBIVE1MU3RyaW5nICs9IGNoaWxkO1xuXHQgICAgICAgIH0pO1xuXG5cdCAgICAgICAgSFRNTFN0cmluZyArPSAnPC8nICsgYXJyYXlbMF0udGFnICsgJz4nO1xuXHQgICAgICB9XG5cblx0ICAgICAgYXJyYXlbMF0gPSBIVE1MU3RyaW5nO1xuXHQgICAgfVxuXG5cdCAgICAvLyBSZXR1cm4gcm9vdCBlbGVtZW50IG9uIGluZGV4IDBcblx0ICAgIGNvbmZpZy5yZXR1cm5PYmplY3RbMF0gPSBhcnJheVswXTtcblx0ICAgIGNvbmZpZy5yZXR1cm5PYmplY3Qucm9vdEVsZW1lbnQgPSBhcnJheVswXTtcblxuXHQgICAgY29uZmlnLnJldHVybk9iamVjdC50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgcmV0dXJuIGFycmF5WzBdO1xuXHQgICAgfTtcblxuXHQgICAgaWYgKGNyZWF0ZWRDYWxsYmFjaykgY3JlYXRlZENhbGxiYWNrKGFycmF5WzBdKTtcblxuXHQgICAgcmV0dXJuIGNvbmZpZy5yZXR1cm5PYmplY3Q7XG5cdCAgfVxuXG5cdCAgcmV0dXJuIGJ1aWxkRG9tKGVsZW1lbnRBcnJheSk7XG5cdH1cblxuXHRzaGF2ZW4uc2V0RGVmYXVsdHMgPSBmdW5jdGlvbiAob2JqZWN0KSB7XG5cdCAgT2JqZWN0LmFzc2lnbihfZGVmYXVsdHMyLmRlZmF1bHQsIG9iamVjdCk7XG5cdCAgcmV0dXJuIHNoYXZlbjtcblx0fTtcblxuXG4vKioqLyB9KSxcbi8qIDE1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHQgIHZhbHVlOiB0cnVlXG5cdH0pO1xuXG5cdGV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChzdWdhclN0cmluZykge1xuXHQgIHZhciB0YWdzID0gc3VnYXJTdHJpbmcubWF0Y2goL15bXFx3LV0rLyk7XG5cdCAgdmFyIHByb3BlcnRpZXMgPSB7XG5cdCAgICB0YWc6IHRhZ3MgPyB0YWdzWzBdIDogJ2Rpdidcblx0ICB9O1xuXHQgIHZhciBpZHMgPSBzdWdhclN0cmluZy5tYXRjaCgvIyhbXFx3LV0rKS8pO1xuXHQgIHZhciBjbGFzc2VzID0gc3VnYXJTdHJpbmcubWF0Y2goL1xcLltcXHctXSsvZyk7XG5cdCAgdmFyIHJlZmVyZW5jZXMgPSBzdWdhclN0cmluZy5tYXRjaCgvXFwkKFtcXHctXSspLyk7XG5cblx0ICBpZiAoaWRzKSBwcm9wZXJ0aWVzLmlkID0gaWRzWzFdO1xuXG5cdCAgaWYgKGNsYXNzZXMpIHtcblx0ICAgIHByb3BlcnRpZXMuY2xhc3MgPSBjbGFzc2VzLmpvaW4oJyAnKS5yZXBsYWNlKC9cXC4vZywgJycpO1xuXHQgIH1cblxuXHQgIGlmIChyZWZlcmVuY2VzKSBwcm9wZXJ0aWVzLnJlZmVyZW5jZSA9IHJlZmVyZW5jZXNbMV07XG5cblx0ICBpZiAoc3VnYXJTdHJpbmcuZW5kc1dpdGgoJyYnKSB8fCBzdWdhclN0cmluZy5lbmRzV2l0aCgnIScpKSB7XG5cdCAgICBwcm9wZXJ0aWVzLmVzY2FwZUhUTUwgPSBmYWxzZTtcblx0ICB9XG5cblx0ICByZXR1cm4gcHJvcGVydGllcztcblx0fTtcblxuLyoqKi8gfSksXG4vKiAxNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdCd1c2Ugc3RyaWN0JztcblxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcblx0ICB2YWx1ZTogdHJ1ZVxuXHR9KTtcblx0ZXhwb3J0cy5hdHRyaWJ1dGUgPSBhdHRyaWJ1dGU7XG5cdGV4cG9ydHMuSFRNTCA9IEhUTUw7XG5cdGZ1bmN0aW9uIGF0dHJpYnV0ZShzdHJpbmcpIHtcblx0ICByZXR1cm4gc3RyaW5nIHx8IHN0cmluZyA9PT0gMCA/IFN0cmluZyhzdHJpbmcpLnJlcGxhY2UoLyYvZywgJyZhbXA7JykucmVwbGFjZSgvXCIvZywgJyZxdW90OycpIDogJyc7XG5cdH1cblxuXHRmdW5jdGlvbiBIVE1MKHN0cmluZykge1xuXHQgIHJldHVybiBTdHJpbmcoc3RyaW5nKS5yZXBsYWNlKC8mL2csICcmYW1wOycpLnJlcGxhY2UoL1wiL2csICcmcXVvdDsnKS5yZXBsYWNlKC8nL2csICcmYXBvczsnKS5yZXBsYWNlKC88L2csICcmbHQ7JykucmVwbGFjZSgvPi9nLCAnJmd0OycpO1xuXHR9XG5cbi8qKiovIH0pLFxuLyogMTcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHQndXNlIHN0cmljdCc7XG5cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG5cdCAgdmFsdWU6IHRydWVcblx0fSk7XG5cdGV4cG9ydHMuZGVmYXVsdCA9IHtcblx0ICBuYW1lc3BhY2U6ICd4aHRtbCcsXG5cdCAgYXV0b05hbWVzcGFjaW5nOiB0cnVlLFxuXHQgIGVzY2FwZUhUTUw6IHRydWUsXG5cdCAgcXVvdGF0aW9uTWFyazogJ1wiJyxcblx0ICBxdW90ZUF0dHJpYnV0ZXM6IHRydWUsXG5cdCAgY29udmVydFRyYW5zZm9ybUFycmF5OiB0cnVlXG5cdH07XG5cbi8qKiovIH0pLFxuLyogMTggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQndXNlIHN0cmljdCc7XG5cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG5cdCAgdmFsdWU6IHRydWVcblx0fSk7XG5cblx0dmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG5cdHZhciBfYnVpbGRUcmFuc2Zvcm1TdHJpbmcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE5KTtcblxuXHR2YXIgX2J1aWxkVHJhbnNmb3JtU3RyaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2J1aWxkVHJhbnNmb3JtU3RyaW5nKTtcblxuXHR2YXIgX3N0cmluZ2lmeVN0eWxlT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMCk7XG5cblx0dmFyIF9zdHJpbmdpZnlTdHlsZU9iamVjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zdHJpbmdpZnlTdHlsZU9iamVjdCk7XG5cblx0ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuXHRleHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuXHQgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG5cdCAgICByZXR1cm4gJyc7XG5cdCAgfVxuXG5cdCAgaWYgKGtleSA9PT0gJ3N0eWxlJyAmJiAodHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZih2YWx1ZSkpID09PSAnb2JqZWN0Jykge1xuXHQgICAgcmV0dXJuICgwLCBfc3RyaW5naWZ5U3R5bGVPYmplY3QyLmRlZmF1bHQpKHZhbHVlKTtcblx0ICB9XG5cblx0ICBpZiAoa2V5ID09PSAndHJhbnNmb3JtJyAmJiBBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuXHQgICAgcmV0dXJuICgwLCBfYnVpbGRUcmFuc2Zvcm1TdHJpbmcyLmRlZmF1bHQpKHZhbHVlKTtcblx0ICB9XG5cblx0ICByZXR1cm4gdmFsdWU7XG5cdH07XG5cbi8qKiovIH0pLFxuLyogMTkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHQndXNlIHN0cmljdCc7XG5cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG5cdCAgdmFsdWU6IHRydWVcblx0fSk7XG5cblx0Ly8gQ3JlYXRlIHRyYW5zZm9ybSBzdHJpbmcgZnJvbSBsaXN0IHRyYW5zZm9ybSBvYmplY3RzXG5cblx0ZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKHRyYW5zZm9ybU9iamVjdHMpIHtcblxuXHQgIHJldHVybiB0cmFuc2Zvcm1PYmplY3RzLm1hcChmdW5jdGlvbiAodHJhbnNmb3JtYXRpb24pIHtcblx0ICAgIHZhciB2YWx1ZXMgPSBbXTtcblxuXHQgICAgaWYgKHRyYW5zZm9ybWF0aW9uLnR5cGUgPT09ICdyb3RhdGUnICYmIHRyYW5zZm9ybWF0aW9uLmRlZ3JlZXMpIHtcblx0ICAgICAgdmFsdWVzLnB1c2godHJhbnNmb3JtYXRpb24uZGVncmVlcyk7XG5cdCAgICB9XG5cdCAgICBpZiAodHJhbnNmb3JtYXRpb24ueCkgdmFsdWVzLnB1c2godHJhbnNmb3JtYXRpb24ueCk7XG5cdCAgICBpZiAodHJhbnNmb3JtYXRpb24ueSkgdmFsdWVzLnB1c2godHJhbnNmb3JtYXRpb24ueSk7XG5cblx0ICAgIHJldHVybiB0cmFuc2Zvcm1hdGlvbi50eXBlICsgJygnICsgdmFsdWVzICsgJyknO1xuXHQgIH0pLmpvaW4oJyAnKTtcblx0fTtcblxuLyoqKi8gfSksXG4vKiAyMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdCd1c2Ugc3RyaWN0JztcblxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcblx0ICB2YWx1ZTogdHJ1ZVxuXHR9KTtcblxuXHR2YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cblx0ZnVuY3Rpb24gc2FuaXRpemVQcm9wZXJ0aWVzKGtleSwgdmFsdWUpIHtcblx0ICBpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IGZhbHNlIHx8IHZhbHVlID09PSB1bmRlZmluZWQpIHJldHVybjtcblx0ICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyB8fCAodHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZih2YWx1ZSkpID09PSAnb2JqZWN0JykgcmV0dXJuIHZhbHVlO1xuXG5cdCAgcmV0dXJuIFN0cmluZyh2YWx1ZSk7XG5cdH1cblxuXHRleHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoc3R5bGVPYmplY3QpIHtcblx0ICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoc3R5bGVPYmplY3QsIHNhbml0aXplUHJvcGVydGllcykuc2xpY2UoMiwgLTIpLnJlcGxhY2UoL1wiLFwiL2csICc7JykucmVwbGFjZSgvXCI6XCIvZywgJzonKS5yZXBsYWNlKC9cXFxcXCIvZywgJ1xcJycpO1xuXHR9O1xuXG4vKioqLyB9KSxcbi8qIDIxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0LyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovKGZ1bmN0aW9uKGdsb2JhbCkgeyd1c2Ugc3RyaWN0JztcblxuXHR2YXIgb2JqZWN0QXNzaWduID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMik7XG5cblx0Ly8gY29tcGFyZSBhbmQgaXNCdWZmZXIgdGFrZW4gZnJvbSBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9ibG9iLzY4MGU5ZTVlNDg4ZjIyYWFjMjc1OTlhNTdkYzg0NGE2MzE1OTI4ZGQvaW5kZXguanNcblx0Ly8gb3JpZ2luYWwgbm90aWNlOlxuXG5cdC8qIVxuXHQgKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cblx0ICpcblx0ICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGZlcm9zc0BmZXJvc3Mub3JnPiA8aHR0cDovL2Zlcm9zcy5vcmc+XG5cdCAqIEBsaWNlbnNlICBNSVRcblx0ICovXG5cdGZ1bmN0aW9uIGNvbXBhcmUoYSwgYikge1xuXHQgIGlmIChhID09PSBiKSB7XG5cdCAgICByZXR1cm4gMDtcblx0ICB9XG5cblx0ICB2YXIgeCA9IGEubGVuZ3RoO1xuXHQgIHZhciB5ID0gYi5sZW5ndGg7XG5cblx0ICBmb3IgKHZhciBpID0gMCwgbGVuID0gTWF0aC5taW4oeCwgeSk7IGkgPCBsZW47ICsraSkge1xuXHQgICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcblx0ICAgICAgeCA9IGFbaV07XG5cdCAgICAgIHkgPSBiW2ldO1xuXHQgICAgICBicmVhaztcblx0ICAgIH1cblx0ICB9XG5cblx0ICBpZiAoeCA8IHkpIHtcblx0ICAgIHJldHVybiAtMTtcblx0ICB9XG5cdCAgaWYgKHkgPCB4KSB7XG5cdCAgICByZXR1cm4gMTtcblx0ICB9XG5cdCAgcmV0dXJuIDA7XG5cdH1cblx0ZnVuY3Rpb24gaXNCdWZmZXIoYikge1xuXHQgIGlmIChnbG9iYWwuQnVmZmVyICYmIHR5cGVvZiBnbG9iYWwuQnVmZmVyLmlzQnVmZmVyID09PSAnZnVuY3Rpb24nKSB7XG5cdCAgICByZXR1cm4gZ2xvYmFsLkJ1ZmZlci5pc0J1ZmZlcihiKTtcblx0ICB9XG5cdCAgcmV0dXJuICEhKGIgIT0gbnVsbCAmJiBiLl9pc0J1ZmZlcik7XG5cdH1cblxuXHQvLyBiYXNlZCBvbiBub2RlIGFzc2VydCwgb3JpZ2luYWwgbm90aWNlOlxuXHQvLyBOQjogVGhlIFVSTCB0byB0aGUgQ29tbW9uSlMgc3BlYyBpcyBrZXB0IGp1c3QgZm9yIHRyYWRpdGlvbi5cblx0Ly8gICAgIG5vZGUtYXNzZXJ0IGhhcyBldm9sdmVkIGEgbG90IHNpbmNlIHRoZW4sIGJvdGggaW4gQVBJIGFuZCBiZWhhdmlvci5cblxuXHQvLyBodHRwOi8vd2lraS5jb21tb25qcy5vcmcvd2lraS9Vbml0X1Rlc3RpbmcvMS4wXG5cdC8vXG5cdC8vIFRISVMgSVMgTk9UIFRFU1RFRCBOT1IgTElLRUxZIFRPIFdPUksgT1VUU0lERSBWOCFcblx0Ly9cblx0Ly8gT3JpZ2luYWxseSBmcm9tIG5hcndoYWwuanMgKGh0dHA6Ly9uYXJ3aGFsanMub3JnKVxuXHQvLyBDb3B5cmlnaHQgKGMpIDIwMDkgVGhvbWFzIFJvYmluc29uIDwyODBub3J0aC5jb20+XG5cdC8vXG5cdC8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcblx0Ly8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgJ1NvZnR3YXJlJyksIHRvXG5cdC8vIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlXG5cdC8vIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vclxuXHQvLyBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuXHQvLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXHQvL1xuXHQvLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuXHQvLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblx0Ly9cblx0Ly8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEICdBUyBJUycsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcblx0Ly8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG5cdC8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuXHQvLyBBVVRIT1JTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTlxuXHQvLyBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OXG5cdC8vIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG5cdHZhciB1dGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMyk7XG5cdHZhciBoYXNPd24gPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXHR2YXIgcFNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xuXHR2YXIgZnVuY3Rpb25zSGF2ZU5hbWVzID0gKGZ1bmN0aW9uICgpIHtcblx0ICByZXR1cm4gZnVuY3Rpb24gZm9vKCkge30ubmFtZSA9PT0gJ2Zvbyc7XG5cdH0oKSk7XG5cdGZ1bmN0aW9uIHBUb1N0cmluZyAob2JqKSB7XG5cdCAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopO1xuXHR9XG5cdGZ1bmN0aW9uIGlzVmlldyhhcnJidWYpIHtcblx0ICBpZiAoaXNCdWZmZXIoYXJyYnVmKSkge1xuXHQgICAgcmV0dXJuIGZhbHNlO1xuXHQgIH1cblx0ICBpZiAodHlwZW9mIGdsb2JhbC5BcnJheUJ1ZmZlciAhPT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgcmV0dXJuIGZhbHNlO1xuXHQgIH1cblx0ICBpZiAodHlwZW9mIEFycmF5QnVmZmVyLmlzVmlldyA9PT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgcmV0dXJuIEFycmF5QnVmZmVyLmlzVmlldyhhcnJidWYpO1xuXHQgIH1cblx0ICBpZiAoIWFycmJ1Zikge1xuXHQgICAgcmV0dXJuIGZhbHNlO1xuXHQgIH1cblx0ICBpZiAoYXJyYnVmIGluc3RhbmNlb2YgRGF0YVZpZXcpIHtcblx0ICAgIHJldHVybiB0cnVlO1xuXHQgIH1cblx0ICBpZiAoYXJyYnVmLmJ1ZmZlciAmJiBhcnJidWYuYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcblx0ICAgIHJldHVybiB0cnVlO1xuXHQgIH1cblx0ICByZXR1cm4gZmFsc2U7XG5cdH1cblx0Ly8gMS4gVGhlIGFzc2VydCBtb2R1bGUgcHJvdmlkZXMgZnVuY3Rpb25zIHRoYXQgdGhyb3dcblx0Ly8gQXNzZXJ0aW9uRXJyb3IncyB3aGVuIHBhcnRpY3VsYXIgY29uZGl0aW9ucyBhcmUgbm90IG1ldC4gVGhlXG5cdC8vIGFzc2VydCBtb2R1bGUgbXVzdCBjb25mb3JtIHRvIHRoZSBmb2xsb3dpbmcgaW50ZXJmYWNlLlxuXG5cdHZhciBhc3NlcnQgPSBtb2R1bGUuZXhwb3J0cyA9IG9rO1xuXG5cdC8vIDIuIFRoZSBBc3NlcnRpb25FcnJvciBpcyBkZWZpbmVkIGluIGFzc2VydC5cblx0Ly8gbmV3IGFzc2VydC5Bc3NlcnRpb25FcnJvcih7IG1lc3NhZ2U6IG1lc3NhZ2UsXG5cdC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3R1YWw6IGFjdHVhbCxcblx0Ly8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBleHBlY3RlZCB9KVxuXG5cdHZhciByZWdleCA9IC9cXHMqZnVuY3Rpb25cXHMrKFteXFwoXFxzXSopXFxzKi87XG5cdC8vIGJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS9samhhcmIvZnVuY3Rpb24ucHJvdG90eXBlLm5hbWUvYmxvYi9hZGVlZWVjOGJmY2M2MDY4YjE4N2Q3ZDlmYjNkNWJiMWQzYTMwODk5L2ltcGxlbWVudGF0aW9uLmpzXG5cdGZ1bmN0aW9uIGdldE5hbWUoZnVuYykge1xuXHQgIGlmICghdXRpbC5pc0Z1bmN0aW9uKGZ1bmMpKSB7XG5cdCAgICByZXR1cm47XG5cdCAgfVxuXHQgIGlmIChmdW5jdGlvbnNIYXZlTmFtZXMpIHtcblx0ICAgIHJldHVybiBmdW5jLm5hbWU7XG5cdCAgfVxuXHQgIHZhciBzdHIgPSBmdW5jLnRvU3RyaW5nKCk7XG5cdCAgdmFyIG1hdGNoID0gc3RyLm1hdGNoKHJlZ2V4KTtcblx0ICByZXR1cm4gbWF0Y2ggJiYgbWF0Y2hbMV07XG5cdH1cblx0YXNzZXJ0LkFzc2VydGlvbkVycm9yID0gZnVuY3Rpb24gQXNzZXJ0aW9uRXJyb3Iob3B0aW9ucykge1xuXHQgIHRoaXMubmFtZSA9ICdBc3NlcnRpb25FcnJvcic7XG5cdCAgdGhpcy5hY3R1YWwgPSBvcHRpb25zLmFjdHVhbDtcblx0ICB0aGlzLmV4cGVjdGVkID0gb3B0aW9ucy5leHBlY3RlZDtcblx0ICB0aGlzLm9wZXJhdG9yID0gb3B0aW9ucy5vcGVyYXRvcjtcblx0ICBpZiAob3B0aW9ucy5tZXNzYWdlKSB7XG5cdCAgICB0aGlzLm1lc3NhZ2UgPSBvcHRpb25zLm1lc3NhZ2U7XG5cdCAgICB0aGlzLmdlbmVyYXRlZE1lc3NhZ2UgPSBmYWxzZTtcblx0ICB9IGVsc2Uge1xuXHQgICAgdGhpcy5tZXNzYWdlID0gZ2V0TWVzc2FnZSh0aGlzKTtcblx0ICAgIHRoaXMuZ2VuZXJhdGVkTWVzc2FnZSA9IHRydWU7XG5cdCAgfVxuXHQgIHZhciBzdGFja1N0YXJ0RnVuY3Rpb24gPSBvcHRpb25zLnN0YWNrU3RhcnRGdW5jdGlvbiB8fCBmYWlsO1xuXHQgIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuXHQgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgc3RhY2tTdGFydEZ1bmN0aW9uKTtcblx0ICB9IGVsc2Uge1xuXHQgICAgLy8gbm9uIHY4IGJyb3dzZXJzIHNvIHdlIGNhbiBoYXZlIGEgc3RhY2t0cmFjZVxuXHQgICAgdmFyIGVyciA9IG5ldyBFcnJvcigpO1xuXHQgICAgaWYgKGVyci5zdGFjaykge1xuXHQgICAgICB2YXIgb3V0ID0gZXJyLnN0YWNrO1xuXG5cdCAgICAgIC8vIHRyeSB0byBzdHJpcCB1c2VsZXNzIGZyYW1lc1xuXHQgICAgICB2YXIgZm5fbmFtZSA9IGdldE5hbWUoc3RhY2tTdGFydEZ1bmN0aW9uKTtcblx0ICAgICAgdmFyIGlkeCA9IG91dC5pbmRleE9mKCdcXG4nICsgZm5fbmFtZSk7XG5cdCAgICAgIGlmIChpZHggPj0gMCkge1xuXHQgICAgICAgIC8vIG9uY2Ugd2UgaGF2ZSBsb2NhdGVkIHRoZSBmdW5jdGlvbiBmcmFtZVxuXHQgICAgICAgIC8vIHdlIG5lZWQgdG8gc3RyaXAgb3V0IGV2ZXJ5dGhpbmcgYmVmb3JlIGl0IChhbmQgaXRzIGxpbmUpXG5cdCAgICAgICAgdmFyIG5leHRfbGluZSA9IG91dC5pbmRleE9mKCdcXG4nLCBpZHggKyAxKTtcblx0ICAgICAgICBvdXQgPSBvdXQuc3Vic3RyaW5nKG5leHRfbGluZSArIDEpO1xuXHQgICAgICB9XG5cblx0ICAgICAgdGhpcy5zdGFjayA9IG91dDtcblx0ICAgIH1cblx0ICB9XG5cdH07XG5cblx0Ly8gYXNzZXJ0LkFzc2VydGlvbkVycm9yIGluc3RhbmNlb2YgRXJyb3Jcblx0dXRpbC5pbmhlcml0cyhhc3NlcnQuQXNzZXJ0aW9uRXJyb3IsIEVycm9yKTtcblxuXHRmdW5jdGlvbiB0cnVuY2F0ZShzLCBuKSB7XG5cdCAgaWYgKHR5cGVvZiBzID09PSAnc3RyaW5nJykge1xuXHQgICAgcmV0dXJuIHMubGVuZ3RoIDwgbiA/IHMgOiBzLnNsaWNlKDAsIG4pO1xuXHQgIH0gZWxzZSB7XG5cdCAgICByZXR1cm4gcztcblx0ICB9XG5cdH1cblx0ZnVuY3Rpb24gaW5zcGVjdChzb21ldGhpbmcpIHtcblx0ICBpZiAoZnVuY3Rpb25zSGF2ZU5hbWVzIHx8ICF1dGlsLmlzRnVuY3Rpb24oc29tZXRoaW5nKSkge1xuXHQgICAgcmV0dXJuIHV0aWwuaW5zcGVjdChzb21ldGhpbmcpO1xuXHQgIH1cblx0ICB2YXIgcmF3bmFtZSA9IGdldE5hbWUoc29tZXRoaW5nKTtcblx0ICB2YXIgbmFtZSA9IHJhd25hbWUgPyAnOiAnICsgcmF3bmFtZSA6ICcnO1xuXHQgIHJldHVybiAnW0Z1bmN0aW9uJyArICBuYW1lICsgJ10nO1xuXHR9XG5cdGZ1bmN0aW9uIGdldE1lc3NhZ2Uoc2VsZikge1xuXHQgIHJldHVybiB0cnVuY2F0ZShpbnNwZWN0KHNlbGYuYWN0dWFsKSwgMTI4KSArICcgJyArXG5cdCAgICAgICAgIHNlbGYub3BlcmF0b3IgKyAnICcgK1xuXHQgICAgICAgICB0cnVuY2F0ZShpbnNwZWN0KHNlbGYuZXhwZWN0ZWQpLCAxMjgpO1xuXHR9XG5cblx0Ly8gQXQgcHJlc2VudCBvbmx5IHRoZSB0aHJlZSBrZXlzIG1lbnRpb25lZCBhYm92ZSBhcmUgdXNlZCBhbmRcblx0Ly8gdW5kZXJzdG9vZCBieSB0aGUgc3BlYy4gSW1wbGVtZW50YXRpb25zIG9yIHN1YiBtb2R1bGVzIGNhbiBwYXNzXG5cdC8vIG90aGVyIGtleXMgdG8gdGhlIEFzc2VydGlvbkVycm9yJ3MgY29uc3RydWN0b3IgLSB0aGV5IHdpbGwgYmVcblx0Ly8gaWdub3JlZC5cblxuXHQvLyAzLiBBbGwgb2YgdGhlIGZvbGxvd2luZyBmdW5jdGlvbnMgbXVzdCB0aHJvdyBhbiBBc3NlcnRpb25FcnJvclxuXHQvLyB3aGVuIGEgY29ycmVzcG9uZGluZyBjb25kaXRpb24gaXMgbm90IG1ldCwgd2l0aCBhIG1lc3NhZ2UgdGhhdFxuXHQvLyBtYXkgYmUgdW5kZWZpbmVkIGlmIG5vdCBwcm92aWRlZC4gIEFsbCBhc3NlcnRpb24gbWV0aG9kcyBwcm92aWRlXG5cdC8vIGJvdGggdGhlIGFjdHVhbCBhbmQgZXhwZWN0ZWQgdmFsdWVzIHRvIHRoZSBhc3NlcnRpb24gZXJyb3IgZm9yXG5cdC8vIGRpc3BsYXkgcHVycG9zZXMuXG5cblx0ZnVuY3Rpb24gZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCBvcGVyYXRvciwgc3RhY2tTdGFydEZ1bmN0aW9uKSB7XG5cdCAgdGhyb3cgbmV3IGFzc2VydC5Bc3NlcnRpb25FcnJvcih7XG5cdCAgICBtZXNzYWdlOiBtZXNzYWdlLFxuXHQgICAgYWN0dWFsOiBhY3R1YWwsXG5cdCAgICBleHBlY3RlZDogZXhwZWN0ZWQsXG5cdCAgICBvcGVyYXRvcjogb3BlcmF0b3IsXG5cdCAgICBzdGFja1N0YXJ0RnVuY3Rpb246IHN0YWNrU3RhcnRGdW5jdGlvblxuXHQgIH0pO1xuXHR9XG5cblx0Ly8gRVhURU5TSU9OISBhbGxvd3MgZm9yIHdlbGwgYmVoYXZlZCBlcnJvcnMgZGVmaW5lZCBlbHNld2hlcmUuXG5cdGFzc2VydC5mYWlsID0gZmFpbDtcblxuXHQvLyA0LiBQdXJlIGFzc2VydGlvbiB0ZXN0cyB3aGV0aGVyIGEgdmFsdWUgaXMgdHJ1dGh5LCBhcyBkZXRlcm1pbmVkXG5cdC8vIGJ5ICEhZ3VhcmQuXG5cdC8vIGFzc2VydC5vayhndWFyZCwgbWVzc2FnZV9vcHQpO1xuXHQvLyBUaGlzIHN0YXRlbWVudCBpcyBlcXVpdmFsZW50IHRvIGFzc2VydC5lcXVhbCh0cnVlLCAhIWd1YXJkLFxuXHQvLyBtZXNzYWdlX29wdCk7LiBUbyB0ZXN0IHN0cmljdGx5IGZvciB0aGUgdmFsdWUgdHJ1ZSwgdXNlXG5cdC8vIGFzc2VydC5zdHJpY3RFcXVhbCh0cnVlLCBndWFyZCwgbWVzc2FnZV9vcHQpOy5cblxuXHRmdW5jdGlvbiBvayh2YWx1ZSwgbWVzc2FnZSkge1xuXHQgIGlmICghdmFsdWUpIGZhaWwodmFsdWUsIHRydWUsIG1lc3NhZ2UsICc9PScsIGFzc2VydC5vayk7XG5cdH1cblx0YXNzZXJ0Lm9rID0gb2s7XG5cblx0Ly8gNS4gVGhlIGVxdWFsaXR5IGFzc2VydGlvbiB0ZXN0cyBzaGFsbG93LCBjb2VyY2l2ZSBlcXVhbGl0eSB3aXRoXG5cdC8vID09LlxuXHQvLyBhc3NlcnQuZXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZV9vcHQpO1xuXG5cdGFzc2VydC5lcXVhbCA9IGZ1bmN0aW9uIGVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcblx0ICBpZiAoYWN0dWFsICE9IGV4cGVjdGVkKSBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICc9PScsIGFzc2VydC5lcXVhbCk7XG5cdH07XG5cblx0Ly8gNi4gVGhlIG5vbi1lcXVhbGl0eSBhc3NlcnRpb24gdGVzdHMgZm9yIHdoZXRoZXIgdHdvIG9iamVjdHMgYXJlIG5vdCBlcXVhbFxuXHQvLyB3aXRoICE9IGFzc2VydC5ub3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlX29wdCk7XG5cblx0YXNzZXJ0Lm5vdEVxdWFsID0gZnVuY3Rpb24gbm90RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuXHQgIGlmIChhY3R1YWwgPT0gZXhwZWN0ZWQpIHtcblx0ICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJyE9JywgYXNzZXJ0Lm5vdEVxdWFsKTtcblx0ICB9XG5cdH07XG5cblx0Ly8gNy4gVGhlIGVxdWl2YWxlbmNlIGFzc2VydGlvbiB0ZXN0cyBhIGRlZXAgZXF1YWxpdHkgcmVsYXRpb24uXG5cdC8vIGFzc2VydC5kZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZV9vcHQpO1xuXG5cdGFzc2VydC5kZWVwRXF1YWwgPSBmdW5jdGlvbiBkZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuXHQgIGlmICghX2RlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBmYWxzZSkpIHtcblx0ICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJ2RlZXBFcXVhbCcsIGFzc2VydC5kZWVwRXF1YWwpO1xuXHQgIH1cblx0fTtcblxuXHRhc3NlcnQuZGVlcFN0cmljdEVxdWFsID0gZnVuY3Rpb24gZGVlcFN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcblx0ICBpZiAoIV9kZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgdHJ1ZSkpIHtcblx0ICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJ2RlZXBTdHJpY3RFcXVhbCcsIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwpO1xuXHQgIH1cblx0fTtcblxuXHRmdW5jdGlvbiBfZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIHN0cmljdCwgbWVtb3MpIHtcblx0ICAvLyA3LjEuIEFsbCBpZGVudGljYWwgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBhcyBkZXRlcm1pbmVkIGJ5ID09PS5cblx0ICBpZiAoYWN0dWFsID09PSBleHBlY3RlZCkge1xuXHQgICAgcmV0dXJuIHRydWU7XG5cdCAgfSBlbHNlIGlmIChpc0J1ZmZlcihhY3R1YWwpICYmIGlzQnVmZmVyKGV4cGVjdGVkKSkge1xuXHQgICAgcmV0dXJuIGNvbXBhcmUoYWN0dWFsLCBleHBlY3RlZCkgPT09IDA7XG5cblx0ICAvLyA3LjIuIElmIHRoZSBleHBlY3RlZCB2YWx1ZSBpcyBhIERhdGUgb2JqZWN0LCB0aGUgYWN0dWFsIHZhbHVlIGlzXG5cdCAgLy8gZXF1aXZhbGVudCBpZiBpdCBpcyBhbHNvIGEgRGF0ZSBvYmplY3QgdGhhdCByZWZlcnMgdG8gdGhlIHNhbWUgdGltZS5cblx0ICB9IGVsc2UgaWYgKHV0aWwuaXNEYXRlKGFjdHVhbCkgJiYgdXRpbC5pc0RhdGUoZXhwZWN0ZWQpKSB7XG5cdCAgICByZXR1cm4gYWN0dWFsLmdldFRpbWUoKSA9PT0gZXhwZWN0ZWQuZ2V0VGltZSgpO1xuXG5cdCAgLy8gNy4zIElmIHRoZSBleHBlY3RlZCB2YWx1ZSBpcyBhIFJlZ0V4cCBvYmplY3QsIHRoZSBhY3R1YWwgdmFsdWUgaXNcblx0ICAvLyBlcXVpdmFsZW50IGlmIGl0IGlzIGFsc28gYSBSZWdFeHAgb2JqZWN0IHdpdGggdGhlIHNhbWUgc291cmNlIGFuZFxuXHQgIC8vIHByb3BlcnRpZXMgKGBnbG9iYWxgLCBgbXVsdGlsaW5lYCwgYGxhc3RJbmRleGAsIGBpZ25vcmVDYXNlYCkuXG5cdCAgfSBlbHNlIGlmICh1dGlsLmlzUmVnRXhwKGFjdHVhbCkgJiYgdXRpbC5pc1JlZ0V4cChleHBlY3RlZCkpIHtcblx0ICAgIHJldHVybiBhY3R1YWwuc291cmNlID09PSBleHBlY3RlZC5zb3VyY2UgJiZcblx0ICAgICAgICAgICBhY3R1YWwuZ2xvYmFsID09PSBleHBlY3RlZC5nbG9iYWwgJiZcblx0ICAgICAgICAgICBhY3R1YWwubXVsdGlsaW5lID09PSBleHBlY3RlZC5tdWx0aWxpbmUgJiZcblx0ICAgICAgICAgICBhY3R1YWwubGFzdEluZGV4ID09PSBleHBlY3RlZC5sYXN0SW5kZXggJiZcblx0ICAgICAgICAgICBhY3R1YWwuaWdub3JlQ2FzZSA9PT0gZXhwZWN0ZWQuaWdub3JlQ2FzZTtcblxuXHQgIC8vIDcuNC4gT3RoZXIgcGFpcnMgdGhhdCBkbyBub3QgYm90aCBwYXNzIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jyxcblx0ICAvLyBlcXVpdmFsZW5jZSBpcyBkZXRlcm1pbmVkIGJ5ID09LlxuXHQgIH0gZWxzZSBpZiAoKGFjdHVhbCA9PT0gbnVsbCB8fCB0eXBlb2YgYWN0dWFsICE9PSAnb2JqZWN0JykgJiZcblx0ICAgICAgICAgICAgIChleHBlY3RlZCA9PT0gbnVsbCB8fCB0eXBlb2YgZXhwZWN0ZWQgIT09ICdvYmplY3QnKSkge1xuXHQgICAgcmV0dXJuIHN0cmljdCA/IGFjdHVhbCA9PT0gZXhwZWN0ZWQgOiBhY3R1YWwgPT0gZXhwZWN0ZWQ7XG5cblx0ICAvLyBJZiBib3RoIHZhbHVlcyBhcmUgaW5zdGFuY2VzIG9mIHR5cGVkIGFycmF5cywgd3JhcCB0aGVpciB1bmRlcmx5aW5nXG5cdCAgLy8gQXJyYXlCdWZmZXJzIGluIGEgQnVmZmVyIGVhY2ggdG8gaW5jcmVhc2UgcGVyZm9ybWFuY2Vcblx0ICAvLyBUaGlzIG9wdGltaXphdGlvbiByZXF1aXJlcyB0aGUgYXJyYXlzIHRvIGhhdmUgdGhlIHNhbWUgdHlwZSBhcyBjaGVja2VkIGJ5XG5cdCAgLy8gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZyAoYWthIHBUb1N0cmluZykuIE5ldmVyIHBlcmZvcm0gYmluYXJ5XG5cdCAgLy8gY29tcGFyaXNvbnMgZm9yIEZsb2F0KkFycmF5cywgdGhvdWdoLCBzaW5jZSBlLmcuICswID09PSAtMCBidXQgdGhlaXJcblx0ICAvLyBiaXQgcGF0dGVybnMgYXJlIG5vdCBpZGVudGljYWwuXG5cdCAgfSBlbHNlIGlmIChpc1ZpZXcoYWN0dWFsKSAmJiBpc1ZpZXcoZXhwZWN0ZWQpICYmXG5cdCAgICAgICAgICAgICBwVG9TdHJpbmcoYWN0dWFsKSA9PT0gcFRvU3RyaW5nKGV4cGVjdGVkKSAmJlxuXHQgICAgICAgICAgICAgIShhY3R1YWwgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkgfHxcblx0ICAgICAgICAgICAgICAgYWN0dWFsIGluc3RhbmNlb2YgRmxvYXQ2NEFycmF5KSkge1xuXHQgICAgcmV0dXJuIGNvbXBhcmUobmV3IFVpbnQ4QXJyYXkoYWN0dWFsLmJ1ZmZlciksXG5cdCAgICAgICAgICAgICAgICAgICBuZXcgVWludDhBcnJheShleHBlY3RlZC5idWZmZXIpKSA9PT0gMDtcblxuXHQgIC8vIDcuNSBGb3IgYWxsIG90aGVyIE9iamVjdCBwYWlycywgaW5jbHVkaW5nIEFycmF5IG9iamVjdHMsIGVxdWl2YWxlbmNlIGlzXG5cdCAgLy8gZGV0ZXJtaW5lZCBieSBoYXZpbmcgdGhlIHNhbWUgbnVtYmVyIG9mIG93bmVkIHByb3BlcnRpZXMgKGFzIHZlcmlmaWVkXG5cdCAgLy8gd2l0aCBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwpLCB0aGUgc2FtZSBzZXQgb2Yga2V5c1xuXHQgIC8vIChhbHRob3VnaCBub3QgbmVjZXNzYXJpbHkgdGhlIHNhbWUgb3JkZXIpLCBlcXVpdmFsZW50IHZhbHVlcyBmb3IgZXZlcnlcblx0ICAvLyBjb3JyZXNwb25kaW5nIGtleSwgYW5kIGFuIGlkZW50aWNhbCAncHJvdG90eXBlJyBwcm9wZXJ0eS4gTm90ZTogdGhpc1xuXHQgIC8vIGFjY291bnRzIGZvciBib3RoIG5hbWVkIGFuZCBpbmRleGVkIHByb3BlcnRpZXMgb24gQXJyYXlzLlxuXHQgIH0gZWxzZSBpZiAoaXNCdWZmZXIoYWN0dWFsKSAhPT0gaXNCdWZmZXIoZXhwZWN0ZWQpKSB7XG5cdCAgICByZXR1cm4gZmFsc2U7XG5cdCAgfSBlbHNlIHtcblx0ICAgIG1lbW9zID0gbWVtb3MgfHwge2FjdHVhbDogW10sIGV4cGVjdGVkOiBbXX07XG5cblx0ICAgIHZhciBhY3R1YWxJbmRleCA9IG1lbW9zLmFjdHVhbC5pbmRleE9mKGFjdHVhbCk7XG5cdCAgICBpZiAoYWN0dWFsSW5kZXggIT09IC0xKSB7XG5cdCAgICAgIGlmIChhY3R1YWxJbmRleCA9PT0gbWVtb3MuZXhwZWN0ZWQuaW5kZXhPZihleHBlY3RlZCkpIHtcblx0ICAgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICBtZW1vcy5hY3R1YWwucHVzaChhY3R1YWwpO1xuXHQgICAgbWVtb3MuZXhwZWN0ZWQucHVzaChleHBlY3RlZCk7XG5cblx0ICAgIHJldHVybiBvYmpFcXVpdihhY3R1YWwsIGV4cGVjdGVkLCBzdHJpY3QsIG1lbW9zKTtcblx0ICB9XG5cdH1cblxuXHRmdW5jdGlvbiBpc0FyZ3VtZW50cyhvYmplY3QpIHtcblx0ICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iamVjdCkgPT0gJ1tvYmplY3QgQXJndW1lbnRzXSc7XG5cdH1cblxuXHRmdW5jdGlvbiBvYmpFcXVpdihhLCBiLCBzdHJpY3QsIGFjdHVhbFZpc2l0ZWRPYmplY3RzKSB7XG5cdCAgaWYgKGEgPT09IG51bGwgfHwgYSA9PT0gdW5kZWZpbmVkIHx8IGIgPT09IG51bGwgfHwgYiA9PT0gdW5kZWZpbmVkKVxuXHQgICAgcmV0dXJuIGZhbHNlO1xuXHQgIC8vIGlmIG9uZSBpcyBhIHByaW1pdGl2ZSwgdGhlIG90aGVyIG11c3QgYmUgc2FtZVxuXHQgIGlmICh1dGlsLmlzUHJpbWl0aXZlKGEpIHx8IHV0aWwuaXNQcmltaXRpdmUoYikpXG5cdCAgICByZXR1cm4gYSA9PT0gYjtcblx0ICBpZiAoc3RyaWN0ICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihhKSAhPT0gT2JqZWN0LmdldFByb3RvdHlwZU9mKGIpKVxuXHQgICAgcmV0dXJuIGZhbHNlO1xuXHQgIHZhciBhSXNBcmdzID0gaXNBcmd1bWVudHMoYSk7XG5cdCAgdmFyIGJJc0FyZ3MgPSBpc0FyZ3VtZW50cyhiKTtcblx0ICBpZiAoKGFJc0FyZ3MgJiYgIWJJc0FyZ3MpIHx8ICghYUlzQXJncyAmJiBiSXNBcmdzKSlcblx0ICAgIHJldHVybiBmYWxzZTtcblx0ICBpZiAoYUlzQXJncykge1xuXHQgICAgYSA9IHBTbGljZS5jYWxsKGEpO1xuXHQgICAgYiA9IHBTbGljZS5jYWxsKGIpO1xuXHQgICAgcmV0dXJuIF9kZWVwRXF1YWwoYSwgYiwgc3RyaWN0KTtcblx0ICB9XG5cdCAgdmFyIGthID0gb2JqZWN0S2V5cyhhKTtcblx0ICB2YXIga2IgPSBvYmplY3RLZXlzKGIpO1xuXHQgIHZhciBrZXksIGk7XG5cdCAgLy8gaGF2aW5nIHRoZSBzYW1lIG51bWJlciBvZiBvd25lZCBwcm9wZXJ0aWVzIChrZXlzIGluY29ycG9yYXRlc1xuXHQgIC8vIGhhc093blByb3BlcnR5KVxuXHQgIGlmIChrYS5sZW5ndGggIT09IGtiLmxlbmd0aClcblx0ICAgIHJldHVybiBmYWxzZTtcblx0ICAvL3RoZSBzYW1lIHNldCBvZiBrZXlzIChhbHRob3VnaCBub3QgbmVjZXNzYXJpbHkgdGhlIHNhbWUgb3JkZXIpLFxuXHQgIGthLnNvcnQoKTtcblx0ICBrYi5zb3J0KCk7XG5cdCAgLy9+fn5jaGVhcCBrZXkgdGVzdFxuXHQgIGZvciAoaSA9IGthLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdCAgICBpZiAoa2FbaV0gIT09IGtiW2ldKVxuXHQgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgfVxuXHQgIC8vZXF1aXZhbGVudCB2YWx1ZXMgZm9yIGV2ZXJ5IGNvcnJlc3BvbmRpbmcga2V5LCBhbmRcblx0ICAvL35+fnBvc3NpYmx5IGV4cGVuc2l2ZSBkZWVwIHRlc3Rcblx0ICBmb3IgKGkgPSBrYS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHQgICAga2V5ID0ga2FbaV07XG5cdCAgICBpZiAoIV9kZWVwRXF1YWwoYVtrZXldLCBiW2tleV0sIHN0cmljdCwgYWN0dWFsVmlzaXRlZE9iamVjdHMpKVxuXHQgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgfVxuXHQgIHJldHVybiB0cnVlO1xuXHR9XG5cblx0Ly8gOC4gVGhlIG5vbi1lcXVpdmFsZW5jZSBhc3NlcnRpb24gdGVzdHMgZm9yIGFueSBkZWVwIGluZXF1YWxpdHkuXG5cdC8vIGFzc2VydC5ub3REZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZV9vcHQpO1xuXG5cdGFzc2VydC5ub3REZWVwRXF1YWwgPSBmdW5jdGlvbiBub3REZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuXHQgIGlmIChfZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIGZhbHNlKSkge1xuXHQgICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnbm90RGVlcEVxdWFsJywgYXNzZXJ0Lm5vdERlZXBFcXVhbCk7XG5cdCAgfVxuXHR9O1xuXG5cdGFzc2VydC5ub3REZWVwU3RyaWN0RXF1YWwgPSBub3REZWVwU3RyaWN0RXF1YWw7XG5cdGZ1bmN0aW9uIG5vdERlZXBTdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG5cdCAgaWYgKF9kZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgdHJ1ZSkpIHtcblx0ICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJ25vdERlZXBTdHJpY3RFcXVhbCcsIG5vdERlZXBTdHJpY3RFcXVhbCk7XG5cdCAgfVxuXHR9XG5cblxuXHQvLyA5LiBUaGUgc3RyaWN0IGVxdWFsaXR5IGFzc2VydGlvbiB0ZXN0cyBzdHJpY3QgZXF1YWxpdHksIGFzIGRldGVybWluZWQgYnkgPT09LlxuXHQvLyBhc3NlcnQuc3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZV9vcHQpO1xuXG5cdGFzc2VydC5zdHJpY3RFcXVhbCA9IGZ1bmN0aW9uIHN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcblx0ICBpZiAoYWN0dWFsICE9PSBleHBlY3RlZCkge1xuXHQgICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnPT09JywgYXNzZXJ0LnN0cmljdEVxdWFsKTtcblx0ICB9XG5cdH07XG5cblx0Ly8gMTAuIFRoZSBzdHJpY3Qgbm9uLWVxdWFsaXR5IGFzc2VydGlvbiB0ZXN0cyBmb3Igc3RyaWN0IGluZXF1YWxpdHksIGFzXG5cdC8vIGRldGVybWluZWQgYnkgIT09LiAgYXNzZXJ0Lm5vdFN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2Vfb3B0KTtcblxuXHRhc3NlcnQubm90U3RyaWN0RXF1YWwgPSBmdW5jdGlvbiBub3RTdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG5cdCAgaWYgKGFjdHVhbCA9PT0gZXhwZWN0ZWQpIHtcblx0ICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJyE9PScsIGFzc2VydC5ub3RTdHJpY3RFcXVhbCk7XG5cdCAgfVxuXHR9O1xuXG5cdGZ1bmN0aW9uIGV4cGVjdGVkRXhjZXB0aW9uKGFjdHVhbCwgZXhwZWN0ZWQpIHtcblx0ICBpZiAoIWFjdHVhbCB8fCAhZXhwZWN0ZWQpIHtcblx0ICAgIHJldHVybiBmYWxzZTtcblx0ICB9XG5cblx0ICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGV4cGVjdGVkKSA9PSAnW29iamVjdCBSZWdFeHBdJykge1xuXHQgICAgcmV0dXJuIGV4cGVjdGVkLnRlc3QoYWN0dWFsKTtcblx0ICB9XG5cblx0ICB0cnkge1xuXHQgICAgaWYgKGFjdHVhbCBpbnN0YW5jZW9mIGV4cGVjdGVkKSB7XG5cdCAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgfVxuXHQgIH0gY2F0Y2ggKGUpIHtcblx0ICAgIC8vIElnbm9yZS4gIFRoZSBpbnN0YW5jZW9mIGNoZWNrIGRvZXNuJ3Qgd29yayBmb3IgYXJyb3cgZnVuY3Rpb25zLlxuXHQgIH1cblxuXHQgIGlmIChFcnJvci5pc1Byb3RvdHlwZU9mKGV4cGVjdGVkKSkge1xuXHQgICAgcmV0dXJuIGZhbHNlO1xuXHQgIH1cblxuXHQgIHJldHVybiBleHBlY3RlZC5jYWxsKHt9LCBhY3R1YWwpID09PSB0cnVlO1xuXHR9XG5cblx0ZnVuY3Rpb24gX3RyeUJsb2NrKGJsb2NrKSB7XG5cdCAgdmFyIGVycm9yO1xuXHQgIHRyeSB7XG5cdCAgICBibG9jaygpO1xuXHQgIH0gY2F0Y2ggKGUpIHtcblx0ICAgIGVycm9yID0gZTtcblx0ICB9XG5cdCAgcmV0dXJuIGVycm9yO1xuXHR9XG5cblx0ZnVuY3Rpb24gX3Rocm93cyhzaG91bGRUaHJvdywgYmxvY2ssIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG5cdCAgdmFyIGFjdHVhbDtcblxuXHQgIGlmICh0eXBlb2YgYmxvY2sgIT09ICdmdW5jdGlvbicpIHtcblx0ICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiYmxvY2tcIiBhcmd1bWVudCBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblx0ICB9XG5cblx0ICBpZiAodHlwZW9mIGV4cGVjdGVkID09PSAnc3RyaW5nJykge1xuXHQgICAgbWVzc2FnZSA9IGV4cGVjdGVkO1xuXHQgICAgZXhwZWN0ZWQgPSBudWxsO1xuXHQgIH1cblxuXHQgIGFjdHVhbCA9IF90cnlCbG9jayhibG9jayk7XG5cblx0ICBtZXNzYWdlID0gKGV4cGVjdGVkICYmIGV4cGVjdGVkLm5hbWUgPyAnICgnICsgZXhwZWN0ZWQubmFtZSArICcpLicgOiAnLicpICtcblx0ICAgICAgICAgICAgKG1lc3NhZ2UgPyAnICcgKyBtZXNzYWdlIDogJy4nKTtcblxuXHQgIGlmIChzaG91bGRUaHJvdyAmJiAhYWN0dWFsKSB7XG5cdCAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsICdNaXNzaW5nIGV4cGVjdGVkIGV4Y2VwdGlvbicgKyBtZXNzYWdlKTtcblx0ICB9XG5cblx0ICB2YXIgdXNlclByb3ZpZGVkTWVzc2FnZSA9IHR5cGVvZiBtZXNzYWdlID09PSAnc3RyaW5nJztcblx0ICB2YXIgaXNVbndhbnRlZEV4Y2VwdGlvbiA9ICFzaG91bGRUaHJvdyAmJiB1dGlsLmlzRXJyb3IoYWN0dWFsKTtcblx0ICB2YXIgaXNVbmV4cGVjdGVkRXhjZXB0aW9uID0gIXNob3VsZFRocm93ICYmIGFjdHVhbCAmJiAhZXhwZWN0ZWQ7XG5cblx0ICBpZiAoKGlzVW53YW50ZWRFeGNlcHRpb24gJiZcblx0ICAgICAgdXNlclByb3ZpZGVkTWVzc2FnZSAmJlxuXHQgICAgICBleHBlY3RlZEV4Y2VwdGlvbihhY3R1YWwsIGV4cGVjdGVkKSkgfHxcblx0ICAgICAgaXNVbmV4cGVjdGVkRXhjZXB0aW9uKSB7XG5cdCAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsICdHb3QgdW53YW50ZWQgZXhjZXB0aW9uJyArIG1lc3NhZ2UpO1xuXHQgIH1cblxuXHQgIGlmICgoc2hvdWxkVGhyb3cgJiYgYWN0dWFsICYmIGV4cGVjdGVkICYmXG5cdCAgICAgICFleHBlY3RlZEV4Y2VwdGlvbihhY3R1YWwsIGV4cGVjdGVkKSkgfHwgKCFzaG91bGRUaHJvdyAmJiBhY3R1YWwpKSB7XG5cdCAgICB0aHJvdyBhY3R1YWw7XG5cdCAgfVxuXHR9XG5cblx0Ly8gMTEuIEV4cGVjdGVkIHRvIHRocm93IGFuIGVycm9yOlxuXHQvLyBhc3NlcnQudGhyb3dzKGJsb2NrLCBFcnJvcl9vcHQsIG1lc3NhZ2Vfb3B0KTtcblxuXHRhc3NlcnQudGhyb3dzID0gZnVuY3Rpb24oYmxvY2ssIC8qb3B0aW9uYWwqL2Vycm9yLCAvKm9wdGlvbmFsKi9tZXNzYWdlKSB7XG5cdCAgX3Rocm93cyh0cnVlLCBibG9jaywgZXJyb3IsIG1lc3NhZ2UpO1xuXHR9O1xuXG5cdC8vIEVYVEVOU0lPTiEgVGhpcyBpcyBhbm5veWluZyB0byB3cml0ZSBvdXRzaWRlIHRoaXMgbW9kdWxlLlxuXHRhc3NlcnQuZG9lc05vdFRocm93ID0gZnVuY3Rpb24oYmxvY2ssIC8qb3B0aW9uYWwqL2Vycm9yLCAvKm9wdGlvbmFsKi9tZXNzYWdlKSB7XG5cdCAgX3Rocm93cyhmYWxzZSwgYmxvY2ssIGVycm9yLCBtZXNzYWdlKTtcblx0fTtcblxuXHRhc3NlcnQuaWZFcnJvciA9IGZ1bmN0aW9uKGVycikgeyBpZiAoZXJyKSB0aHJvdyBlcnI7IH07XG5cblx0Ly8gRXhwb3NlIGEgc3RyaWN0IG9ubHkgdmFyaWFudCBvZiBhc3NlcnRcblx0ZnVuY3Rpb24gc3RyaWN0KHZhbHVlLCBtZXNzYWdlKSB7XG5cdCAgaWYgKCF2YWx1ZSkgZmFpbCh2YWx1ZSwgdHJ1ZSwgbWVzc2FnZSwgJz09Jywgc3RyaWN0KTtcblx0fVxuXHRhc3NlcnQuc3RyaWN0ID0gb2JqZWN0QXNzaWduKHN0cmljdCwgYXNzZXJ0LCB7XG5cdCAgZXF1YWw6IGFzc2VydC5zdHJpY3RFcXVhbCxcblx0ICBkZWVwRXF1YWw6IGFzc2VydC5kZWVwU3RyaWN0RXF1YWwsXG5cdCAgbm90RXF1YWw6IGFzc2VydC5ub3RTdHJpY3RFcXVhbCxcblx0ICBub3REZWVwRXF1YWw6IGFzc2VydC5ub3REZWVwU3RyaWN0RXF1YWxcblx0fSk7XG5cdGFzc2VydC5zdHJpY3Quc3RyaWN0ID0gYXNzZXJ0LnN0cmljdDtcblxuXHR2YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIChvYmopIHtcblx0ICB2YXIga2V5cyA9IFtdO1xuXHQgIGZvciAodmFyIGtleSBpbiBvYmopIHtcblx0ICAgIGlmIChoYXNPd24uY2FsbChvYmosIGtleSkpIGtleXMucHVzaChrZXkpO1xuXHQgIH1cblx0ICByZXR1cm4ga2V5cztcblx0fTtcblxuXHQvKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwoZXhwb3J0cywgKGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSgpKSkpXG5cbi8qKiovIH0pLFxuLyogMjIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHQvKlxuXHRvYmplY3QtYXNzaWduXG5cdChjKSBTaW5kcmUgU29yaHVzXG5cdEBsaWNlbnNlIE1JVFxuXHQqL1xuXG5cdCd1c2Ugc3RyaWN0Jztcblx0LyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cblx0dmFyIGdldE93blByb3BlcnR5U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG5cdHZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cdHZhciBwcm9wSXNFbnVtZXJhYmxlID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuXHRmdW5jdGlvbiB0b09iamVjdCh2YWwpIHtcblx0XHRpZiAodmFsID09PSBudWxsIHx8IHZhbCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdPYmplY3QuYXNzaWduIGNhbm5vdCBiZSBjYWxsZWQgd2l0aCBudWxsIG9yIHVuZGVmaW5lZCcpO1xuXHRcdH1cblxuXHRcdHJldHVybiBPYmplY3QodmFsKTtcblx0fVxuXG5cdGZ1bmN0aW9uIHNob3VsZFVzZU5hdGl2ZSgpIHtcblx0XHR0cnkge1xuXHRcdFx0aWYgKCFPYmplY3QuYXNzaWduKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gRGV0ZWN0IGJ1Z2d5IHByb3BlcnR5IGVudW1lcmF0aW9uIG9yZGVyIGluIG9sZGVyIFY4IHZlcnNpb25zLlxuXG5cdFx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD00MTE4XG5cdFx0XHR2YXIgdGVzdDEgPSBuZXcgU3RyaW5nKCdhYmMnKTsgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3LXdyYXBwZXJzXG5cdFx0XHR0ZXN0MVs1XSA9ICdkZSc7XG5cdFx0XHRpZiAoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGVzdDEpWzBdID09PSAnNScpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMDU2XG5cdFx0XHR2YXIgdGVzdDIgPSB7fTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgMTA7IGkrKykge1xuXHRcdFx0XHR0ZXN0MlsnXycgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGkpXSA9IGk7XG5cdFx0XHR9XG5cdFx0XHR2YXIgb3JkZXIyID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGVzdDIpLm1hcChmdW5jdGlvbiAobikge1xuXHRcdFx0XHRyZXR1cm4gdGVzdDJbbl07XG5cdFx0XHR9KTtcblx0XHRcdGlmIChvcmRlcjIuam9pbignJykgIT09ICcwMTIzNDU2Nzg5Jykge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTMwNTZcblx0XHRcdHZhciB0ZXN0MyA9IHt9O1xuXHRcdFx0J2FiY2RlZmdoaWprbG1ub3BxcnN0Jy5zcGxpdCgnJykuZm9yRWFjaChmdW5jdGlvbiAobGV0dGVyKSB7XG5cdFx0XHRcdHRlc3QzW2xldHRlcl0gPSBsZXR0ZXI7XG5cdFx0XHR9KTtcblx0XHRcdGlmIChPYmplY3Qua2V5cyhPYmplY3QuYXNzaWduKHt9LCB0ZXN0MykpLmpvaW4oJycpICE9PVxuXHRcdFx0XHRcdCdhYmNkZWZnaGlqa2xtbm9wcXJzdCcpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9IGNhdGNoIChlcnIpIHtcblx0XHRcdC8vIFdlIGRvbid0IGV4cGVjdCBhbnkgb2YgdGhlIGFib3ZlIHRvIHRocm93LCBidXQgYmV0dGVyIHRvIGJlIHNhZmUuXG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHR9XG5cblx0bW9kdWxlLmV4cG9ydHMgPSBzaG91bGRVc2VOYXRpdmUoKSA/IE9iamVjdC5hc3NpZ24gOiBmdW5jdGlvbiAodGFyZ2V0LCBzb3VyY2UpIHtcblx0XHR2YXIgZnJvbTtcblx0XHR2YXIgdG8gPSB0b09iamVjdCh0YXJnZXQpO1xuXHRcdHZhciBzeW1ib2xzO1xuXG5cdFx0Zm9yICh2YXIgcyA9IDE7IHMgPCBhcmd1bWVudHMubGVuZ3RoOyBzKyspIHtcblx0XHRcdGZyb20gPSBPYmplY3QoYXJndW1lbnRzW3NdKTtcblxuXHRcdFx0Zm9yICh2YXIga2V5IGluIGZyb20pIHtcblx0XHRcdFx0aWYgKGhhc093blByb3BlcnR5LmNhbGwoZnJvbSwga2V5KSkge1xuXHRcdFx0XHRcdHRvW2tleV0gPSBmcm9tW2tleV07XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKGdldE93blByb3BlcnR5U3ltYm9scykge1xuXHRcdFx0XHRzeW1ib2xzID0gZ2V0T3duUHJvcGVydHlTeW1ib2xzKGZyb20pO1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHN5bWJvbHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRpZiAocHJvcElzRW51bWVyYWJsZS5jYWxsKGZyb20sIHN5bWJvbHNbaV0pKSB7XG5cdFx0XHRcdFx0XHR0b1tzeW1ib2xzW2ldXSA9IGZyb21bc3ltYm9sc1tpXV07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRvO1xuXHR9O1xuXG5cbi8qKiovIH0pLFxuLyogMjMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQvKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi8oZnVuY3Rpb24oZ2xvYmFsLCBwcm9jZXNzKSB7Ly8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG5cdC8vXG5cdC8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG5cdC8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcblx0Ly8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG5cdC8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcblx0Ly8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuXHQvLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcblx0Ly8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cdC8vXG5cdC8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG5cdC8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXHQvL1xuXHQvLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG5cdC8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcblx0Ly8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuXHQvLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcblx0Ly8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG5cdC8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcblx0Ly8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuXHR2YXIgZm9ybWF0UmVnRXhwID0gLyVbc2RqJV0vZztcblx0ZXhwb3J0cy5mb3JtYXQgPSBmdW5jdGlvbihmKSB7XG5cdCAgaWYgKCFpc1N0cmluZyhmKSkge1xuXHQgICAgdmFyIG9iamVjdHMgPSBbXTtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIG9iamVjdHMucHVzaChpbnNwZWN0KGFyZ3VtZW50c1tpXSkpO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIG9iamVjdHMuam9pbignICcpO1xuXHQgIH1cblxuXHQgIHZhciBpID0gMTtcblx0ICB2YXIgYXJncyA9IGFyZ3VtZW50cztcblx0ICB2YXIgbGVuID0gYXJncy5sZW5ndGg7XG5cdCAgdmFyIHN0ciA9IFN0cmluZyhmKS5yZXBsYWNlKGZvcm1hdFJlZ0V4cCwgZnVuY3Rpb24oeCkge1xuXHQgICAgaWYgKHggPT09ICclJScpIHJldHVybiAnJSc7XG5cdCAgICBpZiAoaSA+PSBsZW4pIHJldHVybiB4O1xuXHQgICAgc3dpdGNoICh4KSB7XG5cdCAgICAgIGNhc2UgJyVzJzogcmV0dXJuIFN0cmluZyhhcmdzW2krK10pO1xuXHQgICAgICBjYXNlICclZCc6IHJldHVybiBOdW1iZXIoYXJnc1tpKytdKTtcblx0ICAgICAgY2FzZSAnJWonOlxuXHQgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoYXJnc1tpKytdKTtcblx0ICAgICAgICB9IGNhdGNoIChfKSB7XG5cdCAgICAgICAgICByZXR1cm4gJ1tDaXJjdWxhcl0nO1xuXHQgICAgICAgIH1cblx0ICAgICAgZGVmYXVsdDpcblx0ICAgICAgICByZXR1cm4geDtcblx0ICAgIH1cblx0ICB9KTtcblx0ICBmb3IgKHZhciB4ID0gYXJnc1tpXTsgaSA8IGxlbjsgeCA9IGFyZ3NbKytpXSkge1xuXHQgICAgaWYgKGlzTnVsbCh4KSB8fCAhaXNPYmplY3QoeCkpIHtcblx0ICAgICAgc3RyICs9ICcgJyArIHg7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBzdHIgKz0gJyAnICsgaW5zcGVjdCh4KTtcblx0ICAgIH1cblx0ICB9XG5cdCAgcmV0dXJuIHN0cjtcblx0fTtcblxuXG5cdC8vIE1hcmsgdGhhdCBhIG1ldGhvZCBzaG91bGQgbm90IGJlIHVzZWQuXG5cdC8vIFJldHVybnMgYSBtb2RpZmllZCBmdW5jdGlvbiB3aGljaCB3YXJucyBvbmNlIGJ5IGRlZmF1bHQuXG5cdC8vIElmIC0tbm8tZGVwcmVjYXRpb24gaXMgc2V0LCB0aGVuIGl0IGlzIGEgbm8tb3AuXG5cdGV4cG9ydHMuZGVwcmVjYXRlID0gZnVuY3Rpb24oZm4sIG1zZykge1xuXHQgIC8vIEFsbG93IGZvciBkZXByZWNhdGluZyB0aGluZ3MgaW4gdGhlIHByb2Nlc3Mgb2Ygc3RhcnRpbmcgdXAuXG5cdCAgaWYgKGlzVW5kZWZpbmVkKGdsb2JhbC5wcm9jZXNzKSkge1xuXHQgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuXHQgICAgICByZXR1cm4gZXhwb3J0cy5kZXByZWNhdGUoZm4sIG1zZykuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0ICAgIH07XG5cdCAgfVxuXG5cdCAgaWYgKHByb2Nlc3Mubm9EZXByZWNhdGlvbiA9PT0gdHJ1ZSkge1xuXHQgICAgcmV0dXJuIGZuO1xuXHQgIH1cblxuXHQgIHZhciB3YXJuZWQgPSBmYWxzZTtcblx0ICBmdW5jdGlvbiBkZXByZWNhdGVkKCkge1xuXHQgICAgaWYgKCF3YXJuZWQpIHtcblx0ICAgICAgaWYgKHByb2Nlc3MudGhyb3dEZXByZWNhdGlvbikge1xuXHQgICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuXHQgICAgICB9IGVsc2UgaWYgKHByb2Nlc3MudHJhY2VEZXByZWNhdGlvbikge1xuXHQgICAgICAgIGNvbnNvbGUudHJhY2UobXNnKTtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICBjb25zb2xlLmVycm9yKG1zZyk7XG5cdCAgICAgIH1cblx0ICAgICAgd2FybmVkID0gdHJ1ZTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHQgIH1cblxuXHQgIHJldHVybiBkZXByZWNhdGVkO1xuXHR9O1xuXG5cblx0dmFyIGRlYnVncyA9IHt9O1xuXHR2YXIgZGVidWdFbnZpcm9uO1xuXHRleHBvcnRzLmRlYnVnbG9nID0gZnVuY3Rpb24oc2V0KSB7XG5cdCAgaWYgKGlzVW5kZWZpbmVkKGRlYnVnRW52aXJvbikpXG5cdCAgICBkZWJ1Z0Vudmlyb24gPSBwcm9jZXNzLmVudi5OT0RFX0RFQlVHIHx8ICcnO1xuXHQgIHNldCA9IHNldC50b1VwcGVyQ2FzZSgpO1xuXHQgIGlmICghZGVidWdzW3NldF0pIHtcblx0ICAgIGlmIChuZXcgUmVnRXhwKCdcXFxcYicgKyBzZXQgKyAnXFxcXGInLCAnaScpLnRlc3QoZGVidWdFbnZpcm9uKSkge1xuXHQgICAgICB2YXIgcGlkID0gcHJvY2Vzcy5waWQ7XG5cdCAgICAgIGRlYnVnc1tzZXRdID0gZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgdmFyIG1zZyA9IGV4cG9ydHMuZm9ybWF0LmFwcGx5KGV4cG9ydHMsIGFyZ3VtZW50cyk7XG5cdCAgICAgICAgY29uc29sZS5lcnJvcignJXMgJWQ6ICVzJywgc2V0LCBwaWQsIG1zZyk7XG5cdCAgICAgIH07XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBkZWJ1Z3Nbc2V0XSA9IGZ1bmN0aW9uKCkge307XG5cdCAgICB9XG5cdCAgfVxuXHQgIHJldHVybiBkZWJ1Z3Nbc2V0XTtcblx0fTtcblxuXG5cdC8qKlxuXHQgKiBFY2hvcyB0aGUgdmFsdWUgb2YgYSB2YWx1ZS4gVHJ5cyB0byBwcmludCB0aGUgdmFsdWUgb3V0XG5cdCAqIGluIHRoZSBiZXN0IHdheSBwb3NzaWJsZSBnaXZlbiB0aGUgZGlmZmVyZW50IHR5cGVzLlxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gcHJpbnQgb3V0LlxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3B0cyBPcHRpb25hbCBvcHRpb25zIG9iamVjdCB0aGF0IGFsdGVycyB0aGUgb3V0cHV0LlxuXHQgKi9cblx0LyogbGVnYWN5OiBvYmosIHNob3dIaWRkZW4sIGRlcHRoLCBjb2xvcnMqL1xuXHRmdW5jdGlvbiBpbnNwZWN0KG9iaiwgb3B0cykge1xuXHQgIC8vIGRlZmF1bHQgb3B0aW9uc1xuXHQgIHZhciBjdHggPSB7XG5cdCAgICBzZWVuOiBbXSxcblx0ICAgIHN0eWxpemU6IHN0eWxpemVOb0NvbG9yXG5cdCAgfTtcblx0ICAvLyBsZWdhY3kuLi5cblx0ICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAzKSBjdHguZGVwdGggPSBhcmd1bWVudHNbMl07XG5cdCAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gNCkgY3R4LmNvbG9ycyA9IGFyZ3VtZW50c1szXTtcblx0ICBpZiAoaXNCb29sZWFuKG9wdHMpKSB7XG5cdCAgICAvLyBsZWdhY3kuLi5cblx0ICAgIGN0eC5zaG93SGlkZGVuID0gb3B0cztcblx0ICB9IGVsc2UgaWYgKG9wdHMpIHtcblx0ICAgIC8vIGdvdCBhbiBcIm9wdGlvbnNcIiBvYmplY3Rcblx0ICAgIGV4cG9ydHMuX2V4dGVuZChjdHgsIG9wdHMpO1xuXHQgIH1cblx0ICAvLyBzZXQgZGVmYXVsdCBvcHRpb25zXG5cdCAgaWYgKGlzVW5kZWZpbmVkKGN0eC5zaG93SGlkZGVuKSkgY3R4LnNob3dIaWRkZW4gPSBmYWxzZTtcblx0ICBpZiAoaXNVbmRlZmluZWQoY3R4LmRlcHRoKSkgY3R4LmRlcHRoID0gMjtcblx0ICBpZiAoaXNVbmRlZmluZWQoY3R4LmNvbG9ycykpIGN0eC5jb2xvcnMgPSBmYWxzZTtcblx0ICBpZiAoaXNVbmRlZmluZWQoY3R4LmN1c3RvbUluc3BlY3QpKSBjdHguY3VzdG9tSW5zcGVjdCA9IHRydWU7XG5cdCAgaWYgKGN0eC5jb2xvcnMpIGN0eC5zdHlsaXplID0gc3R5bGl6ZVdpdGhDb2xvcjtcblx0ICByZXR1cm4gZm9ybWF0VmFsdWUoY3R4LCBvYmosIGN0eC5kZXB0aCk7XG5cdH1cblx0ZXhwb3J0cy5pbnNwZWN0ID0gaW5zcGVjdDtcblxuXG5cdC8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQU5TSV9lc2NhcGVfY29kZSNncmFwaGljc1xuXHRpbnNwZWN0LmNvbG9ycyA9IHtcblx0ICAnYm9sZCcgOiBbMSwgMjJdLFxuXHQgICdpdGFsaWMnIDogWzMsIDIzXSxcblx0ICAndW5kZXJsaW5lJyA6IFs0LCAyNF0sXG5cdCAgJ2ludmVyc2UnIDogWzcsIDI3XSxcblx0ICAnd2hpdGUnIDogWzM3LCAzOV0sXG5cdCAgJ2dyZXknIDogWzkwLCAzOV0sXG5cdCAgJ2JsYWNrJyA6IFszMCwgMzldLFxuXHQgICdibHVlJyA6IFszNCwgMzldLFxuXHQgICdjeWFuJyA6IFszNiwgMzldLFxuXHQgICdncmVlbicgOiBbMzIsIDM5XSxcblx0ICAnbWFnZW50YScgOiBbMzUsIDM5XSxcblx0ICAncmVkJyA6IFszMSwgMzldLFxuXHQgICd5ZWxsb3cnIDogWzMzLCAzOV1cblx0fTtcblxuXHQvLyBEb24ndCB1c2UgJ2JsdWUnIG5vdCB2aXNpYmxlIG9uIGNtZC5leGVcblx0aW5zcGVjdC5zdHlsZXMgPSB7XG5cdCAgJ3NwZWNpYWwnOiAnY3lhbicsXG5cdCAgJ251bWJlcic6ICd5ZWxsb3cnLFxuXHQgICdib29sZWFuJzogJ3llbGxvdycsXG5cdCAgJ3VuZGVmaW5lZCc6ICdncmV5Jyxcblx0ICAnbnVsbCc6ICdib2xkJyxcblx0ICAnc3RyaW5nJzogJ2dyZWVuJyxcblx0ICAnZGF0ZSc6ICdtYWdlbnRhJyxcblx0ICAvLyBcIm5hbWVcIjogaW50ZW50aW9uYWxseSBub3Qgc3R5bGluZ1xuXHQgICdyZWdleHAnOiAncmVkJ1xuXHR9O1xuXG5cblx0ZnVuY3Rpb24gc3R5bGl6ZVdpdGhDb2xvcihzdHIsIHN0eWxlVHlwZSkge1xuXHQgIHZhciBzdHlsZSA9IGluc3BlY3Quc3R5bGVzW3N0eWxlVHlwZV07XG5cblx0ICBpZiAoc3R5bGUpIHtcblx0ICAgIHJldHVybiAnXFx1MDAxYlsnICsgaW5zcGVjdC5jb2xvcnNbc3R5bGVdWzBdICsgJ20nICsgc3RyICtcblx0ICAgICAgICAgICAnXFx1MDAxYlsnICsgaW5zcGVjdC5jb2xvcnNbc3R5bGVdWzFdICsgJ20nO1xuXHQgIH0gZWxzZSB7XG5cdCAgICByZXR1cm4gc3RyO1xuXHQgIH1cblx0fVxuXG5cblx0ZnVuY3Rpb24gc3R5bGl6ZU5vQ29sb3Ioc3RyLCBzdHlsZVR5cGUpIHtcblx0ICByZXR1cm4gc3RyO1xuXHR9XG5cblxuXHRmdW5jdGlvbiBhcnJheVRvSGFzaChhcnJheSkge1xuXHQgIHZhciBoYXNoID0ge307XG5cblx0ICBhcnJheS5mb3JFYWNoKGZ1bmN0aW9uKHZhbCwgaWR4KSB7XG5cdCAgICBoYXNoW3ZhbF0gPSB0cnVlO1xuXHQgIH0pO1xuXG5cdCAgcmV0dXJuIGhhc2g7XG5cdH1cblxuXG5cdGZ1bmN0aW9uIGZvcm1hdFZhbHVlKGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcykge1xuXHQgIC8vIFByb3ZpZGUgYSBob29rIGZvciB1c2VyLXNwZWNpZmllZCBpbnNwZWN0IGZ1bmN0aW9ucy5cblx0ICAvLyBDaGVjayB0aGF0IHZhbHVlIGlzIGFuIG9iamVjdCB3aXRoIGFuIGluc3BlY3QgZnVuY3Rpb24gb24gaXRcblx0ICBpZiAoY3R4LmN1c3RvbUluc3BlY3QgJiZcblx0ICAgICAgdmFsdWUgJiZcblx0ICAgICAgaXNGdW5jdGlvbih2YWx1ZS5pbnNwZWN0KSAmJlxuXHQgICAgICAvLyBGaWx0ZXIgb3V0IHRoZSB1dGlsIG1vZHVsZSwgaXQncyBpbnNwZWN0IGZ1bmN0aW9uIGlzIHNwZWNpYWxcblx0ICAgICAgdmFsdWUuaW5zcGVjdCAhPT0gZXhwb3J0cy5pbnNwZWN0ICYmXG5cdCAgICAgIC8vIEFsc28gZmlsdGVyIG91dCBhbnkgcHJvdG90eXBlIG9iamVjdHMgdXNpbmcgdGhlIGNpcmN1bGFyIGNoZWNrLlxuXHQgICAgICAhKHZhbHVlLmNvbnN0cnVjdG9yICYmIHZhbHVlLmNvbnN0cnVjdG9yLnByb3RvdHlwZSA9PT0gdmFsdWUpKSB7XG5cdCAgICB2YXIgcmV0ID0gdmFsdWUuaW5zcGVjdChyZWN1cnNlVGltZXMsIGN0eCk7XG5cdCAgICBpZiAoIWlzU3RyaW5nKHJldCkpIHtcblx0ICAgICAgcmV0ID0gZm9ybWF0VmFsdWUoY3R4LCByZXQsIHJlY3Vyc2VUaW1lcyk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gcmV0O1xuXHQgIH1cblxuXHQgIC8vIFByaW1pdGl2ZSB0eXBlcyBjYW5ub3QgaGF2ZSBwcm9wZXJ0aWVzXG5cdCAgdmFyIHByaW1pdGl2ZSA9IGZvcm1hdFByaW1pdGl2ZShjdHgsIHZhbHVlKTtcblx0ICBpZiAocHJpbWl0aXZlKSB7XG5cdCAgICByZXR1cm4gcHJpbWl0aXZlO1xuXHQgIH1cblxuXHQgIC8vIExvb2sgdXAgdGhlIGtleXMgb2YgdGhlIG9iamVjdC5cblx0ICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHZhbHVlKTtcblx0ICB2YXIgdmlzaWJsZUtleXMgPSBhcnJheVRvSGFzaChrZXlzKTtcblxuXHQgIGlmIChjdHguc2hvd0hpZGRlbikge1xuXHQgICAga2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHZhbHVlKTtcblx0ICB9XG5cblx0ICAvLyBJRSBkb2Vzbid0IG1ha2UgZXJyb3IgZmllbGRzIG5vbi1lbnVtZXJhYmxlXG5cdCAgLy8gaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2llL2R3dzUyc2J0KHY9dnMuOTQpLmFzcHhcblx0ICBpZiAoaXNFcnJvcih2YWx1ZSlcblx0ICAgICAgJiYgKGtleXMuaW5kZXhPZignbWVzc2FnZScpID49IDAgfHwga2V5cy5pbmRleE9mKCdkZXNjcmlwdGlvbicpID49IDApKSB7XG5cdCAgICByZXR1cm4gZm9ybWF0RXJyb3IodmFsdWUpO1xuXHQgIH1cblxuXHQgIC8vIFNvbWUgdHlwZSBvZiBvYmplY3Qgd2l0aG91dCBwcm9wZXJ0aWVzIGNhbiBiZSBzaG9ydGN1dHRlZC5cblx0ICBpZiAoa2V5cy5sZW5ndGggPT09IDApIHtcblx0ICAgIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuXHQgICAgICB2YXIgbmFtZSA9IHZhbHVlLm5hbWUgPyAnOiAnICsgdmFsdWUubmFtZSA6ICcnO1xuXHQgICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ1tGdW5jdGlvbicgKyBuYW1lICsgJ10nLCAnc3BlY2lhbCcpO1xuXHQgICAgfVxuXHQgICAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuXHQgICAgICByZXR1cm4gY3R4LnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ3JlZ2V4cCcpO1xuXHQgICAgfVxuXHQgICAgaWYgKGlzRGF0ZSh2YWx1ZSkpIHtcblx0ICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAnZGF0ZScpO1xuXHQgICAgfVxuXHQgICAgaWYgKGlzRXJyb3IodmFsdWUpKSB7XG5cdCAgICAgIHJldHVybiBmb3JtYXRFcnJvcih2YWx1ZSk7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgdmFyIGJhc2UgPSAnJywgYXJyYXkgPSBmYWxzZSwgYnJhY2VzID0gWyd7JywgJ30nXTtcblxuXHQgIC8vIE1ha2UgQXJyYXkgc2F5IHRoYXQgdGhleSBhcmUgQXJyYXlcblx0ICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcblx0ICAgIGFycmF5ID0gdHJ1ZTtcblx0ICAgIGJyYWNlcyA9IFsnWycsICddJ107XG5cdCAgfVxuXG5cdCAgLy8gTWFrZSBmdW5jdGlvbnMgc2F5IHRoYXQgdGhleSBhcmUgZnVuY3Rpb25zXG5cdCAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG5cdCAgICB2YXIgbiA9IHZhbHVlLm5hbWUgPyAnOiAnICsgdmFsdWUubmFtZSA6ICcnO1xuXHQgICAgYmFzZSA9ICcgW0Z1bmN0aW9uJyArIG4gKyAnXSc7XG5cdCAgfVxuXG5cdCAgLy8gTWFrZSBSZWdFeHBzIHNheSB0aGF0IHRoZXkgYXJlIFJlZ0V4cHNcblx0ICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG5cdCAgICBiYXNlID0gJyAnICsgUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKTtcblx0ICB9XG5cblx0ICAvLyBNYWtlIGRhdGVzIHdpdGggcHJvcGVydGllcyBmaXJzdCBzYXkgdGhlIGRhdGVcblx0ICBpZiAoaXNEYXRlKHZhbHVlKSkge1xuXHQgICAgYmFzZSA9ICcgJyArIERhdGUucHJvdG90eXBlLnRvVVRDU3RyaW5nLmNhbGwodmFsdWUpO1xuXHQgIH1cblxuXHQgIC8vIE1ha2UgZXJyb3Igd2l0aCBtZXNzYWdlIGZpcnN0IHNheSB0aGUgZXJyb3Jcblx0ICBpZiAoaXNFcnJvcih2YWx1ZSkpIHtcblx0ICAgIGJhc2UgPSAnICcgKyBmb3JtYXRFcnJvcih2YWx1ZSk7XG5cdCAgfVxuXG5cdCAgaWYgKGtleXMubGVuZ3RoID09PSAwICYmICghYXJyYXkgfHwgdmFsdWUubGVuZ3RoID09IDApKSB7XG5cdCAgICByZXR1cm4gYnJhY2VzWzBdICsgYmFzZSArIGJyYWNlc1sxXTtcblx0ICB9XG5cblx0ICBpZiAocmVjdXJzZVRpbWVzIDwgMCkge1xuXHQgICAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuXHQgICAgICByZXR1cm4gY3R4LnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ3JlZ2V4cCcpO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCdbT2JqZWN0XScsICdzcGVjaWFsJyk7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgY3R4LnNlZW4ucHVzaCh2YWx1ZSk7XG5cblx0ICB2YXIgb3V0cHV0O1xuXHQgIGlmIChhcnJheSkge1xuXHQgICAgb3V0cHV0ID0gZm9ybWF0QXJyYXkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5cyk7XG5cdCAgfSBlbHNlIHtcblx0ICAgIG91dHB1dCA9IGtleXMubWFwKGZ1bmN0aW9uKGtleSkge1xuXHQgICAgICByZXR1cm4gZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5LCBhcnJheSk7XG5cdCAgICB9KTtcblx0ICB9XG5cblx0ICBjdHguc2Vlbi5wb3AoKTtcblxuXHQgIHJldHVybiByZWR1Y2VUb1NpbmdsZVN0cmluZyhvdXRwdXQsIGJhc2UsIGJyYWNlcyk7XG5cdH1cblxuXG5cdGZ1bmN0aW9uIGZvcm1hdFByaW1pdGl2ZShjdHgsIHZhbHVlKSB7XG5cdCAgaWYgKGlzVW5kZWZpbmVkKHZhbHVlKSlcblx0ICAgIHJldHVybiBjdHguc3R5bGl6ZSgndW5kZWZpbmVkJywgJ3VuZGVmaW5lZCcpO1xuXHQgIGlmIChpc1N0cmluZyh2YWx1ZSkpIHtcblx0ICAgIHZhciBzaW1wbGUgPSAnXFwnJyArIEpTT04uc3RyaW5naWZ5KHZhbHVlKS5yZXBsYWNlKC9eXCJ8XCIkL2csICcnKVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvJy9nLCBcIlxcXFwnXCIpXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcXCIvZywgJ1wiJykgKyAnXFwnJztcblx0ICAgIHJldHVybiBjdHguc3R5bGl6ZShzaW1wbGUsICdzdHJpbmcnKTtcblx0ICB9XG5cdCAgaWYgKGlzTnVtYmVyKHZhbHVlKSlcblx0ICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnbnVtYmVyJyk7XG5cdCAgaWYgKGlzQm9vbGVhbih2YWx1ZSkpXG5cdCAgICByZXR1cm4gY3R4LnN0eWxpemUoJycgKyB2YWx1ZSwgJ2Jvb2xlYW4nKTtcblx0ICAvLyBGb3Igc29tZSByZWFzb24gdHlwZW9mIG51bGwgaXMgXCJvYmplY3RcIiwgc28gc3BlY2lhbCBjYXNlIGhlcmUuXG5cdCAgaWYgKGlzTnVsbCh2YWx1ZSkpXG5cdCAgICByZXR1cm4gY3R4LnN0eWxpemUoJ251bGwnLCAnbnVsbCcpO1xuXHR9XG5cblxuXHRmdW5jdGlvbiBmb3JtYXRFcnJvcih2YWx1ZSkge1xuXHQgIHJldHVybiAnWycgKyBFcnJvci5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgKyAnXSc7XG5cdH1cblxuXG5cdGZ1bmN0aW9uIGZvcm1hdEFycmF5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleXMpIHtcblx0ICB2YXIgb3V0cHV0ID0gW107XG5cdCAgZm9yICh2YXIgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyArK2kpIHtcblx0ICAgIGlmIChoYXNPd25Qcm9wZXJ0eSh2YWx1ZSwgU3RyaW5nKGkpKSkge1xuXHQgICAgICBvdXRwdXQucHVzaChmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLFxuXHQgICAgICAgICAgU3RyaW5nKGkpLCB0cnVlKSk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBvdXRwdXQucHVzaCgnJyk7XG5cdCAgICB9XG5cdCAgfVxuXHQgIGtleXMuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcblx0ICAgIGlmICgha2V5Lm1hdGNoKC9eXFxkKyQvKSkge1xuXHQgICAgICBvdXRwdXQucHVzaChmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLFxuXHQgICAgICAgICAga2V5LCB0cnVlKSk7XG5cdCAgICB9XG5cdCAgfSk7XG5cdCAgcmV0dXJuIG91dHB1dDtcblx0fVxuXG5cblx0ZnVuY3Rpb24gZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5LCBhcnJheSkge1xuXHQgIHZhciBuYW1lLCBzdHIsIGRlc2M7XG5cdCAgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodmFsdWUsIGtleSkgfHwgeyB2YWx1ZTogdmFsdWVba2V5XSB9O1xuXHQgIGlmIChkZXNjLmdldCkge1xuXHQgICAgaWYgKGRlc2Muc2V0KSB7XG5cdCAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbR2V0dGVyL1NldHRlcl0nLCAnc3BlY2lhbCcpO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tHZXR0ZXJdJywgJ3NwZWNpYWwnKTtcblx0ICAgIH1cblx0ICB9IGVsc2Uge1xuXHQgICAgaWYgKGRlc2Muc2V0KSB7XG5cdCAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbU2V0dGVyXScsICdzcGVjaWFsJyk7XG5cdCAgICB9XG5cdCAgfVxuXHQgIGlmICghaGFzT3duUHJvcGVydHkodmlzaWJsZUtleXMsIGtleSkpIHtcblx0ICAgIG5hbWUgPSAnWycgKyBrZXkgKyAnXSc7XG5cdCAgfVxuXHQgIGlmICghc3RyKSB7XG5cdCAgICBpZiAoY3R4LnNlZW4uaW5kZXhPZihkZXNjLnZhbHVlKSA8IDApIHtcblx0ICAgICAgaWYgKGlzTnVsbChyZWN1cnNlVGltZXMpKSB7XG5cdCAgICAgICAgc3RyID0gZm9ybWF0VmFsdWUoY3R4LCBkZXNjLnZhbHVlLCBudWxsKTtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICBzdHIgPSBmb3JtYXRWYWx1ZShjdHgsIGRlc2MudmFsdWUsIHJlY3Vyc2VUaW1lcyAtIDEpO1xuXHQgICAgICB9XG5cdCAgICAgIGlmIChzdHIuaW5kZXhPZignXFxuJykgPiAtMSkge1xuXHQgICAgICAgIGlmIChhcnJheSkge1xuXHQgICAgICAgICAgc3RyID0gc3RyLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xuXHQgICAgICAgICAgICByZXR1cm4gJyAgJyArIGxpbmU7XG5cdCAgICAgICAgICB9KS5qb2luKCdcXG4nKS5zdWJzdHIoMik7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgIHN0ciA9ICdcXG4nICsgc3RyLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xuXHQgICAgICAgICAgICByZXR1cm4gJyAgICcgKyBsaW5lO1xuXHQgICAgICAgICAgfSkuam9pbignXFxuJyk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0NpcmN1bGFyXScsICdzcGVjaWFsJyk7XG5cdCAgICB9XG5cdCAgfVxuXHQgIGlmIChpc1VuZGVmaW5lZChuYW1lKSkge1xuXHQgICAgaWYgKGFycmF5ICYmIGtleS5tYXRjaCgvXlxcZCskLykpIHtcblx0ICAgICAgcmV0dXJuIHN0cjtcblx0ICAgIH1cblx0ICAgIG5hbWUgPSBKU09OLnN0cmluZ2lmeSgnJyArIGtleSk7XG5cdCAgICBpZiAobmFtZS5tYXRjaCgvXlwiKFthLXpBLVpfXVthLXpBLVpfMC05XSopXCIkLykpIHtcblx0ICAgICAgbmFtZSA9IG5hbWUuc3Vic3RyKDEsIG5hbWUubGVuZ3RoIC0gMik7XG5cdCAgICAgIG5hbWUgPSBjdHguc3R5bGl6ZShuYW1lLCAnbmFtZScpO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZSgvJy9nLCBcIlxcXFwnXCIpXG5cdCAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKVxuXHQgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8oXlwifFwiJCkvZywgXCInXCIpO1xuXHQgICAgICBuYW1lID0gY3R4LnN0eWxpemUobmFtZSwgJ3N0cmluZycpO1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIHJldHVybiBuYW1lICsgJzogJyArIHN0cjtcblx0fVxuXG5cblx0ZnVuY3Rpb24gcmVkdWNlVG9TaW5nbGVTdHJpbmcob3V0cHV0LCBiYXNlLCBicmFjZXMpIHtcblx0ICB2YXIgbnVtTGluZXNFc3QgPSAwO1xuXHQgIHZhciBsZW5ndGggPSBvdXRwdXQucmVkdWNlKGZ1bmN0aW9uKHByZXYsIGN1cikge1xuXHQgICAgbnVtTGluZXNFc3QrKztcblx0ICAgIGlmIChjdXIuaW5kZXhPZignXFxuJykgPj0gMCkgbnVtTGluZXNFc3QrKztcblx0ICAgIHJldHVybiBwcmV2ICsgY3VyLnJlcGxhY2UoL1xcdTAwMWJcXFtcXGRcXGQ/bS9nLCAnJykubGVuZ3RoICsgMTtcblx0ICB9LCAwKTtcblxuXHQgIGlmIChsZW5ndGggPiA2MCkge1xuXHQgICAgcmV0dXJuIGJyYWNlc1swXSArXG5cdCAgICAgICAgICAgKGJhc2UgPT09ICcnID8gJycgOiBiYXNlICsgJ1xcbiAnKSArXG5cdCAgICAgICAgICAgJyAnICtcblx0ICAgICAgICAgICBvdXRwdXQuam9pbignLFxcbiAgJykgK1xuXHQgICAgICAgICAgICcgJyArXG5cdCAgICAgICAgICAgYnJhY2VzWzFdO1xuXHQgIH1cblxuXHQgIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgJyAnICsgb3V0cHV0LmpvaW4oJywgJykgKyAnICcgKyBicmFjZXNbMV07XG5cdH1cblxuXG5cdC8vIE5PVEU6IFRoZXNlIHR5cGUgY2hlY2tpbmcgZnVuY3Rpb25zIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIGBpbnN0YW5jZW9mYFxuXHQvLyBiZWNhdXNlIGl0IGlzIGZyYWdpbGUgYW5kIGNhbiBiZSBlYXNpbHkgZmFrZWQgd2l0aCBgT2JqZWN0LmNyZWF0ZSgpYC5cblx0ZnVuY3Rpb24gaXNBcnJheShhcikge1xuXHQgIHJldHVybiBBcnJheS5pc0FycmF5KGFyKTtcblx0fVxuXHRleHBvcnRzLmlzQXJyYXkgPSBpc0FycmF5O1xuXG5cdGZ1bmN0aW9uIGlzQm9vbGVhbihhcmcpIHtcblx0ICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nO1xuXHR9XG5cdGV4cG9ydHMuaXNCb29sZWFuID0gaXNCb29sZWFuO1xuXG5cdGZ1bmN0aW9uIGlzTnVsbChhcmcpIHtcblx0ICByZXR1cm4gYXJnID09PSBudWxsO1xuXHR9XG5cdGV4cG9ydHMuaXNOdWxsID0gaXNOdWxsO1xuXG5cdGZ1bmN0aW9uIGlzTnVsbE9yVW5kZWZpbmVkKGFyZykge1xuXHQgIHJldHVybiBhcmcgPT0gbnVsbDtcblx0fVxuXHRleHBvcnRzLmlzTnVsbE9yVW5kZWZpbmVkID0gaXNOdWxsT3JVbmRlZmluZWQ7XG5cblx0ZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG5cdCAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xuXHR9XG5cdGV4cG9ydHMuaXNOdW1iZXIgPSBpc051bWJlcjtcblxuXHRmdW5jdGlvbiBpc1N0cmluZyhhcmcpIHtcblx0ICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N0cmluZyc7XG5cdH1cblx0ZXhwb3J0cy5pc1N0cmluZyA9IGlzU3RyaW5nO1xuXG5cdGZ1bmN0aW9uIGlzU3ltYm9sKGFyZykge1xuXHQgIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3ltYm9sJztcblx0fVxuXHRleHBvcnRzLmlzU3ltYm9sID0gaXNTeW1ib2w7XG5cblx0ZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG5cdCAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xuXHR9XG5cdGV4cG9ydHMuaXNVbmRlZmluZWQgPSBpc1VuZGVmaW5lZDtcblxuXHRmdW5jdGlvbiBpc1JlZ0V4cChyZSkge1xuXHQgIHJldHVybiBpc09iamVjdChyZSkgJiYgb2JqZWN0VG9TdHJpbmcocmUpID09PSAnW29iamVjdCBSZWdFeHBdJztcblx0fVxuXHRleHBvcnRzLmlzUmVnRXhwID0gaXNSZWdFeHA7XG5cblx0ZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG5cdCAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcblx0fVxuXHRleHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG5cblx0ZnVuY3Rpb24gaXNEYXRlKGQpIHtcblx0ICByZXR1cm4gaXNPYmplY3QoZCkgJiYgb2JqZWN0VG9TdHJpbmcoZCkgPT09ICdbb2JqZWN0IERhdGVdJztcblx0fVxuXHRleHBvcnRzLmlzRGF0ZSA9IGlzRGF0ZTtcblxuXHRmdW5jdGlvbiBpc0Vycm9yKGUpIHtcblx0ICByZXR1cm4gaXNPYmplY3QoZSkgJiZcblx0ICAgICAgKG9iamVjdFRvU3RyaW5nKGUpID09PSAnW29iamVjdCBFcnJvcl0nIHx8IGUgaW5zdGFuY2VvZiBFcnJvcik7XG5cdH1cblx0ZXhwb3J0cy5pc0Vycm9yID0gaXNFcnJvcjtcblxuXHRmdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuXHQgIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xuXHR9XG5cdGV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG5cblx0ZnVuY3Rpb24gaXNQcmltaXRpdmUoYXJnKSB7XG5cdCAgcmV0dXJuIGFyZyA9PT0gbnVsbCB8fFxuXHQgICAgICAgICB0eXBlb2YgYXJnID09PSAnYm9vbGVhbicgfHxcblx0ICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ251bWJlcicgfHxcblx0ICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N0cmluZycgfHxcblx0ICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCcgfHwgIC8vIEVTNiBzeW1ib2xcblx0ICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3VuZGVmaW5lZCc7XG5cdH1cblx0ZXhwb3J0cy5pc1ByaW1pdGl2ZSA9IGlzUHJpbWl0aXZlO1xuXG5cdGV4cG9ydHMuaXNCdWZmZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI1KTtcblxuXHRmdW5jdGlvbiBvYmplY3RUb1N0cmluZyhvKSB7XG5cdCAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKTtcblx0fVxuXG5cblx0ZnVuY3Rpb24gcGFkKG4pIHtcblx0ICByZXR1cm4gbiA8IDEwID8gJzAnICsgbi50b1N0cmluZygxMCkgOiBuLnRvU3RyaW5nKDEwKTtcblx0fVxuXG5cblx0dmFyIG1vbnRocyA9IFsnSmFuJywgJ0ZlYicsICdNYXInLCAnQXByJywgJ01heScsICdKdW4nLCAnSnVsJywgJ0F1ZycsICdTZXAnLFxuXHQgICAgICAgICAgICAgICdPY3QnLCAnTm92JywgJ0RlYyddO1xuXG5cdC8vIDI2IEZlYiAxNjoxOTozNFxuXHRmdW5jdGlvbiB0aW1lc3RhbXAoKSB7XG5cdCAgdmFyIGQgPSBuZXcgRGF0ZSgpO1xuXHQgIHZhciB0aW1lID0gW3BhZChkLmdldEhvdXJzKCkpLFxuXHQgICAgICAgICAgICAgIHBhZChkLmdldE1pbnV0ZXMoKSksXG5cdCAgICAgICAgICAgICAgcGFkKGQuZ2V0U2Vjb25kcygpKV0uam9pbignOicpO1xuXHQgIHJldHVybiBbZC5nZXREYXRlKCksIG1vbnRoc1tkLmdldE1vbnRoKCldLCB0aW1lXS5qb2luKCcgJyk7XG5cdH1cblxuXG5cdC8vIGxvZyBpcyBqdXN0IGEgdGhpbiB3cmFwcGVyIHRvIGNvbnNvbGUubG9nIHRoYXQgcHJlcGVuZHMgYSB0aW1lc3RhbXBcblx0ZXhwb3J0cy5sb2cgPSBmdW5jdGlvbigpIHtcblx0ICBjb25zb2xlLmxvZygnJXMgLSAlcycsIHRpbWVzdGFtcCgpLCBleHBvcnRzLmZvcm1hdC5hcHBseShleHBvcnRzLCBhcmd1bWVudHMpKTtcblx0fTtcblxuXG5cdC8qKlxuXHQgKiBJbmhlcml0IHRoZSBwcm90b3R5cGUgbWV0aG9kcyBmcm9tIG9uZSBjb25zdHJ1Y3RvciBpbnRvIGFub3RoZXIuXG5cdCAqXG5cdCAqIFRoZSBGdW5jdGlvbi5wcm90b3R5cGUuaW5oZXJpdHMgZnJvbSBsYW5nLmpzIHJld3JpdHRlbiBhcyBhIHN0YW5kYWxvbmVcblx0ICogZnVuY3Rpb24gKG5vdCBvbiBGdW5jdGlvbi5wcm90b3R5cGUpLiBOT1RFOiBJZiB0aGlzIGZpbGUgaXMgdG8gYmUgbG9hZGVkXG5cdCAqIGR1cmluZyBib290c3RyYXBwaW5nIHRoaXMgZnVuY3Rpb24gbmVlZHMgdG8gYmUgcmV3cml0dGVuIHVzaW5nIHNvbWUgbmF0aXZlXG5cdCAqIGZ1bmN0aW9ucyBhcyBwcm90b3R5cGUgc2V0dXAgdXNpbmcgbm9ybWFsIEphdmFTY3JpcHQgZG9lcyBub3Qgd29yayBhc1xuXHQgKiBleHBlY3RlZCBkdXJpbmcgYm9vdHN0cmFwcGluZyAoc2VlIG1pcnJvci5qcyBpbiByMTE0OTAzKS5cblx0ICpcblx0ICogQHBhcmFtIHtmdW5jdGlvbn0gY3RvciBDb25zdHJ1Y3RvciBmdW5jdGlvbiB3aGljaCBuZWVkcyB0byBpbmhlcml0IHRoZVxuXHQgKiAgICAgcHJvdG90eXBlLlxuXHQgKiBAcGFyYW0ge2Z1bmN0aW9ufSBzdXBlckN0b3IgQ29uc3RydWN0b3IgZnVuY3Rpb24gdG8gaW5oZXJpdCBwcm90b3R5cGUgZnJvbS5cblx0ICovXG5cdGV4cG9ydHMuaW5oZXJpdHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI2KTtcblxuXHRleHBvcnRzLl9leHRlbmQgPSBmdW5jdGlvbihvcmlnaW4sIGFkZCkge1xuXHQgIC8vIERvbid0IGRvIGFueXRoaW5nIGlmIGFkZCBpc24ndCBhbiBvYmplY3Rcblx0ICBpZiAoIWFkZCB8fCAhaXNPYmplY3QoYWRkKSkgcmV0dXJuIG9yaWdpbjtcblxuXHQgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoYWRkKTtcblx0ICB2YXIgaSA9IGtleXMubGVuZ3RoO1xuXHQgIHdoaWxlIChpLS0pIHtcblx0ICAgIG9yaWdpbltrZXlzW2ldXSA9IGFkZFtrZXlzW2ldXTtcblx0ICB9XG5cdCAgcmV0dXJuIG9yaWdpbjtcblx0fTtcblxuXHRmdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmosIHByb3ApIHtcblx0ICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7XG5cdH1cblxuXHQvKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwoZXhwb3J0cywgKGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSgpKSwgX193ZWJwYWNrX3JlcXVpcmVfXygyNCkpKVxuXG4vKioqLyB9KSxcbi8qIDI0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0Ly8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG5cdHZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuXHQvLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcblx0Ly8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG5cdC8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcblx0Ly8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxuXHR2YXIgY2FjaGVkU2V0VGltZW91dDtcblx0dmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuXHRmdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuXHQgICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG5cdH1cblx0ZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG5cdCAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xuXHR9XG5cdChmdW5jdGlvbiAoKSB7XG5cdCAgICB0cnkge1xuXHQgICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcblx0ICAgICAgICB9XG5cdCAgICB9IGNhdGNoIChlKSB7XG5cdCAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG5cdCAgICB9XG5cdCAgICB0cnkge1xuXHQgICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG5cdCAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuXHQgICAgICAgIH1cblx0ICAgIH0gY2F0Y2ggKGUpIHtcblx0ICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuXHQgICAgfVxuXHR9ICgpKVxuXHRmdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuXHQgICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcblx0ICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcblx0ICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuXHQgICAgfVxuXHQgICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcblx0ICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuXHQgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuXHQgICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG5cdCAgICB9XG5cdCAgICB0cnkge1xuXHQgICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3Ncblx0ICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuXHQgICAgfSBjYXRjaChlKXtcblx0ICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcblx0ICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuXHQgICAgICAgIH0gY2F0Y2goZSl7XG5cdCAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG5cdCAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cblxuXHR9XG5cdGZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcblx0ICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuXHQgICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuXHQgICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcblx0ICAgIH1cblx0ICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcblx0ICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuXHQgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcblx0ICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG5cdCAgICB9XG5cdCAgICB0cnkge1xuXHQgICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3Ncblx0ICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG5cdCAgICB9IGNhdGNoIChlKXtcblx0ICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG5cdCAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuXHQgICAgICAgIH0gY2F0Y2ggKGUpe1xuXHQgICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cblx0ICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuXHQgICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cblxuXG5cdH1cblx0dmFyIHF1ZXVlID0gW107XG5cdHZhciBkcmFpbmluZyA9IGZhbHNlO1xuXHR2YXIgY3VycmVudFF1ZXVlO1xuXHR2YXIgcXVldWVJbmRleCA9IC0xO1xuXG5cdGZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcblx0ICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuXHQgICAgICAgIHJldHVybjtcblx0ICAgIH1cblx0ICAgIGRyYWluaW5nID0gZmFsc2U7XG5cdCAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuXHQgICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcblx0ICAgIH1cblx0ICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcblx0ICAgICAgICBkcmFpblF1ZXVlKCk7XG5cdCAgICB9XG5cdH1cblxuXHRmdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuXHQgICAgaWYgKGRyYWluaW5nKSB7XG5cdCAgICAgICAgcmV0dXJuO1xuXHQgICAgfVxuXHQgICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG5cdCAgICBkcmFpbmluZyA9IHRydWU7XG5cblx0ICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG5cdCAgICB3aGlsZShsZW4pIHtcblx0ICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcblx0ICAgICAgICBxdWV1ZSA9IFtdO1xuXHQgICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcblx0ICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuXHQgICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcblx0ICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG5cdCAgICB9XG5cdCAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuXHQgICAgZHJhaW5pbmcgPSBmYWxzZTtcblx0ICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcblx0fVxuXG5cdHByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG5cdCAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG5cdCAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcblx0ICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cdCAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuXHQgICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcblx0ICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuXHQgICAgfVxuXHR9O1xuXG5cdC8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcblx0ZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG5cdCAgICB0aGlzLmZ1biA9IGZ1bjtcblx0ICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcblx0fVxuXHRJdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG5cdCAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcblx0fTtcblx0cHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcblx0cHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcblx0cHJvY2Vzcy5lbnYgPSB7fTtcblx0cHJvY2Vzcy5hcmd2ID0gW107XG5cdHByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xuXHRwcm9jZXNzLnZlcnNpb25zID0ge307XG5cblx0ZnVuY3Rpb24gbm9vcCgpIHt9XG5cblx0cHJvY2Vzcy5vbiA9IG5vb3A7XG5cdHByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xuXHRwcm9jZXNzLm9uY2UgPSBub29wO1xuXHRwcm9jZXNzLm9mZiA9IG5vb3A7XG5cdHByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xuXHRwcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5cdHByb2Nlc3MuZW1pdCA9IG5vb3A7XG5cdHByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDtcblx0cHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxuXHRwcm9jZXNzLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBbXSB9XG5cblx0cHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcblx0ICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcblx0fTtcblxuXHRwcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xuXHRwcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuXHQgICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcblx0fTtcblx0cHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcblxuXG4vKioqLyB9KSxcbi8qIDI1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0J1ZmZlcihhcmcpIHtcblx0ICByZXR1cm4gYXJnICYmIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnXG5cdCAgICAmJiB0eXBlb2YgYXJnLmNvcHkgPT09ICdmdW5jdGlvbidcblx0ICAgICYmIHR5cGVvZiBhcmcuZmlsbCA9PT0gJ2Z1bmN0aW9uJ1xuXHQgICAgJiYgdHlwZW9mIGFyZy5yZWFkVUludDggPT09ICdmdW5jdGlvbic7XG5cdH1cblxuLyoqKi8gfSksXG4vKiAyNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdGlmICh0eXBlb2YgT2JqZWN0LmNyZWF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuXHQgIC8vIGltcGxlbWVudGF0aW9uIGZyb20gc3RhbmRhcmQgbm9kZS5qcyAndXRpbCcgbW9kdWxlXG5cdCAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcblx0ICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG5cdCAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSwge1xuXHQgICAgICBjb25zdHJ1Y3Rvcjoge1xuXHQgICAgICAgIHZhbHVlOiBjdG9yLFxuXHQgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuXHQgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuXHQgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuXHQgICAgICB9XG5cdCAgICB9KTtcblx0ICB9O1xuXHR9IGVsc2Uge1xuXHQgIC8vIG9sZCBzY2hvb2wgc2hpbSBmb3Igb2xkIGJyb3dzZXJzXG5cdCAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcblx0ICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG5cdCAgICB2YXIgVGVtcEN0b3IgPSBmdW5jdGlvbiAoKSB7fVxuXHQgICAgVGVtcEN0b3IucHJvdG90eXBlID0gc3VwZXJDdG9yLnByb3RvdHlwZVxuXHQgICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgVGVtcEN0b3IoKVxuXHQgICAgY3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjdG9yXG5cdCAgfVxuXHR9XG5cblxuLyoqKi8gfSksXG4vKiAyNyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdHZhciBET00gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpO1xuXHR2YXIgdXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpO1xuXG5cdG1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uKCkge1xuXHQgICAgdmFyIGNhbnZhcyA9IERPTS5uZXdFbCgnY2FudmFzJyk7XG5cdCAgICB2YXIgY3R4ID0gbnVsbDtcblxuXHQgICAgcmV0dXJuIGZ1bmN0aW9uKHNjZW5lR3JhcGgpIHtcblx0ICAgICAgICBpZiAoY3R4ID09IG51bGwpIHtcblx0ICAgICAgICAgICAgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgdmFyIGRwciA9IHV0aWxzLmNhbnZhc1JhdGlvKCk7XG5cdCAgICAgICAgdmFyIHJvb3QgPSBzY2VuZUdyYXBoLnJvb3Q7XG5cdCAgICAgICAgY2FudmFzLndpZHRoID0gZHByICogcm9vdC5wcm9wZXJ0aWVzLndpZHRoO1xuXHQgICAgICAgIGNhbnZhcy5oZWlnaHQgPSBkcHIgKiByb290LnByb3BlcnRpZXMuaGVpZ2h0IDtcblx0ICAgICAgICBjdHgudGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG5cblx0ICAgICAgICB2YXIgYmcgPSByb290LmNoaWxkcmVuLmhvbGRlckJnO1xuXHQgICAgICAgIHZhciBiZ1dpZHRoID0gZHByICogYmcud2lkdGg7XG5cdCAgICAgICAgdmFyIGJnSGVpZ2h0ID0gZHByICogYmcuaGVpZ2h0O1xuXHQgICAgICAgIC8vdG9kbzogcGFyYW1ldHJpemUgb3V0bGluZSB3aWR0aCAoZS5nLiBpbiBzY2VuZSBvYmplY3QpXG5cdCAgICAgICAgdmFyIG91dGxpbmVXaWR0aCA9IDI7XG5cdCAgICAgICAgdmFyIG91dGxpbmVPZmZzZXRXaWR0aCA9IG91dGxpbmVXaWR0aCAvIDI7XG5cblx0ICAgICAgICBjdHguZmlsbFN0eWxlID0gYmcucHJvcGVydGllcy5maWxsO1xuXHQgICAgICAgIGN0eC5maWxsUmVjdCgwLCAwLCBiZ1dpZHRoLCBiZ0hlaWdodCk7XG5cblx0ICAgICAgICBpZiAoYmcucHJvcGVydGllcy5vdXRsaW5lKSB7XG5cdCAgICAgICAgICAgIC8vdG9kbzogYWJzdHJhY3QgdGhpcyBpbnRvIGEgbWV0aG9kXG5cdCAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGJnLnByb3BlcnRpZXMub3V0bGluZS5maWxsO1xuXHQgICAgICAgICAgICBjdHgubGluZVdpZHRoID0gYmcucHJvcGVydGllcy5vdXRsaW5lLndpZHRoO1xuXHQgICAgICAgICAgICBjdHgubW92ZVRvKG91dGxpbmVPZmZzZXRXaWR0aCwgb3V0bGluZU9mZnNldFdpZHRoKTtcblx0ICAgICAgICAgICAgLy8gVEwsIFRSLCBCUiwgQkxcblx0ICAgICAgICAgICAgY3R4LmxpbmVUbyhiZ1dpZHRoIC0gb3V0bGluZU9mZnNldFdpZHRoLCBvdXRsaW5lT2Zmc2V0V2lkdGgpO1xuXHQgICAgICAgICAgICBjdHgubGluZVRvKGJnV2lkdGggLSBvdXRsaW5lT2Zmc2V0V2lkdGgsIGJnSGVpZ2h0IC0gb3V0bGluZU9mZnNldFdpZHRoKTtcblx0ICAgICAgICAgICAgY3R4LmxpbmVUbyhvdXRsaW5lT2Zmc2V0V2lkdGgsIGJnSGVpZ2h0IC0gb3V0bGluZU9mZnNldFdpZHRoKTtcblx0ICAgICAgICAgICAgY3R4LmxpbmVUbyhvdXRsaW5lT2Zmc2V0V2lkdGgsIG91dGxpbmVPZmZzZXRXaWR0aCk7XG5cdCAgICAgICAgICAgIC8vIERpYWdvbmFsc1xuXHQgICAgICAgICAgICBjdHgubW92ZVRvKDAsIG91dGxpbmVPZmZzZXRXaWR0aCk7XG5cdCAgICAgICAgICAgIGN0eC5saW5lVG8oYmdXaWR0aCwgYmdIZWlnaHQgLSBvdXRsaW5lT2Zmc2V0V2lkdGgpO1xuXHQgICAgICAgICAgICBjdHgubW92ZVRvKDAsIGJnSGVpZ2h0IC0gb3V0bGluZU9mZnNldFdpZHRoKTtcblx0ICAgICAgICAgICAgY3R4LmxpbmVUbyhiZ1dpZHRoLCBvdXRsaW5lT2Zmc2V0V2lkdGgpO1xuXHQgICAgICAgICAgICBjdHguc3Ryb2tlKCk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgdmFyIHRleHRHcm91cCA9IHJvb3QuY2hpbGRyZW4uaG9sZGVyVGV4dEdyb3VwO1xuXHQgICAgICAgIGN0eC5mb250ID0gdGV4dEdyb3VwLnByb3BlcnRpZXMuZm9udC53ZWlnaHQgKyAnICcgKyAoZHByICogdGV4dEdyb3VwLnByb3BlcnRpZXMuZm9udC5zaXplKSArIHRleHRHcm91cC5wcm9wZXJ0aWVzLmZvbnQudW5pdHMgKyAnICcgKyB0ZXh0R3JvdXAucHJvcGVydGllcy5mb250LmZhbWlseSArICcsIG1vbm9zcGFjZSc7XG5cdCAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHRleHRHcm91cC5wcm9wZXJ0aWVzLmZpbGw7XG5cblx0ICAgICAgICBmb3IgKHZhciBsaW5lS2V5IGluIHRleHRHcm91cC5jaGlsZHJlbikge1xuXHQgICAgICAgICAgICB2YXIgbGluZSA9IHRleHRHcm91cC5jaGlsZHJlbltsaW5lS2V5XTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgd29yZEtleSBpbiBsaW5lLmNoaWxkcmVuKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgd29yZCA9IGxpbmUuY2hpbGRyZW5bd29yZEtleV07XG5cdCAgICAgICAgICAgICAgICB2YXIgeCA9IGRwciAqICh0ZXh0R3JvdXAueCArIGxpbmUueCArIHdvcmQueCk7XG5cdCAgICAgICAgICAgICAgICB2YXIgeSA9IGRwciAqICh0ZXh0R3JvdXAueSArIGxpbmUueSArIHdvcmQueSArICh0ZXh0R3JvdXAucHJvcGVydGllcy5sZWFkaW5nIC8gMikpO1xuXG5cdCAgICAgICAgICAgICAgICBjdHguZmlsbFRleHQod29yZC5wcm9wZXJ0aWVzLnRleHQsIHgsIHkpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgcmV0dXJuIGNhbnZhcy50b0RhdGFVUkwoJ2ltYWdlL3BuZycpO1xuXHQgICAgfTtcblx0fSkoKTtcblxuLyoqKi8gfSlcbi8qKioqKiovIF0pXG59KTtcbjtcbihmdW5jdGlvbihjdHgsIGlzTWV0ZW9yUGFja2FnZSkge1xuICAgIGlmIChpc01ldGVvclBhY2thZ2UpIHtcbiAgICAgICAgSG9sZGVyID0gY3R4LkhvbGRlcjtcbiAgICB9XG59KSh0aGlzLCB0eXBlb2YgTWV0ZW9yICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgUGFja2FnZSAhPT0gJ3VuZGVmaW5lZCcpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9